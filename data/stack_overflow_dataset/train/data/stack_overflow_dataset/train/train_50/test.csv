PostId,PostCreationDate,OwnerUserId,OwnerCreationDate,ReputationAtPostCreation,OwnerUndeletedAnswerCountAtPostTime,Title,BodyMarkdown,Tag1,Tag2,Tag3,Tag4,Tag5,PostClosedDate,OpenStatus,OpenStatusInt,BodyLength,TitleLength,TitleConcatWithBody,NumberOfTags
6386127,06/17/2011 13:02:33,803258,06/17/2011 13:02:33,1,0,Create a utf8 file in linux in c programing,"I have to create a utf8 file (say utf8_test.txt)  in linux (Ubuntu), in c.
I tried fopen(), but it create hte file depending on the Locale - as the locale was en_IN, it created in Ascii I guess.

Is there any interface or function by which I can specify the format of the file to open or I need to add some byte in the beginning of the file, so that the OS understands that it is a UTF8 file?

Please give your valuable inputs.

Thank you.


 
",c,linux,file,utf-8,,05/24/2012 03:39:13,not a real question,1,85,9,"Create a utf8 file in linux in c programing I have to create a utf8 file (say utf8_test.txt)  in linux (Ubuntu), in c.
I tried fopen(), but it create hte file depending on the Locale - as the locale was en_IN, it created in Ascii I guess.

Is there any interface or function by which I can specify the format of the file to open or I need to add some byte in the beginning of the file, so that the OS understands that it is a UTF8 file?

Please give your valuable inputs.

Thank you.


 
",4
7657362,10/05/2011 06:15:09,520162,11/25/2010 12:46:16,4107,183,How do I ensure that two types have the same size?,"In my code, I want to ensure that `sizeof(a) == sizeof(b)`.

First approach was to let the preprocessor do the checking:

    #if (sizeof(a) != sizeof(b))
    #  error sizes don't match
    #endif

which doesn't compile because of `fatal error C1017: invalid integer constant expression`. Okay. Understand.

Next try:

    if(sizeof(a) != sizeof(b)){
      printf(""sizes don't match\n"");
      return -1;
    }

Which results in a warning: `warning C4127: conditional expression is constant`.

Now, I'm stuck. Is there a warning-and-error-free way to make sure that the two structs `a` and `b` have the same size?",c,visual-studio-2005,,,,,open,0,110,11,"How do I ensure that two types have the same size? In my code, I want to ensure that `sizeof(a) == sizeof(b)`.

First approach was to let the preprocessor do the checking:

    #if (sizeof(a) != sizeof(b))
    #  error sizes don't match
    #endif

which doesn't compile because of `fatal error C1017: invalid integer constant expression`. Okay. Understand.

Next try:

    if(sizeof(a) != sizeof(b)){
      printf(""sizes don't match\n"");
      return -1;
    }

Which results in a warning: `warning C4127: conditional expression is constant`.

Now, I'm stuck. Is there a warning-and-error-free way to make sure that the two structs `a` and `b` have the same size?",2
10418738,05/02/2012 17:27:13,277800,02/20/2010 20:02:21,4364,131,why are both i[a] and a[i] valid in C?,"For example consider:

    int i = 3;
    int a[4] = {0,1,2,3};

then both `i[a]` and `a[i]` are valid expressions, much like `*(i + a)` and `*(a + i)`.

My question is: why did the language designers choose to allow this? Why not just enforce that `i[a]` is invalid, for clarity's sake?",c,arrays,pointers,standards,,05/03/2012 19:56:50,not constructive,1,55,9,"why are both i[a] and a[i] valid in C? For example consider:

    int i = 3;
    int a[4] = {0,1,2,3};

then both `i[a]` and `a[i]` are valid expressions, much like `*(i + a)` and `*(a + i)`.

My question is: why did the language designers choose to allow this? Why not just enforce that `i[a]` is invalid, for clarity's sake?",4
8515782,12/15/2011 06:00:08,974380,10/01/2011 10:35:45,20,0,read string of character and assign it to an array," I don't know how to work with scanf and get the input of it for the entry of the function readBigNum I want to make array until the user entered the Enter and also I want to write a function for assigning it into an array and return the size of the large number
I want readBigNum to exactly have the char *n but I can not relate it in my function  

      #include <stdio.h>
        
        int readBigNum(char *n)
        {
        char msg[100],ch;
        	int i=0;
        while((ch=getchar())!='\n')
        {
        if(ch!='0'||ch!='1'||ch!='2'||ch!='3'||ch!='4'||ch!='5'||ch!='6'||ch!='7'||ch!='8'||ch!='9')
        return -1;
        msg[i++]=ch;
        		}
        	msg[i]='\0';
        	i=0;
        	return i;
        }
        int main()       
        {
        const char x;
        	const char n;
        n=scanf(""%d"",x);
        int h=readBigNum(&n);
        	printf(h);
        }",c,arrays,,,,,open,0,284,10,"read string of character and assign it to an array  I don't know how to work with scanf and get the input of it for the entry of the function readBigNum I want to make array until the user entered the Enter and also I want to write a function for assigning it into an array and return the size of the large number
I want readBigNum to exactly have the char *n but I can not relate it in my function  

      #include <stdio.h>
        
        int readBigNum(char *n)
        {
        char msg[100],ch;
        	int i=0;
        while((ch=getchar())!='\n')
        {
        if(ch!='0'||ch!='1'||ch!='2'||ch!='3'||ch!='4'||ch!='5'||ch!='6'||ch!='7'||ch!='8'||ch!='9')
        return -1;
        msg[i++]=ch;
        		}
        	msg[i]='\0';
        	i=0;
        	return i;
        }
        int main()       
        {
        const char x;
        	const char n;
        n=scanf(""%d"",x);
        int h=readBigNum(&n);
        	printf(h);
        }",2
9337597,02/18/2012 01:14:24,548266,12/20/2010 06:11:02,1,0,Supress output from POPEN,"Is there a way to suppress the output from POPEN without loosing the Wait().

**Test 1:**

    FILE * stream = NULL;
    char buffer [120];
    
    stream = popen (""ffmpeg -y -i test.amr -ar 16000 test.wav -v quiet"", ""r"");
    
    while (fgets (buffer, sizeof(buffer), stream))
    {
    }
    
    pclose (stream);

**Test 2:**

    FILE * stream = NULL;
    char buffer [120];
    
    stream = popen (""ffmpeg -y -i test.amr -ar 16000 test.wav -v quiet &> /dev/null"", ""r"");
    
    while (fgets (buffer, sizeof(buffer), stream))
    {
    }
    
    pclose (stream);

The problem with **Test 2** is that pclose is not waiting for the pipe to finish processing.  I don't want to have a bunch of FFMPEG output every time I have to do a pipe. ",c,linux,ffmpeg,popen,suppress,,open,0,180,4,"Supress output from POPEN Is there a way to suppress the output from POPEN without loosing the Wait().

**Test 1:**

    FILE * stream = NULL;
    char buffer [120];
    
    stream = popen (""ffmpeg -y -i test.amr -ar 16000 test.wav -v quiet"", ""r"");
    
    while (fgets (buffer, sizeof(buffer), stream))
    {
    }
    
    pclose (stream);

**Test 2:**

    FILE * stream = NULL;
    char buffer [120];
    
    stream = popen (""ffmpeg -y -i test.amr -ar 16000 test.wav -v quiet &> /dev/null"", ""r"");
    
    while (fgets (buffer, sizeof(buffer), stream))
    {
    }
    
    pclose (stream);

The problem with **Test 2** is that pclose is not waiting for the pipe to finish processing.  I don't want to have a bunch of FFMPEG output every time I have to do a pipe. ",5
2531088,03/27/2010 21:50:30,255355,01/20/2010 23:24:37,34,1,Read options from file,"I would like to write a function which will read values from a text file and write them to variables. For example my file is:

    mysql_server localhost
    mysql_user root
    mysql_passworg abcdefg
    mysql_database testgenerator
    log log.txt
    username admin
    password abcd

and I have the same variables as the first word in the line. 
So how to make the function read data from file and do sth like this:

    char *mysql_server = localhost;
    char *mysql_user = root;
    ...

I have no idea even how to start writing it... ",c,file,,,,,open,0,115,4,"Read options from file I would like to write a function which will read values from a text file and write them to variables. For example my file is:

    mysql_server localhost
    mysql_user root
    mysql_passworg abcdefg
    mysql_database testgenerator
    log log.txt
    username admin
    password abcd

and I have the same variables as the first word in the line. 
So how to make the function read data from file and do sth like this:

    char *mysql_server = localhost;
    char *mysql_user = root;
    ...

I have no idea even how to start writing it... ",2
9703133,03/14/2012 13:40:18,1012824,10/25/2011 13:45:55,1,0,objact-c Interpretation of the picture binary information,I want to get a the UIImagePickerController return UIImage name,c,ios,,,,03/14/2012 20:29:25,not a real question,1,10,7,objact-c Interpretation of the picture binary information I want to get a the UIImagePickerController return UIImage name,2
6555541,07/02/2011 06:48:31,778245,05/31/2011 19:25:38,47,0,Sending Hexadecimal data through Serial Port Communication in Linux,"I have got a task of sending hexadecimal data to my COMPORT in linux. I have written this simple C code, but it sends only a decimal number. Can anyone help me in sending an hexadecimal bit.

Here is the code I have written

`
    #include <stdio.h>   /* Standard input/output definitions */
    #include <string.h>  /* String function definitions */
    #include <unistd.h>  /* UNIX standard function definitions */
    #include <fcntl.h>   /* File control definitions */
    #include <errno.h>   /* Error number definitions */
    #include <termios.h> /* POSIX terminal control definitions */

   int number,n;
    void main(void){
    open_port(); 
    }
    
      int open_port(void)
    {
      int fd; /* File descriptor for the port */


      fd = open(""/dev/ttyACM0"", O_RDWR | O_NOCTTY | O_NDELAY);
      if (fd == -1)
      {

	perror(""open_port: Unable to open /dev/ttyACM0 - "");
      }
      else{
         printf(""Port Opened successfully\n"");
         number = 1;
         while(number!=55){
         scanf(""%d"",&number);
          n = write(fd, ""ATZ\r"", number);
         if (n < 0)
         fputs(""write() of 4 bytes failed!\n"", stderr);
         }
	

 }

      return (fd);
    }

     
    
`

Please help

Thanks in advance :) :)",c,serial-port,hex,acm,,,open,0,321,9,"Sending Hexadecimal data through Serial Port Communication in Linux I have got a task of sending hexadecimal data to my COMPORT in linux. I have written this simple C code, but it sends only a decimal number. Can anyone help me in sending an hexadecimal bit.

Here is the code I have written

`
    #include <stdio.h>   /* Standard input/output definitions */
    #include <string.h>  /* String function definitions */
    #include <unistd.h>  /* UNIX standard function definitions */
    #include <fcntl.h>   /* File control definitions */
    #include <errno.h>   /* Error number definitions */
    #include <termios.h> /* POSIX terminal control definitions */

   int number,n;
    void main(void){
    open_port(); 
    }
    
      int open_port(void)
    {
      int fd; /* File descriptor for the port */


      fd = open(""/dev/ttyACM0"", O_RDWR | O_NOCTTY | O_NDELAY);
      if (fd == -1)
      {

	perror(""open_port: Unable to open /dev/ttyACM0 - "");
      }
      else{
         printf(""Port Opened successfully\n"");
         number = 1;
         while(number!=55){
         scanf(""%d"",&number);
          n = write(fd, ""ATZ\r"", number);
         if (n < 0)
         fputs(""write() of 4 bytes failed!\n"", stderr);
         }
	

 }

      return (fd);
    }

     
    
`

Please help

Thanks in advance :) :)",4
9419596,02/23/2012 19:11:12,1229165,02/23/2012 19:07:59,1,0,How do I use google code and git?,"I wrote a little program in C, a simple command line calculator of sorts. I want to put the source on google code, but i can't figure out the git hosting? I dont know anything about repositories or anything about git. If someone could explain to me a step by step of how to setup google code with git that would be great. ",c,git,google,version-control,repository,02/24/2012 06:42:26,too localized,1,64,8,"How do I use google code and git? I wrote a little program in C, a simple command line calculator of sorts. I want to put the source on google code, but i can't figure out the git hosting? I dont know anything about repositories or anything about git. If someone could explain to me a step by step of how to setup google code with git that would be great. ",5
4517539,12/23/2010 09:45:21,544532,12/16/2010 09:22:05,1,0,C float division,"how do i divide 2 float-type numbers in a variable?

ex.
float num1 = 1;
float num2 = 2;

float res = num1/num2;

how do i get 0.5 without changing the initialization?

thanks in advance :)
",c,float,division,,,12/23/2010 10:47:48,not a real question,1,30,3,"C float division how do i divide 2 float-type numbers in a variable?

ex.
float num1 = 1;
float num2 = 2;

float res = num1/num2;

how do i get 0.5 without changing the initialization?

thanks in advance :)
",3
101439,09/19/2008 12:30:30,8123,09/15/2008 15:13:32,569,32,"The most efficient way to implement an integer based power function pow(int, int)","What is the most efficient way given to raise an integer to the power of another integer in C?

    // 2^3
    pow(2,3) == 6

    // 5^5
    pow(5,5) == 3125

",c,efficiency,,,,,open,0,41,13,"The most efficient way to implement an integer based power function pow(int, int) What is the most efficient way given to raise an integer to the power of another integer in C?

    // 2^3
    pow(2,3) == 6

    // 5^5
    pow(5,5) == 3125

",2
11282672,07/01/2012 14:14:33,1494340,07/01/2012 14:11:26,1,0,How do i create sin function with C language?,"I want to create sin function with math.h library in C, in output I want the line of the sin function.
Thanks ",c,sin,,,,07/01/2012 14:30:03,not a real question,1,22,9,"How do i create sin function with C language? I want to create sin function with math.h library in C, in output I want the line of the sin function.
Thanks ",2
5825683,04/28/2011 22:17:21,668452,03/20/2011 18:16:12,74,3,"Heapsort in C, index 0 issue.","for a project for school I have decided to solve a problem by coding a HeapSort but I have an issue. (""vector"" is the vector to sort and ""n"" is the number of elements in ""vector"")

Here is my code :

    void fixHeap(int position,int length)
    {
        int next=2*position;
        int temp;
    
        while (next<=length)
        {
            if (next<length && vector[next]<vector[next+1])
            {
                next++;
            }
            if (vector[position]<vector[next])
            {
                temp=vector[position];
                vector[position]=vector[next];
                vector[next]=temp;
                position=next;
                next=2*position;
            }
            else
            {
                return;
            }
        }
    }
    
    void heapSort()
    {
        int counter;
        int temp;
    
        for(counter=(n-1)/2;counter==0;counter--)
        {
            fixHeap(counter,n-1);
        }
        for(counter=n-1;counter>0;counter--)
        {
            temp=vector[counter]; 
            vector[counter]=vector[0];
            vector[0]=temp;
            fixHeap(0,counter-1);
        }
        display();
    }

When I'm doing fixHeap(0,n-1) I'm putting next to 0 and then position is also at 0 so I'm not really doing the Heap right. Could someone help me fixing it?

Also are there other mistakes that you spotted that I may have overlooked? ",c,homework,vector,heapsort,,,open,0,524,6,"Heapsort in C, index 0 issue. for a project for school I have decided to solve a problem by coding a HeapSort but I have an issue. (""vector"" is the vector to sort and ""n"" is the number of elements in ""vector"")

Here is my code :

    void fixHeap(int position,int length)
    {
        int next=2*position;
        int temp;
    
        while (next<=length)
        {
            if (next<length && vector[next]<vector[next+1])
            {
                next++;
            }
            if (vector[position]<vector[next])
            {
                temp=vector[position];
                vector[position]=vector[next];
                vector[next]=temp;
                position=next;
                next=2*position;
            }
            else
            {
                return;
            }
        }
    }
    
    void heapSort()
    {
        int counter;
        int temp;
    
        for(counter=(n-1)/2;counter==0;counter--)
        {
            fixHeap(counter,n-1);
        }
        for(counter=n-1;counter>0;counter--)
        {
            temp=vector[counter]; 
            vector[counter]=vector[0];
            vector[0]=temp;
            fixHeap(0,counter-1);
        }
        display();
    }

When I'm doing fixHeap(0,n-1) I'm putting next to 0 and then position is also at 0 so I'm not really doing the Heap right. Could someone help me fixing it?

Also are there other mistakes that you spotted that I may have overlooked? ",4
10758728,05/25/2012 17:17:46,655295,03/11/2011 12:01:05,887,1,finding out modified element in an array using XOR property,"This question is being attempted from [here][1]

> How to find out modified element in an array?
> 
> Eg: Array A= {1,2,3,4,5,6} before modifiction After modification
> A={1,2,3,7,5,6}. Here the element 4 is replaced with element 7.

Some one used a XOR Property to solve this problem 

     int getModifiedElement(int arr1[ ],int arr2[ ])
           {
                       int xor1 = arr1[0];
                       int xor2 = arr2[0];
                                  for(int i=1;<i<arr1.length;i++)
                                  {
                                         xor1 = xor1 ^ arr1[i];
                                         xor2 = xor2 ^ arr2[i];
                                  }
                 return xor1^xor2;
                }


I am not clear with what XOR property has been used to solve the problem?
  [1]: http://www.careercup.com/question?id=13718667",c,bitwise,xor,,,05/29/2012 13:30:42,too localized,1,362,10,"finding out modified element in an array using XOR property This question is being attempted from [here][1]

> How to find out modified element in an array?
> 
> Eg: Array A= {1,2,3,4,5,6} before modifiction After modification
> A={1,2,3,7,5,6}. Here the element 4 is replaced with element 7.

Some one used a XOR Property to solve this problem 

     int getModifiedElement(int arr1[ ],int arr2[ ])
           {
                       int xor1 = arr1[0];
                       int xor2 = arr2[0];
                                  for(int i=1;<i<arr1.length;i++)
                                  {
                                         xor1 = xor1 ^ arr1[i];
                                         xor2 = xor2 ^ arr2[i];
                                  }
                 return xor1^xor2;
                }


I am not clear with what XOR property has been used to solve the problem?
  [1]: http://www.careercup.com/question?id=13718667",3
7791718,10/17/2011 09:23:00,623975,02/19/2011 00:50:35,191,7,Request for a code quality check on an integer to string function written in C,"For an embedded systems class, I had to write an integer to string function.  I tried to make it as clear and versitile as possible, but I still know it's pretty noob-ish.

Does anyone have any comments / suggestions?


    // takes a char* container, and integer to print, and a number of digits
    // will add leading spaces if necessary, eg:
    // toPrint = 12 digits = 3 = ' 12'
    void printInt(uchar* container, int toPrint, int digits) {
      int decade = 1;
      for (digits--; digits > 0; digits--)
	decade *= 10;
      if (decade * 10 < toPrint) {
	return;
      }
      int i = 0;
      int temp;
      short zerosTrigger = 0;
      for (; decade > 0; decade /= 10) {
	if (toPrint < decade) {
	  if (zerosTrigger) {
            container[i++] = 48;
	  } else {
            if (decade == 1) {
              container[i++] = 48;              
            } else {
              container[i++] = ' ';
            }
	  }
	} else {
	  if (!zerosTrigger) {
            zerosTrigger = 1;
	  }
	  temp = toPrint % decade;
	  container[i++] = 48 + (toPrint - temp) / decade;
	  toPrint = temp;
	}
      }
      container[i] = '\0';
    }
",c,string,integer,embedded,,10/17/2011 09:28:37,off topic,1,347,15,"Request for a code quality check on an integer to string function written in C For an embedded systems class, I had to write an integer to string function.  I tried to make it as clear and versitile as possible, but I still know it's pretty noob-ish.

Does anyone have any comments / suggestions?


    // takes a char* container, and integer to print, and a number of digits
    // will add leading spaces if necessary, eg:
    // toPrint = 12 digits = 3 = ' 12'
    void printInt(uchar* container, int toPrint, int digits) {
      int decade = 1;
      for (digits--; digits > 0; digits--)
	decade *= 10;
      if (decade * 10 < toPrint) {
	return;
      }
      int i = 0;
      int temp;
      short zerosTrigger = 0;
      for (; decade > 0; decade /= 10) {
	if (toPrint < decade) {
	  if (zerosTrigger) {
            container[i++] = 48;
	  } else {
            if (decade == 1) {
              container[i++] = 48;              
            } else {
              container[i++] = ' ';
            }
	  }
	} else {
	  if (!zerosTrigger) {
            zerosTrigger = 1;
	  }
	  temp = toPrint % decade;
	  container[i++] = 48 + (toPrint - temp) / decade;
	  toPrint = temp;
	}
      }
      container[i] = '\0';
    }
",4
3209310,07/09/2010 01:56:51,72437,03/01/2009 11:00:43,1563,43," wchar_t pointer manipulation - How to check whether it is ended with L"".xls""","I am using C. I have a wchar_t pointer which pointing a a file path.

I was wondering, how I can check, whether it is ended with L"".xls""?

Any function call I can use?",c,,,,,,open,0,32,14," wchar_t pointer manipulation - How to check whether it is ended with L"".xls"" I am using C. I have a wchar_t pointer which pointing a a file path.

I was wondering, how I can check, whether it is ended with L"".xls""?

Any function call I can use?",1
7563407,09/27/2011 01:55:52,481061,10/19/2010 22:11:10,981,15,SO's 404 page - BF program within C program?,"I have just gotten the StackOverflow 404 page by trying to open [a deleted question][1]. 

It contains this image of what seem to be several programs interleaved in one file, written in C, Brainfuck and possibly something I don't recognize.

![enter image description here][2]

Is there a name for this kind of source code which represents several valid programs in different programming languages? What programs are contained in this example?


  [1]: http://stackoverflow.com/questions/498512/how-to-be-an-eco-friendly-programmer
  [2]: http://i.stack.imgur.com/PZiSq.png",c,brainfuck,,,,09/27/2011 04:49:51,off topic,1,74,9,"SO's 404 page - BF program within C program? I have just gotten the StackOverflow 404 page by trying to open [a deleted question][1]. 

It contains this image of what seem to be several programs interleaved in one file, written in C, Brainfuck and possibly something I don't recognize.

![enter image description here][2]

Is there a name for this kind of source code which represents several valid programs in different programming languages? What programs are contained in this example?


  [1]: http://stackoverflow.com/questions/498512/how-to-be-an-eco-friendly-programmer
  [2]: http://i.stack.imgur.com/PZiSq.png",2
8845816,01/13/2012 04:09:18,1117380,12/27/2011 09:26:26,1,0,How to rotate a 3 dimensional matrix by 90 degrees clockwise around its central element?,"Can you suggest me an algorithm to rotate a three dimensional array of size 3x3x3 around its central element (say matrix[1][1][1]), accordind to x, y, and z axes of the 3D coordinate system?",c,algorithm,multidimensional-array,rotation,,01/14/2012 06:22:28,not a real question,1,33,15,"How to rotate a 3 dimensional matrix by 90 degrees clockwise around its central element? Can you suggest me an algorithm to rotate a three dimensional array of size 3x3x3 around its central element (say matrix[1][1][1]), accordind to x, y, and z axes of the 3D coordinate system?",4
11142687,06/21/2012 16:34:35,1471101,06/21/2012 05:21:40,18,0,Alternative for openssl shell command in C code,"I need to write a C code which can do the same functions as the following linux commanda using openssl:

    openssl aes-256-cbc -a -salt -in test.txt
    openssl aes-256-cbc -a -salt -in test.txt -out test1.txt
    openssl aes-256-cbc -d -a -salt -in test.txt
    openssl aes-256-cbc -d -a -salt -in test.txt -out test1.txt
    echo ""string_variable"" | openssl aes-256-cbc -a -salt
    echo ""encrypted_string_variable"" | openssl aes-256-cbc -d -a -salt

Please tell me which all functions should I use to do the above functions in a C code. Thanks in advance.",c,linux,terminal,openssl,,06/22/2012 11:50:31,not a real question,1,103,8,"Alternative for openssl shell command in C code I need to write a C code which can do the same functions as the following linux commanda using openssl:

    openssl aes-256-cbc -a -salt -in test.txt
    openssl aes-256-cbc -a -salt -in test.txt -out test1.txt
    openssl aes-256-cbc -d -a -salt -in test.txt
    openssl aes-256-cbc -d -a -salt -in test.txt -out test1.txt
    echo ""string_variable"" | openssl aes-256-cbc -a -salt
    echo ""encrypted_string_variable"" | openssl aes-256-cbc -d -a -salt

Please tell me which all functions should I use to do the above functions in a C code. Thanks in advance.",4
2150938,01/27/2010 22:53:39,14777,09/17/2008 02:45:21,1280,59,Can I get C's pthread.h to compile in Windows?,"If I try to compile a program with

    #include <pthread.h>
in it, I get the error:
***pthread.h: No such file or directory***

Is it possible to get this to compile in a Windows environment?

I am using Vista with the latest mingw",c,windows,multithreading,pthreads,,,open,0,41,9,"Can I get C's pthread.h to compile in Windows? If I try to compile a program with

    #include <pthread.h>
in it, I get the error:
***pthread.h: No such file or directory***

Is it possible to get this to compile in a Windows environment?

I am using Vista with the latest mingw",4
10373935,04/29/2012 16:46:53,759007,05/18/2011 10:33:31,27,0,Pascal to C converter,"I'm writing program which translate Pascal to C and need some help. I started with scanner generator Flex. I defined some rules and created scanner which is working more or less ok. It breaks Pascal syntax into tokens, for now it's only printing what it found. But I have no idea what should I do next...  Are there any articles or books covering this subject? What is the next step?

Thanks in advance.",c,converter,pascal,gnu-flex,translator,04/30/2012 17:14:14,not constructive,1,73,4,"Pascal to C converter I'm writing program which translate Pascal to C and need some help. I started with scanner generator Flex. I defined some rules and created scanner which is working more or less ok. It breaks Pascal syntax into tokens, for now it's only printing what it found. But I have no idea what should I do next...  Are there any articles or books covering this subject? What is the next step?

Thanks in advance.",5
5661864,04/14/2011 10:28:31,707754,04/14/2011 10:28:31,1,0,i want to make a c code for converting a pascal code to a c code,"doing a pascal to c code converter would be cool...
can anybody help me ?",c,,,,,04/14/2011 10:31:07,not a real question,1,14,16,"i want to make a c code for converting a pascal code to a c code doing a pascal to c code converter would be cool...
can anybody help me ?",1
8865262,01/14/2012 20:50:58,1138886,01/09/2012 14:32:47,1,0,Separating numbers in an input in C,"I need to take a 4 digit input in C such as 1234, and store the numbers separetly like 1, 2, 3, 4. How could I do this?

Thanks
",c,input,,,,01/15/2012 03:54:37,not a real question,1,28,7,"Separating numbers in an input in C I need to take a 4 digit input in C such as 1234, and store the numbers separetly like 1, 2, 3, 4. How could I do this?

Thanks
",2
8912840,01/18/2012 15:33:36,1156473,01/18/2012 14:49:43,6,0,"Dijkstra algorithm implementation in ""c"" and ""java""","    #include <stdio.h>
    #include <stdlib.h>

    #define GRAPHSIZE 2048
    #define INFINITY GRAPHSIZE*GRAPHSIZE
    #define MAX(a, b) ((a > b) ? (a) : (b))

    int edges; /* The number of edges in the graph */
    int nodes; /* The number of nodes in the graph */
    long dist[GRAPHSIZE][GRAPHSIZE];
    long d[GRAPHSIZE];/* d[i] is the length of the shortest path between the source (s) and node i */

    void printD() {
	    int i;
	for (i = 1; i <= n; ++i)
		printf(""%10d"", i);
	printf(""\n"");
	for (i = 1; i <= n; ++i) {
		printf(""%10ld"", d[i]);
	}
	printf(""\n"");
    }

    void dijkstra(int s) {
	int i, k, mini;
	int visited[GRAPHSIZE];

	for (i = 1; i <= n; ++i) {
		d[i] = INFINITY;
		visited[i] = 0; /* the i-th element has not yet been visited */
	}

	d[s] = 0;
                for (k = 1; k <= n; ++k) {
		mini = -1;
		for (i = 1; i <= n; ++i)
			if (!visited[i] && ((mini == -1) || (d[i] < d[mini])))
				mini = i;

		visited[mini] = 1;

		for (i = 1; i <= n; ++i)
			if (dist[mini][i])
				if (d[mini] + dist[mini][i] < d[i]) 
					d[i] = d[mini] + dist[mini][i];
	    }
    }

So far this is what i have done for ""c"". I would like some help from here. 
""C"" is not really my ""favourite"" language so i cant actually get the way it works. I try to find code samples in different websites but i have a little problem putting them together after that. ",c,,,,,01/18/2012 15:36:48,not a real question,1,282,7,"Dijkstra algorithm implementation in ""c"" and ""java""     #include <stdio.h>
    #include <stdlib.h>

    #define GRAPHSIZE 2048
    #define INFINITY GRAPHSIZE*GRAPHSIZE
    #define MAX(a, b) ((a > b) ? (a) : (b))

    int edges; /* The number of edges in the graph */
    int nodes; /* The number of nodes in the graph */
    long dist[GRAPHSIZE][GRAPHSIZE];
    long d[GRAPHSIZE];/* d[i] is the length of the shortest path between the source (s) and node i */

    void printD() {
	    int i;
	for (i = 1; i <= n; ++i)
		printf(""%10d"", i);
	printf(""\n"");
	for (i = 1; i <= n; ++i) {
		printf(""%10ld"", d[i]);
	}
	printf(""\n"");
    }

    void dijkstra(int s) {
	int i, k, mini;
	int visited[GRAPHSIZE];

	for (i = 1; i <= n; ++i) {
		d[i] = INFINITY;
		visited[i] = 0; /* the i-th element has not yet been visited */
	}

	d[s] = 0;
                for (k = 1; k <= n; ++k) {
		mini = -1;
		for (i = 1; i <= n; ++i)
			if (!visited[i] && ((mini == -1) || (d[i] < d[mini])))
				mini = i;

		visited[mini] = 1;

		for (i = 1; i <= n; ++i)
			if (dist[mini][i])
				if (d[mini] + dist[mini][i] < d[i]) 
					d[i] = d[mini] + dist[mini][i];
	    }
    }

So far this is what i have done for ""c"". I would like some help from here. 
""C"" is not really my ""favourite"" language so i cant actually get the way it works. I try to find code samples in different websites but i have a little problem putting them together after that. ",1
9801614,03/21/2012 09:19:28,1264317,03/12/2012 14:22:31,1,0,Porting C code to Arduino Platform (Errors in struct and typedef definitions),"I have a working cross-platform visual studio windows C console application source. This application communicates with a RFID reader using serial interface.  I want to port it to a microcontroller to start reader without PC. For this purpose I decide to use Arduino. It uses C/C++ syntax.  In the below code Arduino IDE compiler gives error. The error is 
**""error: expected `)' before '*' token""**. 

    /* A typedef that should be used for RFID radio handles */
    typedef HANDLE32    RFID_RADIO_HANDLE;
    
    /******************************************************************************
     * Name: RFID_PACKET_CALLBACK_FUNCTION
     *
     * Description:
     *   The tag-protocol operation response packet callback function signature.
     *
     * Parameters:
     *   handle - the handle for the radio for which operation response packets are
     *     being returned
     *   bufferLength - the length of the buffer that contains the packets
     *   pBuffer - a buffer that contains one or more complete operation response
     *     packets
     *   context - an application-defined context value that was supplied when the
     *     the original tag-protocol operation function was invoked
     *
     * Returns:
     *   0 - continue making packet callbacks
     *   !0 - cancel the tag-protocol operation and stop making callbacks for that
     *
     *   The return value of the last packet callback for the tag-protocol operation
     *   is returned to the application if the application indicates the desire for
     *   this value when it invokes the tag-protocol opreation.
     ******************************************************************************/
    typedef INT32S (RFID_CALLBACK * RFID_PACKET_CALLBACK_FUNCTION)(
        RFID_RADIO_HANDLE   handle,
        INT32U              bufferLength,
        const INT8U*        pBuffer,
        void*               context
        );

It is working in visual studio, so its syntax should be correct. I do not know how to solve this error.

I have another error in below code. There are lots of struct definitons in this header. I give small part of it which gives error. The error is **""error: 'RFID_PACKET_CALLBACK_FUNCTION' does not name a type""**.

    .
    .
    .
    ...
    typedef struct {
        INT32U                 tagStopCount;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                     context;
        INT32S*                 pCallbackCode;
    } RFID_18K6C_COMMON_PARMS;
    
    typedef struct {
        INT32U                  length;
        INT32U                  command;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                      context;
        INT32S*                  pCallbackCode;
    } RFID_ISSUE_RADIO_COMMAND_PARMS;
    
    typedef struct {
        INT32U                  length;
        INT32U                  duration;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                      context;
        INT32S*                  pCallbackCode;
    } RFID_RANDOM_CW_PARMS;
    .
    .
    .
    ...

These codes are all working in VS console application. What sould I do for Arduino platform?",c,struct,typedef,arduino,,04/16/2012 17:14:15,too localized,1,945,12,"Porting C code to Arduino Platform (Errors in struct and typedef definitions) I have a working cross-platform visual studio windows C console application source. This application communicates with a RFID reader using serial interface.  I want to port it to a microcontroller to start reader without PC. For this purpose I decide to use Arduino. It uses C/C++ syntax.  In the below code Arduino IDE compiler gives error. The error is 
**""error: expected `)' before '*' token""**. 

    /* A typedef that should be used for RFID radio handles */
    typedef HANDLE32    RFID_RADIO_HANDLE;
    
    /******************************************************************************
     * Name: RFID_PACKET_CALLBACK_FUNCTION
     *
     * Description:
     *   The tag-protocol operation response packet callback function signature.
     *
     * Parameters:
     *   handle - the handle for the radio for which operation response packets are
     *     being returned
     *   bufferLength - the length of the buffer that contains the packets
     *   pBuffer - a buffer that contains one or more complete operation response
     *     packets
     *   context - an application-defined context value that was supplied when the
     *     the original tag-protocol operation function was invoked
     *
     * Returns:
     *   0 - continue making packet callbacks
     *   !0 - cancel the tag-protocol operation and stop making callbacks for that
     *
     *   The return value of the last packet callback for the tag-protocol operation
     *   is returned to the application if the application indicates the desire for
     *   this value when it invokes the tag-protocol opreation.
     ******************************************************************************/
    typedef INT32S (RFID_CALLBACK * RFID_PACKET_CALLBACK_FUNCTION)(
        RFID_RADIO_HANDLE   handle,
        INT32U              bufferLength,
        const INT8U*        pBuffer,
        void*               context
        );

It is working in visual studio, so its syntax should be correct. I do not know how to solve this error.

I have another error in below code. There are lots of struct definitons in this header. I give small part of it which gives error. The error is **""error: 'RFID_PACKET_CALLBACK_FUNCTION' does not name a type""**.

    .
    .
    .
    ...
    typedef struct {
        INT32U                 tagStopCount;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                     context;
        INT32S*                 pCallbackCode;
    } RFID_18K6C_COMMON_PARMS;
    
    typedef struct {
        INT32U                  length;
        INT32U                  command;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                      context;
        INT32S*                  pCallbackCode;
    } RFID_ISSUE_RADIO_COMMAND_PARMS;
    
    typedef struct {
        INT32U                  length;
        INT32U                  duration;
        RFID_PACKET_CALLBACK_FUNCTION           pCallback;
        void*                      context;
        INT32S*                  pCallbackCode;
    } RFID_RANDOM_CW_PARMS;
    .
    .
    .
    ...

These codes are all working in VS console application. What sould I do for Arduino platform?",4
8303176,11/28/2011 22:19:09,600170,02/02/2011 14:57:40,614,23,SIGSEGV in optimized version of code,"My knowledge of the intel instruction set is a bit rusty.  Can you tell me why I might be getting a segmentation fault in the optimized version of my function (bonus points if you can tell me why I don't get it in the -O0 build of the code.

It's C code compiled by GCC 4.1.2.

Here is the result of GDB's ""disas"" command at the crash:

       0x00000000004263e5 <+0>: 	sub    $0x8,%rsp
       0x00000000004263e9 <+4>: 	movsd  %xmm2,(%rsp)
       0x00000000004263ee <+9>: 	divsd  %xmm1,%xmm0
       0x00000000004263f2 <+13>:	callq  0x60f098 <log@plt>
    => 0x00000000004263f7 <+18>:	andpd  0x169529(%rip),%xmm0        
       0x00000000004263ff <+26>:	movsd  (%rsp),%xmm1
       0x0000000000426404 <+31>:	ucomisd %xmm0,%xmm1
       0x0000000000426408 <+35>:	seta   %al
       0x000000000042640b <+38>:	movzbl %al,%eax
       0x000000000042640e <+41>:	add    $0x8,%rsp
       0x0000000000426412 <+45>:	retq   

And here's the original source of the function:

    char is_within_range(double a, double b, double range) {
      double ratio = a / b;
      double logRatio = fabs(log(ratio));
      return logRatio < range;
    }

",c,gcc,assembly,segmentation-fault,sigsegv,,open,0,241,6,"SIGSEGV in optimized version of code My knowledge of the intel instruction set is a bit rusty.  Can you tell me why I might be getting a segmentation fault in the optimized version of my function (bonus points if you can tell me why I don't get it in the -O0 build of the code.

It's C code compiled by GCC 4.1.2.

Here is the result of GDB's ""disas"" command at the crash:

       0x00000000004263e5 <+0>: 	sub    $0x8,%rsp
       0x00000000004263e9 <+4>: 	movsd  %xmm2,(%rsp)
       0x00000000004263ee <+9>: 	divsd  %xmm1,%xmm0
       0x00000000004263f2 <+13>:	callq  0x60f098 <log@plt>
    => 0x00000000004263f7 <+18>:	andpd  0x169529(%rip),%xmm0        
       0x00000000004263ff <+26>:	movsd  (%rsp),%xmm1
       0x0000000000426404 <+31>:	ucomisd %xmm0,%xmm1
       0x0000000000426408 <+35>:	seta   %al
       0x000000000042640b <+38>:	movzbl %al,%eax
       0x000000000042640e <+41>:	add    $0x8,%rsp
       0x0000000000426412 <+45>:	retq   

And here's the original source of the function:

    char is_within_range(double a, double b, double range) {
      double ratio = a / b;
      double logRatio = fabs(log(ratio));
      return logRatio < range;
    }

",5
8020376,11/05/2011 13:11:09,1027046,11/03/2011 05:58:59,31,0,how to separate a number from a string,"Actually I need to handle situation like 

I should be giving input as ""rows <n>""
There should be space between 'rows' and number <n> or any single non numeric character. 

I should be able to separate that string part and assign it to a char variable and number part to a int... 

The string part should be then verified whether its a correct command or not.. If a wrong command is entered like ""ada aad 99"" or ""adaha 9"" or ""adfad9"".. It should say ""its wrong command"".

I tried to use strtok(), but it can't handle strings where there isn't NULL in between strings.. I tried to use $ sscanf(string,""%s %*c %d"",str, &num); 
but its even not working for all possibilities. 

How can I do it.. 
",c,string,,,,11/05/2011 19:37:06,too localized,1,125,8,"how to separate a number from a string Actually I need to handle situation like 

I should be giving input as ""rows <n>""
There should be space between 'rows' and number <n> or any single non numeric character. 

I should be able to separate that string part and assign it to a char variable and number part to a int... 

The string part should be then verified whether its a correct command or not.. If a wrong command is entered like ""ada aad 99"" or ""adaha 9"" or ""adfad9"".. It should say ""its wrong command"".

I tried to use strtok(), but it can't handle strings where there isn't NULL in between strings.. I tried to use $ sscanf(string,""%s %*c %d"",str, &num); 
but its even not working for all possibilities. 

How can I do it.. 
",2
7864206,10/23/2011 03:42:40,91422,04/16/2009 02:09:50,116,1,what is the best way to handle new clients using select() in a server?,"I want to write a asynchronous socket server in C, but before I do I'm doing some research. Looking at the select() socket example shown here: http://www.gnu.org/s/hello/manual/libc/Server-Example.html#Server-Example I can see that the example program will only accept one client per select loop (if I'm reading it right). So if there are 20 clients and two more try to connect, will it only accept the 21st client then process the other 20 (worst case, assuming all 20 others require reading) and THEN accept the 22nd? Would it be better if I break the loop after accepting a client so it can select() again and take care of all pending clients before processing connected ones? Or does that defeat the purpose of using select()? Thanks.",c,sockets,select,asynchronous,,,open,0,123,14,"what is the best way to handle new clients using select() in a server? I want to write a asynchronous socket server in C, but before I do I'm doing some research. Looking at the select() socket example shown here: http://www.gnu.org/s/hello/manual/libc/Server-Example.html#Server-Example I can see that the example program will only accept one client per select loop (if I'm reading it right). So if there are 20 clients and two more try to connect, will it only accept the 21st client then process the other 20 (worst case, assuming all 20 others require reading) and THEN accept the 22nd? Would it be better if I break the loop after accepting a client so it can select() again and take care of all pending clients before processing connected ones? Or does that defeat the purpose of using select()? Thanks.",4
4893382,02/04/2011 00:32:29,355682,06/01/2010 17:31:09,489,8,Can -std=c99 prevent my #includes from working properly?,"I am trying to compile a c program on a linux system. I have #include 'd stdlib.h

When I compile the program with gcc as follows:

    gcc -std=c99 -g -o progfoo progfoo.c progbar.c

I get warnings about ""Implicit declaration of function [srand48, drand48, bzero, or close]""

compiling instead as:

    gcc -g -o progfoo progfoo.c progbar.c

doesn't give me the warnings, but it does yell about my use of ""for"" loops (which was the rationale for adding -std=c99 in the first place).

Given that ""man srand48"" mentions including <stdlib.h>, which I have, I'm unsure what else the problem could be. The for loops aren't essential to anything (they were just to save time in initializing an array) so I have no problem removing them, but before I do I'd like to confirm whether the c99 standard is superseding some aspect of my #include s.

I'm using gcc 4.1.2-50 (Red Hat)",c,linux,gcc,,,,open,0,149,8,"Can -std=c99 prevent my #includes from working properly? I am trying to compile a c program on a linux system. I have #include 'd stdlib.h

When I compile the program with gcc as follows:

    gcc -std=c99 -g -o progfoo progfoo.c progbar.c

I get warnings about ""Implicit declaration of function [srand48, drand48, bzero, or close]""

compiling instead as:

    gcc -g -o progfoo progfoo.c progbar.c

doesn't give me the warnings, but it does yell about my use of ""for"" loops (which was the rationale for adding -std=c99 in the first place).

Given that ""man srand48"" mentions including <stdlib.h>, which I have, I'm unsure what else the problem could be. The for loops aren't essential to anything (they were just to save time in initializing an array) so I have no problem removing them, but before I do I'd like to confirm whether the c99 standard is superseding some aspect of my #include s.

I'm using gcc 4.1.2-50 (Red Hat)",3
11392418,07/09/2012 09:33:49,733176,05/01/2011 10:06:55,30,2,how many arithmetic operation cufft performs?,"I need to calculate gflops of cufft forward and inverse algorithm . 

I have : 

    double gflops = 1.0e-9 * dNumOps/gpuTime;

but I don't know how set dNumOps , I need to know total operations of cufft forward and inverse.

I remember that fft usually have a N*logr(N) operations where r is the number of dataset division in fft, but for cufft ?",c,time,cuda,fft,,,open,0,65,6,"how many arithmetic operation cufft performs? I need to calculate gflops of cufft forward and inverse algorithm . 

I have : 

    double gflops = 1.0e-9 * dNumOps/gpuTime;

but I don't know how set dNumOps , I need to know total operations of cufft forward and inverse.

I remember that fft usually have a N*logr(N) operations where r is the number of dataset division in fft, but for cufft ?",4
1967456,12/28/2009 00:04:40,239324,12/24/2009 19:18:27,1,0,"How Big Should main() Be, in C?","I'm learning a little C over the holiday weekend, and I started to look at other programs written in C. I ended up looking at GNU Netcat, thinking it would be a good example.

I was a bit shocked to see a [600 line `main()` function][2]. Is this normal? If it is normal is this considered good C coding practices?


  [2]: http://netcat.cvs.sourceforge.net/viewvc/netcat/netcat/src/netcat.c?revision=1.64&view=markup",c,gnu,,,,12/28/2009 14:22:59,not constructive,1,62,7,"How Big Should main() Be, in C? I'm learning a little C over the holiday weekend, and I started to look at other programs written in C. I ended up looking at GNU Netcat, thinking it would be a good example.

I was a bit shocked to see a [600 line `main()` function][2]. Is this normal? If it is normal is this considered good C coding practices?


  [2]: http://netcat.cvs.sourceforge.net/viewvc/netcat/netcat/src/netcat.c?revision=1.64&view=markup",2
1814748,11/29/2009 05:32:37,120800,06/10/2009 19:12:04,299,1,Using & (addressof) with const variables in C,"Text books say that & (addressof) operator doesn't apply to cannot be applied to expressions,  
constants, or register variables.  
Does constants mean only literals like 'A', '7' etc or variables declared with const keyword as well?  
I think this mean only literals since following code compiles:-

    int main()
    {
	const int i=10;
	const int *ip;

	ip = &i;
}
",c,constants,,,,,open,0,64,8,"Using & (addressof) with const variables in C Text books say that & (addressof) operator doesn't apply to cannot be applied to expressions,  
constants, or register variables.  
Does constants mean only literals like 'A', '7' etc or variables declared with const keyword as well?  
I think this mean only literals since following code compiles:-

    int main()
    {
	const int i=10;
	const int *ip;

	ip = &i;
}
",2
10316267,04/25/2012 13:03:33,1356201,04/25/2012 12:37:32,1,0,how to correctly design / plan the source code development,"I work for a company where we mainly do embedded programming. The way we do project or task is next. Each programmer gets some section to work on and the next thing we do is to just start programming without making any general or detailed plan on how the source code is going to be at the end. can you please give me some advice or recommend a book in how this should be done and what methods are you using at where you work??? what is really working out for. How much time should there be planing and discussing everything till the smallest details and what % of time should be spent on actual coding. i relay want to get better in the things I do and I want to learn the right way of designing the source for a project or a major task. Also we suck in documenting the source code it is like comments are disabling a peace of code. I have recently read the book on coding standards from Michael Barr and i was shocked how this helped me. I hope the same thing can be done for planning or designing the code. Any advice is much appreciated.

Best regards,
Martin",c,,,,,04/25/2012 13:07:45,off topic,1,204,10,"how to correctly design / plan the source code development I work for a company where we mainly do embedded programming. The way we do project or task is next. Each programmer gets some section to work on and the next thing we do is to just start programming without making any general or detailed plan on how the source code is going to be at the end. can you please give me some advice or recommend a book in how this should be done and what methods are you using at where you work??? what is really working out for. How much time should there be planing and discussing everything till the smallest details and what % of time should be spent on actual coding. i relay want to get better in the things I do and I want to learn the right way of designing the source for a project or a major task. Also we suck in documenting the source code it is like comments are disabling a peace of code. I have recently read the book on coding standards from Michael Barr and i was shocked how this helped me. I hope the same thing can be done for planning or designing the code. Any advice is much appreciated.

Best regards,
Martin",1
9542730,03/03/2012 02:01:44,1246297,03/03/2012 01:38:25,1,0,a C-program using some posix commands,"error: request for member `st_mode' in something not a structure or union

error: syntax error before ')' token

error: incompatible type for argument 1 of `read'

/* Here is the code */

int main( int argc, char **argv)

{

    int src, dst;
    char buf[BUFSIZE];
    int n;

    if (argc!=3)
    {
      printf(""\n usage: copy src dst\n"");
      return -1;
    }

  struct stat src;

  if(stat(argv[1],&src) < 0)

  return 1;

  printf(""File Permissions for source file: \t"");

  printf(""%d"", S_ISDIR(src.st_mode)) ? ""d"" : ""-"");
 
  printf(src.st_mode & S_IRUSR) ? ""r"" : ""-"");
 
  printf(src.st_mode & S_IWUSR) ? ""w"" : ""-"");
  
  printf(src.st_mode & S_IXUSR) ? ""x"" : ""-"");
 

  int creat(char *dst,int perms);
  

  printf(""File Permissions for destination file: \t"");

  printf(S_ISDIR(src.st_mode)) ? ""d"" : ""-"");

  printf(dst.st_mode & S_IRUSR) ? ""r"" : ""-"");

  printf(dst.st_mode & S_IWUSR) ? ""w"" : ""-"");

  printf(dst.st_mode & S_IXUSR) ? ""x"" : ""-"");
  
  
  src=open(argv[1], O_RDONLY | S_IRUSR | S_IWUSR |S_IXUSR | );

  dst=open(argv[2], O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR |S_IXUSR);

  while ((n=read(src, buf, BUFSIZE)) > 0)

  {

    if (write(dst, buf, n) != n)

    printf(""write error!"");

  }

   if (n<0){

   printf(""read error !"");

  }

   close(src);

   close(dst);

   exit(0);

}
",c,,,,,03/03/2012 11:33:19,not a real question,1,248,6,"a C-program using some posix commands error: request for member `st_mode' in something not a structure or union

error: syntax error before ')' token

error: incompatible type for argument 1 of `read'

/* Here is the code */

int main( int argc, char **argv)

{

    int src, dst;
    char buf[BUFSIZE];
    int n;

    if (argc!=3)
    {
      printf(""\n usage: copy src dst\n"");
      return -1;
    }

  struct stat src;

  if(stat(argv[1],&src) < 0)

  return 1;

  printf(""File Permissions for source file: \t"");

  printf(""%d"", S_ISDIR(src.st_mode)) ? ""d"" : ""-"");
 
  printf(src.st_mode & S_IRUSR) ? ""r"" : ""-"");
 
  printf(src.st_mode & S_IWUSR) ? ""w"" : ""-"");
  
  printf(src.st_mode & S_IXUSR) ? ""x"" : ""-"");
 

  int creat(char *dst,int perms);
  

  printf(""File Permissions for destination file: \t"");

  printf(S_ISDIR(src.st_mode)) ? ""d"" : ""-"");

  printf(dst.st_mode & S_IRUSR) ? ""r"" : ""-"");

  printf(dst.st_mode & S_IWUSR) ? ""w"" : ""-"");

  printf(dst.st_mode & S_IXUSR) ? ""x"" : ""-"");
  
  
  src=open(argv[1], O_RDONLY | S_IRUSR | S_IWUSR |S_IXUSR | );

  dst=open(argv[2], O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR |S_IXUSR);

  while ((n=read(src, buf, BUFSIZE)) > 0)

  {

    if (write(dst, buf, n) != n)

    printf(""write error!"");

  }

   if (n<0){

   printf(""read error !"");

  }

   close(src);

   close(dst);

   exit(0);

}
",1
2976523,06/04/2010 17:51:00,319824,04/18/2010 19:03:42,53,5,taking input from unknown ends,"            line  by line, there are inputs.
            first line will be stored in as[0]
            second one is as[1]
             ...
           how input line ends is not known (maybe it end with EOF or new line character)
           how should I take input



 ",c,token,scanf,,,06/04/2010 20:12:10,not a real question,1,107,5,"taking input from unknown ends             line  by line, there are inputs.
            first line will be stored in as[0]
            second one is as[1]
             ...
           how input line ends is not known (maybe it end with EOF or new line character)
           how should I take input



 ",3
11578268,07/20/2012 11:18:22,1430289,06/01/2012 08:55:32,18,0,Program executes after for loop - C,"Here is my problem. Immediately after I type in some input and hit enter the program executes. And I some how figured out that the problem was due to the for loop which I was using. Here is the code.

    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    
    main(){
           
           
     char myString[100]; 
     char myChar = myString[6];
     int i;
     
     for(i=0; i<=100; i++){
        scanf(""%s"", myString[i]);
     }
     
     printf(""%c\n"", myChar); 
     system(""pause"");
            
    }",c,loops,,,,07/20/2012 19:55:15,not a real question,1,162,7,"Program executes after for loop - C Here is my problem. Immediately after I type in some input and hit enter the program executes. And I some how figured out that the problem was due to the for loop which I was using. Here is the code.

    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    
    main(){
           
           
     char myString[100]; 
     char myChar = myString[6];
     int i;
     
     for(i=0; i<=100; i++){
        scanf(""%s"", myString[i]);
     }
     
     printf(""%c\n"", myChar); 
     system(""pause"");
            
    }",2
8403731,12/06/2011 16:59:12,654928,03/11/2011 07:12:42,667,10,GTK and scrolling text view,"This is what I have so far

    GtkWidget* createConsoleBox()
    {
            GtkWidget* textArea = gtk_text_view_new();
            GtkWidget* scrollbar = gtk_vscrollbar_new(gtk_text_view_get_vadjustment(GTK_TEXT_VIEW(textArea)));
            GtkWidget* textEntry = gtk_entry_new();
    
            GtkWidget* console = gtk_table_new(3, 2, FALSE);
    
            gtk_table_attach_defaults(GTK_TABLE(console), textArea, 0, 1, 0, 1);
            gtk_table_attach_defaults(GTK_TABLE(console), scrollbar, 1, 2, 0, 1);
    
            gtk_table_attach_defaults(GTK_TABLE(console), textEntry, 0, 2, 1, 2);
    
            return console;
    
    }

I want the text view to be scrollable as the text begins to fill the box, but the box keeps on expanding to accommodate more text. How to do I limit the size of the text view and create a scrollable text view.

Thanks in advance :-)",c,gtk2,,,,,open,0,211,5,"GTK and scrolling text view This is what I have so far

    GtkWidget* createConsoleBox()
    {
            GtkWidget* textArea = gtk_text_view_new();
            GtkWidget* scrollbar = gtk_vscrollbar_new(gtk_text_view_get_vadjustment(GTK_TEXT_VIEW(textArea)));
            GtkWidget* textEntry = gtk_entry_new();
    
            GtkWidget* console = gtk_table_new(3, 2, FALSE);
    
            gtk_table_attach_defaults(GTK_TABLE(console), textArea, 0, 1, 0, 1);
            gtk_table_attach_defaults(GTK_TABLE(console), scrollbar, 1, 2, 0, 1);
    
            gtk_table_attach_defaults(GTK_TABLE(console), textEntry, 0, 2, 1, 2);
    
            return console;
    
    }

I want the text view to be scrollable as the text begins to fill the box, but the box keeps on expanding to accommodate more text. How to do I limit the size of the text view and create a scrollable text view.

Thanks in advance :-)",2
6827012,07/26/2011 08:03:09,806393,06/20/2011 09:45:27,13,1,Combine multiple VS2010 Projects to one .lib file,"I want to combine a number of Win32 C-Projects to one .lib file.

OS: Windows XP Sp3
IDE/Comipler: Visual Studio 2010

Now I have one parent project that references all the other projects. But all the functions and globals from the referenced projects are not included or not public, so I get an ""unresolved external"" error when using the library.
Functions within the parent project function correctly.

What can I do?",c,windows,visual-studio-2010,,,,open,0,66,8,"Combine multiple VS2010 Projects to one .lib file I want to combine a number of Win32 C-Projects to one .lib file.

OS: Windows XP Sp3
IDE/Comipler: Visual Studio 2010

Now I have one parent project that references all the other projects. But all the functions and globals from the referenced projects are not included or not public, so I get an ""unresolved external"" error when using the library.
Functions within the parent project function correctly.

What can I do?",3
8023888,11/05/2011 22:52:24,962891,09/24/2011 18:10:11,102,0,A good tutorial for CUnit?,"I am looking for an online tutorial for CUnit. After much ""Googling"", the only ones I have come across are the CUnit documentation on sourcefige and [this one][1]. None of which can really be described as a tutorial with a ""walk though"" working example.

Does any one know of a CUnit tutorial that actually walks through testing a sample program?


  [1]: http://w3.scs.ryerson.ca/~schi/cps707/general-usage.html#",c,cunit,,,,11/11/2011 10:58:07,not constructive,1,62,5,"A good tutorial for CUnit? I am looking for an online tutorial for CUnit. After much ""Googling"", the only ones I have come across are the CUnit documentation on sourcefige and [this one][1]. None of which can really be described as a tutorial with a ""walk though"" working example.

Does any one know of a CUnit tutorial that actually walks through testing a sample program?


  [1]: http://w3.scs.ryerson.ca/~schi/cps707/general-usage.html#",2
4882563,02/03/2011 04:00:08,587887,01/24/2011 17:47:43,14,0,should we use c # program to writing a Vpn ,"should we use c # program to writing a Vpn ?
should we writh a vpn program with c# ?
",c,,,,,02/03/2011 05:05:25,not a real question,1,19,11,"should we use c # program to writing a Vpn  should we use c # program to writing a Vpn ?
should we writh a vpn program with c# ?
",1
5931558,05/09/2011 01:20:54,742836,05/07/2011 08:09:50,1,0,How does gdb interpret `main` when no debug symbols loaded?,"    <http://www.gnu.org/software/gdb/bugs/>...
    Reading symbols from /root/ctest/printf...(no debugging symbols found)...done.
    (gdb) disas main
    Dump of assembler code for function main:
    0x0000000000400498 <main+0>:	push   %rbp
    0x0000000000400499 <main+1>:	mov    %rsp,%rbp
    0x000000000040049c <main+4>:	sub    $0x10,%rsp


How does gdb interpret `main` when no debug symbols loaded?",c,gdb,,,,,open,0,66,10,"How does gdb interpret `main` when no debug symbols loaded?     <http://www.gnu.org/software/gdb/bugs/>...
    Reading symbols from /root/ctest/printf...(no debugging symbols found)...done.
    (gdb) disas main
    Dump of assembler code for function main:
    0x0000000000400498 <main+0>:	push   %rbp
    0x0000000000400499 <main+1>:	mov    %rsp,%rbp
    0x000000000040049c <main+4>:	sub    $0x10,%rsp


How does gdb interpret `main` when no debug symbols loaded?",2
2704813,04/24/2010 14:33:35,324870,04/24/2010 10:07:12,16,0,"what i don't understand in my task here what kind of list i can use, and if it should have 2 attributes key and value ? or only value? with pointers to another node ofc","what i don't understand in my task here what kind of list i can use, and if it should have 2 attributes key and value ? or only value?
with pointers to another node ofc

the task:
""design a function which create a list using input from the keyboard _ the prefered solution. Assume that some magic stops the input; so the length of a list is not known in advance.(alternative solution: a function which creates explicitly a fixed list. However, all other function can not assume any knowledge about the length of lists). Necessary utilities( additional functions to be created): a function which deallocates the memory used for lists and a function which prints the content of the list.
let the element of lists contain a letter. Design a function which create a copy of such list.

can't also understand the list line !!!!!???",c,,,,,,open,0,140,35,"what i don't understand in my task here what kind of list i can use, and if it should have 2 attributes key and value ? or only value? with pointers to another node ofc what i don't understand in my task here what kind of list i can use, and if it should have 2 attributes key and value ? or only value?
with pointers to another node ofc

the task:
""design a function which create a list using input from the keyboard _ the prefered solution. Assume that some magic stops the input; so the length of a list is not known in advance.(alternative solution: a function which creates explicitly a fixed list. However, all other function can not assume any knowledge about the length of lists). Necessary utilities( additional functions to be created): a function which deallocates the memory used for lists and a function which prints the content of the list.
let the element of lists contain a letter. Design a function which create a copy of such list.

can't also understand the list line !!!!!???",1
11608511,07/23/2012 08:01:41,956134,09/21/2011 04:51:31,830,0,Get sizeof type that is pointed to by a typedefed pointer,"I have code that looks like the following:

    #include <stdio.h>
    typedef struct SomeStruct* ptr;
    main(){
      printf(""%lu"",sizeof(ptr));
    }

The given code will print the size of `struct SomeStruct*`. However I want `sizeof(struct SomeStruct)`. If I don't know beforehand the name of the struct, is there a way for me to still find the size of the struct pointed to by `ptr`?",c,sizeof,,,,,open,0,76,11,"Get sizeof type that is pointed to by a typedefed pointer I have code that looks like the following:

    #include <stdio.h>
    typedef struct SomeStruct* ptr;
    main(){
      printf(""%lu"",sizeof(ptr));
    }

The given code will print the size of `struct SomeStruct*`. However I want `sizeof(struct SomeStruct)`. If I don't know beforehand the name of the struct, is there a way for me to still find the size of the struct pointed to by `ptr`?",2
11158766,06/22/2012 14:56:55,1190678,02/05/2012 14:01:39,11,0,How to learn from opensource projects written in C language?,"I used to read some codes in coreutils.But it's really frustrating when I found too-much portability support code.so can someone recommend a good opensource project written in C 
language for beginner or a good way to learn from it?And I try to understand what's kernel
and how ipc, memory management works.any great books or projects guides me? Thanks!",c,linux,,,,06/22/2012 15:01:50,not constructive,1,57,10,"How to learn from opensource projects written in C language? I used to read some codes in coreutils.But it's really frustrating when I found too-much portability support code.so can someone recommend a good opensource project written in C 
language for beginner or a good way to learn from it?And I try to understand what's kernel
and how ipc, memory management works.any great books or projects guides me? Thanks!",2
1998119,01/04/2010 08:02:52,456,08/05/2008 21:47:05,3168,79,Macro resolution address,"    #define PLAINTEXT_TARGET ""plaintext""
    if( strstr(PLAINTEXT_TARGET, optarg) == PLAINTEXT_TARGET )
        /* ... */

Does the C language guarantee that `PLAINTEXT_TARGET` above compiles into a single instance?  If the compiler may produce two instances of the macro string then the conditional above is misleading and can be false.",c,,,,,,open,0,60,3,"Macro resolution address     #define PLAINTEXT_TARGET ""plaintext""
    if( strstr(PLAINTEXT_TARGET, optarg) == PLAINTEXT_TARGET )
        /* ... */

Does the C language guarantee that `PLAINTEXT_TARGET` above compiles into a single instance?  If the compiler may produce two instances of the macro string then the conditional above is misleading and can be false.",1
1022957,06/21/2009 01:35:44,119597,06/09/2009 05:35:51,10,0,getting terminal width in c,"i've been looking for a way to get the terminal width from within my c program. what i keep coming up with is somthing along the lines of:

    #include <sys/ioctl.h>
    #include <stdio.h>
    
    int main (void)
    {
        struct ttysize ts;
        ioctl(0, TIOCGSIZE, &ts);
      
        printf (""lines %d\n"", ts.ts_lines);
        printf (""columns %d\n"", ts.ts_cols);
    }

but everytime i try that i get

    austin@:~$ gcc test.c -o test
    test.c: In function main:
    test.c:6: error: storage size of ts isnt known
    test.c:7: error: TIOCGSIZE undeclared (first use in this function)
    test.c:7: error: (Each undeclared identifier is reported only once
    test.c:7: error: for each function it appears in.)

is this the best way to do this, or is there a better way? If not how can i get this to work?

",c,linux,terminal,width,,,open,0,193,5,"getting terminal width in c i've been looking for a way to get the terminal width from within my c program. what i keep coming up with is somthing along the lines of:

    #include <sys/ioctl.h>
    #include <stdio.h>
    
    int main (void)
    {
        struct ttysize ts;
        ioctl(0, TIOCGSIZE, &ts);
      
        printf (""lines %d\n"", ts.ts_lines);
        printf (""columns %d\n"", ts.ts_cols);
    }

but everytime i try that i get

    austin@:~$ gcc test.c -o test
    test.c: In function main:
    test.c:6: error: storage size of ts isnt known
    test.c:7: error: TIOCGSIZE undeclared (first use in this function)
    test.c:7: error: (Each undeclared identifier is reported only once
    test.c:7: error: for each function it appears in.)

is this the best way to do this, or is there a better way? If not how can i get this to work?

",4
8783435,01/09/2012 02:53:19,1137894,01/09/2012 02:45:39,1,0,Openlayers maps item for resale,"I noticed that you can use openlayers for commercial redistribution.  Therefore, can you print openlayers maps and sell the maps?  If not, are there any other map services that allow you to print maps or acquire licenses to print maps for sale?

.asp",c,,,,,01/09/2012 04:42:54,off topic,1,44,5,"Openlayers maps item for resale I noticed that you can use openlayers for commercial redistribution.  Therefore, can you print openlayers maps and sell the maps?  If not, are there any other map services that allow you to print maps or acquire licenses to print maps for sale?

.asp",1
3589772,08/28/2010 06:48:05,159072,06/02/2009 18:25:22,1599,37,Circular Linked List in C,"Why exactly do we need a ""Circular Liked List"" (singly or doubly) data structure?

What problem does it solve that is evident with simple Liked Lists (singly or doubly)? ",c,data-structures,linkedlist,circular-list,,,open,0,29,5,"Circular Linked List in C Why exactly do we need a ""Circular Liked List"" (singly or doubly) data structure?

What problem does it solve that is evident with simple Liked Lists (singly or doubly)? ",4
8435002,12/08/2011 17:23:46,842785,07/13/2011 13:36:41,320,14,In which cases va_list should be used,"I made a small C library that implements graph theory algorithms and binds them for use in Python.

I send it to a friend to check it and he told me that `va_list` is ""dangerous"" and must not be used in this kind of project.

So the question is. In which cases `va_list` should be used?
",c,,,,,,open,0,54,7,"In which cases va_list should be used I made a small C library that implements graph theory algorithms and binds them for use in Python.

I send it to a friend to check it and he told me that `va_list` is ""dangerous"" and must not be used in this kind of project.

So the question is. In which cases `va_list` should be used?
",1
8773535,01/07/2012 22:11:33,463304,09/30/2010 21:11:12,4291,139,Solaris 11: Which package has /usr/include/sys/types.h?,"The [Ubuntu Equivalent](http://ubuntuforums.org/showthread.php?t=492245) would be `libc6-dev`, but I can't seem to find it for Solaris?

Where should I go?",c,64bit,solaris,libc,,,open,0,18,6,"Solaris 11: Which package has /usr/include/sys/types.h? The [Ubuntu Equivalent](http://ubuntuforums.org/showthread.php?t=492245) would be `libc6-dev`, but I can't seem to find it for Solaris?

Where should I go?",4
8975521,01/23/2012 17:03:01,370520,06/18/2010 17:12:37,604,14,read() from stdin,"Consider the following line of code

    while((n = read(stdin, buff, BUFSIZ) != 0))

As per my understanding `read/write` functions are part of non-buffered I/O. So does that mean `read()` function will read only one character per call from stdio? Or in other words, the value of n will be 

        -1  in case of error
    n =  0  in case of EOF
         1  otherwise

If it is not the case, when would the above `read()` function will return and why?

Note: I was also thinking that `read()` will wait until it successfully read `BUFSIZ` number of characters from stdin. But what happen in a case when number of character available to read are less than `BUFSIZ`? Will read wait forever or until EOF arrives (`Ctrl + D` on unix or `Ctrl + Z` on windows)?

Also, lets say `BUFSIZ = 100` and `stdin = ACtrl+D` (i.e EOF immediately followed by a single character). Now how many times the `while loop` will iterate? ",c,linux,unix,io,,,open,0,184,3,"read() from stdin Consider the following line of code

    while((n = read(stdin, buff, BUFSIZ) != 0))

As per my understanding `read/write` functions are part of non-buffered I/O. So does that mean `read()` function will read only one character per call from stdio? Or in other words, the value of n will be 

        -1  in case of error
    n =  0  in case of EOF
         1  otherwise

If it is not the case, when would the above `read()` function will return and why?

Note: I was also thinking that `read()` will wait until it successfully read `BUFSIZ` number of characters from stdin. But what happen in a case when number of character available to read are less than `BUFSIZ`? Will read wait forever or until EOF arrives (`Ctrl + D` on unix or `Ctrl + Z` on windows)?

Also, lets say `BUFSIZ = 100` and `stdin = ACtrl+D` (i.e EOF immediately followed by a single character). Now how many times the `while loop` will iterate? ",4
7343287,09/08/2011 04:57:23,672560,03/23/2011 07:07:49,4,0,How to compile a program of c Langauge manually on MS DOS instead of Borland,"I need to compile a program in ms dos.I have borland Editor I can compile it using Alt+F9 but the things is what it do at the backend.i want to compile it in ms dos.I m trying this

cd:\tc\bin>tcc -o hello.exe hello.c

where hello.c is is my file,hello.exe i want to produce.Its not working what should i do ?and also please tell me also how do i compile .cpp file manually from ms dos.thnx advance.",c,,,,,,open,0,73,15,"How to compile a program of c Langauge manually on MS DOS instead of Borland I need to compile a program in ms dos.I have borland Editor I can compile it using Alt+F9 but the things is what it do at the backend.i want to compile it in ms dos.I m trying this

cd:\tc\bin>tcc -o hello.exe hello.c

where hello.c is is my file,hello.exe i want to produce.Its not working what should i do ?and also please tell me also how do i compile .cpp file manually from ms dos.thnx advance.",1
6702161,07/15/2011 02:42:47,809811,06/22/2011 06:43:35,23,0,Pointer comparisons in C. Are they signed or unsigned?,"Hi I'm sure this must be a common question but I can't find the answer when I search for it. My question basically concerns two pointers. I want to compare their addresses and determine if one is bigger than the other. I would expect all addresses to be unsigned during comparison. Is this true, and does it vary between C89, C99 and C++? When I compile with gcc the comparison is unsigned.  

If I have a two pointers that I'm comparing like this:  
char *a = (char *)0x80000000; //-2147483648 or 2147483648 ?  
char *b = (char *)0x1;  
Then a is greater. Is this guaranteed by a standard?
",c,pointers,comparison,,,,open,0,111,9,"Pointer comparisons in C. Are they signed or unsigned? Hi I'm sure this must be a common question but I can't find the answer when I search for it. My question basically concerns two pointers. I want to compare their addresses and determine if one is bigger than the other. I would expect all addresses to be unsigned during comparison. Is this true, and does it vary between C89, C99 and C++? When I compile with gcc the comparison is unsigned.  

If I have a two pointers that I'm comparing like this:  
char *a = (char *)0x80000000; //-2147483648 or 2147483648 ?  
char *b = (char *)0x1;  
Then a is greater. Is this guaranteed by a standard?
",3
6924287,08/03/2011 09:25:27,876291,08/03/2011 09:25:27,1,0,Problem with function,"its been so much time since a left programming, so now i realize that there are some little changes while coding like



    if(x>y) x=10;

now when i try to compile this line of code, the compiler said that something went wrong, now i need to write this

    if(x>y){x=10;}

and this runs perfectly, does anyone know about this change?
Currently using gcc for Mingw",c,coding-style,,,,07/06/2012 22:19:56,not a real question,1,66,3,"Problem with function its been so much time since a left programming, so now i realize that there are some little changes while coding like



    if(x>y) x=10;

now when i try to compile this line of code, the compiler said that something went wrong, now i need to write this

    if(x>y){x=10;}

and this runs perfectly, does anyone know about this change?
Currently using gcc for Mingw",2
9841590,03/23/2012 15:07:30,1077031,12/02/2011 08:55:10,77,0,Who provided the C header file?,"To Be SpecificI use Ubuntu(Linux)+ gcc as a example.

<stdio.h> <sys/socket.h> <poll.h> <pthread.h>,which on Ubuntu Linux(with gcc installed), are respectively provided by which organization? GNU? Linux ? ISO? Ubuntu?

And what about the corresponding library?",c,linux,gcc,,,03/23/2012 16:01:11,off topic,1,33,6,"Who provided the C header file? To Be SpecificI use Ubuntu(Linux)+ gcc as a example.

<stdio.h> <sys/socket.h> <poll.h> <pthread.h>,which on Ubuntu Linux(with gcc installed), are respectively provided by which organization? GNU? Linux ? ISO? Ubuntu?

And what about the corresponding library?",3
7369969,09/10/2011 06:06:21,216190,11/21/2009 19:13:45,391,2,Implementing linked list with iterator interface,"Here's the problem.

Write a function for merging multiple (sorted) linked lists into one sorted linked list. This
function should access the elements through Iterator interface (do not access elements
through the linked list directly). The arguments to the merge procedure are an array of
Iterators and the size of the array. The return value should be another Iterator with an
underlying List implementation.

Now i dont want the solution for this, but i want to know what an iterator interface is.
I have never heard of it before.

And how do i go about implementing linked list with iterator interface.What does it mean?",c,homework,iterator,linked-list,,,open,0,96,6,"Implementing linked list with iterator interface Here's the problem.

Write a function for merging multiple (sorted) linked lists into one sorted linked list. This
function should access the elements through Iterator interface (do not access elements
through the linked list directly). The arguments to the merge procedure are an array of
Iterators and the size of the array. The return value should be another Iterator with an
underlying List implementation.

Now i dont want the solution for this, but i want to know what an iterator interface is.
I have never heard of it before.

And how do i go about implementing linked list with iterator interface.What does it mean?",4
4546356,12/28/2010 13:20:34,98494,04/30/2009 12:05:34,5702,221,"is mknod portable? if not, what is the alternative?","I would like to use `mknod` in my code to create a file, but `man` says, that 

> The only portable use of mknod() is to create a FIFO-special file.  If mode is not S_IFIFO or dev is not  0,  the  behavior  of
       mknod()  is unspecified.

Does that mean, that mknod is not really portable and I should use some other way to create a function? How about calling `open` and the instantly `close`? Which way is safer?",c,posix,mknod,,,,open,0,89,9,"is mknod portable? if not, what is the alternative? I would like to use `mknod` in my code to create a file, but `man` says, that 

> The only portable use of mknod() is to create a FIFO-special file.  If mode is not S_IFIFO or dev is not  0,  the  behavior  of
       mknod()  is unspecified.

Does that mean, that mknod is not really portable and I should use some other way to create a function? How about calling `open` and the instantly `close`? Which way is safer?",3
9978566,04/02/2012 14:49:18,1308282,04/02/2012 14:31:56,101,0,Determining monotonic behavior of a number in C,"I want to write a simple program that determines whether the number the user inputs is increasing, strictly increasing, etc. etc. 

To solve this I want to break up each digit and see if they are always getting smaller or not, etc. 
How do I break up the input into separate digits using scanf function?

",c,,,,,,open,0,55,8,"Determining monotonic behavior of a number in C I want to write a simple program that determines whether the number the user inputs is increasing, strictly increasing, etc. etc. 

To solve this I want to break up each digit and see if they are always getting smaller or not, etc. 
How do I break up the input into separate digits using scanf function?

",1
7710032,10/10/2011 08:09:18,877235,08/03/2011 18:39:14,152,14,"weird #define declaration, can't understand to what it expand","I have this #define statement in legacy code I'm inspecting in c.

    #define STEP(x)         case x: STEP ## x : WPAN_Startup_Step = x;

This is a macro to replace cases in a very big switch state machine.
I can't understand what's going on in this macro. to what does it expand to ?

",c,define,,,,,open,0,62,9,"weird #define declaration, can't understand to what it expand I have this #define statement in legacy code I'm inspecting in c.

    #define STEP(x)         case x: STEP ## x : WPAN_Startup_Step = x;

This is a macro to replace cases in a very big switch state machine.
I can't understand what's going on in this macro. to what does it expand to ?

",2
8190400,11/18/2011 23:26:07,965949,09/26/2011 22:47:19,21,1,Program execute at a certain time. C,"Alright so my question is, how can I make a program that basically executes the rest of the program at for example 12pm. For example some non realistic code:

    #include <stdio.h>
    #include <time.h>

    int main()
    {
    
         Get_time() //Gets system time

         if(time() == 254pm ){ //if time is 2:54pm

                 printf(""Time: 2:54pm\n"");
             }
  
          else printf(""Program can not execute at this time.\n"");

          return 0;
     }

Does anyone know how I can do something similar?",c,winapi,time,,,,open,0,154,7,"Program execute at a certain time. C Alright so my question is, how can I make a program that basically executes the rest of the program at for example 12pm. For example some non realistic code:

    #include <stdio.h>
    #include <time.h>

    int main()
    {
    
         Get_time() //Gets system time

         if(time() == 254pm ){ //if time is 2:54pm

                 printf(""Time: 2:54pm\n"");
             }
  
          else printf(""Program can not execute at this time.\n"");

          return 0;
     }

Does anyone know how I can do something similar?",3
8879619,01/16/2012 11:52:50,1143051,01/11/2012 11:22:54,1,0,How to create free memory pool in c?,"In my source code I will not allocate memory at run time , but memory will be allocated from memory pool.",c,memory,memory-management,memory-pool,,01/16/2012 13:54:25,not a real question,1,21,8,"How to create free memory pool in c? In my source code I will not allocate memory at run time , but memory will be allocated from memory pool.",4
9673380,03/12/2012 19:17:50,609027,02/09/2011 00:41:40,143,0,Qsorting 2d pointer arrays,"I'm trying to sort a 2d array of pointers using qsort. The only issue I have right now is originally I was using statically declared arrays now switching over to pointers. I'm almost tempted to switch to structs but being stubborn that I can't get this to work. 


So far I malloc the 2d array of pointers[array2d[m][3] was the intended size]:

         int **array2d;
        
         array2d = (int**)malloc((m)*sizeof(int*));
        
         for(i=0; i<=m; i++)
           array2d = [i]=(int*)malloc(3*sizeof(int));
         qsort(array2d, m, 3*sizeof(int**),comp);

My compare is:

    int comp(const void* left, const void*right)                                                                                  
    {
    
      const int *a = *(const int**)left;
      const int *b = *(const int**)right;
    
      return a-b;
    }

Although I'm not sure how to structure the compare to work with 2d pointers.",c,qsort,,,,,open,0,284,4,"Qsorting 2d pointer arrays I'm trying to sort a 2d array of pointers using qsort. The only issue I have right now is originally I was using statically declared arrays now switching over to pointers. I'm almost tempted to switch to structs but being stubborn that I can't get this to work. 


So far I malloc the 2d array of pointers[array2d[m][3] was the intended size]:

         int **array2d;
        
         array2d = (int**)malloc((m)*sizeof(int*));
        
         for(i=0; i<=m; i++)
           array2d = [i]=(int*)malloc(3*sizeof(int));
         qsort(array2d, m, 3*sizeof(int**),comp);

My compare is:

    int comp(const void* left, const void*right)                                                                                  
    {
    
      const int *a = *(const int**)left;
      const int *b = *(const int**)right;
    
      return a-b;
    }

Although I'm not sure how to structure the compare to work with 2d pointers.",2
4987415,02/13/2011 22:40:54,14860,09/17/2008 03:36:45,129113,3855,"""int main (vooid)""? How does that work?","I just had to type in a small C test program and I made a spelling mistake in the main function by accidentally using `vooid` instead of `void`.

And yet it still worked, with `gcc -Wall` not even complaining.

The smallest complete version is:

    int main (vooid) {
        return 42;
    }

and it does indeed compile (`gcc -Wall -o myprog myprog.c`), run and return 42 (at least under CygWin).

How exactly is this valid code?
",c,syntax,main,,,,open,0,84,7,"""int main (vooid)""? How does that work? I just had to type in a small C test program and I made a spelling mistake in the main function by accidentally using `vooid` instead of `void`.

And yet it still worked, with `gcc -Wall` not even complaining.

The smallest complete version is:

    int main (vooid) {
        return 42;
    }

and it does indeed compile (`gcc -Wall -o myprog myprog.c`), run and return 42 (at least under CygWin).

How exactly is this valid code?
",3
7448262,09/16/2011 17:20:19,899213,08/17/2011 18:11:34,182,8,Why are C names shortened?,"Why there is a function called strcat and not a function called stringConcatenation, or stringConcat or string_concat or something like that? Why there is a clrscr function and not clearScreen or clear_screen?

Does it have something to do with source code size in past days, where every byte was worth gold on overly-sized floopy disks? Or is this fueled by programmers' inherent laziness? Is it a convention?",c,function,name,conventions,,09/17/2011 07:07:41,not constructive,1,66,5,"Why are C names shortened? Why there is a function called strcat and not a function called stringConcatenation, or stringConcat or string_concat or something like that? Why there is a clrscr function and not clearScreen or clear_screen?

Does it have something to do with source code size in past days, where every byte was worth gold on overly-sized floopy disks? Or is this fueled by programmers' inherent laziness? Is it a convention?",4
8006218,11/04/2011 07:45:55,975239,10/02/2011 08:43:13,6,0,shell in the C Programming language,"i want to write a shell in the Linux with C language.
what is the name of the Library and function use in this Project? thank you.",c,shell,operating-system,,,11/04/2011 10:40:37,not a real question,1,26,6,"shell in the C Programming language i want to write a shell in the Linux with C language.
what is the name of the Library and function use in this Project? thank you.",3
3143731,06/29/2010 18:42:09,379334,06/29/2010 18:41:44,1,0,Need to ramp on software design fast (8 year ASIC/FPGA system designer),"I hope you guys can help me out. I'm a 8 year ASIC/FPGA designer who's worked mainly on a system level. I'm quite familiar with C and Java but more of a test code role rather then production firmware/driver code.

I've been recently asked to be a Product Lead with the Software Group working on derivative products. What that means is that we'll be given lead product firmware that is tested well and we're supposed to proliferate that across different market segments. It is not going to be mere #define changes but it's probably not going to be major rearchitecting or starting from scratch work.

What do you think is the best starting point? Aside from jumping right into the code that is.
Also any books to recommend?'

Thank you so much for your inputs.",c,firmware,,,,06/29/2010 19:49:21,off topic,1,131,12,"Need to ramp on software design fast (8 year ASIC/FPGA system designer) I hope you guys can help me out. I'm a 8 year ASIC/FPGA designer who's worked mainly on a system level. I'm quite familiar with C and Java but more of a test code role rather then production firmware/driver code.

I've been recently asked to be a Product Lead with the Software Group working on derivative products. What that means is that we'll be given lead product firmware that is tested well and we're supposed to proliferate that across different market segments. It is not going to be mere #define changes but it's probably not going to be major rearchitecting or starting from scratch work.

What do you think is the best starting point? Aside from jumping right into the code that is.
Also any books to recommend?'

Thank you so much for your inputs.",2
3998845,10/22/2010 16:21:27,484428,10/22/2010 16:21:28,1,0,2-opt algorithm for traveling salesman problem in C programming,Hello Can someone give me a code sample of 2-opt algorithm for traveling salesman problem in C programming..,c,optimization,,,,10/22/2010 16:30:31,not a real question,1,18,9,2-opt algorithm for traveling salesman problem in C programming Hello Can someone give me a code sample of 2-opt algorithm for traveling salesman problem in C programming..,2
11535655,07/18/2012 06:43:33,1533818,07/18/2012 06:33:01,1,0,i am unable to object create a program in c.It displays fatal error,"i am unable to create even a simple program in c.It compiles bt when it comes to show the output the fatal error is displayed which says ""can't create object file"".",c,fatal-error,,,,07/18/2012 13:44:26,not a real question,1,31,13,"i am unable to object create a program in c.It displays fatal error i am unable to create even a simple program in c.It compiles bt when it comes to show the output the fatal error is displayed which says ""can't create object file"".",2
6287604,06/09/2011 02:52:16,790178,06/09/2011 02:52:16,1,0,TCP/IP books for windows OS,"I've heard about these TCP/IP books which apparently seem to focus on TCP/IP in UNIX 

[TCP-Illustrated-Vol.1][1]  
[TCP-Illustrated-Vol.2][2]

Apart from the code introduced in these books, Are there any differences between TCP/IP implementation from windows?

If yes, Can you suggest some other TCP/IP books for windows platform?

  [1]: http://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469/ref=pd_sim_b_1
  [2]: http://www.amazon.com/TCP-IP-Illustrated-Vol-Implementation/dp/020163354X/ref=pd_sim_b_1",c,winapi,tcp,winsock,,09/26/2011 14:38:04,not constructive,1,51,5,"TCP/IP books for windows OS I've heard about these TCP/IP books which apparently seem to focus on TCP/IP in UNIX 

[TCP-Illustrated-Vol.1][1]  
[TCP-Illustrated-Vol.2][2]

Apart from the code introduced in these books, Are there any differences between TCP/IP implementation from windows?

If yes, Can you suggest some other TCP/IP books for windows platform?

  [1]: http://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469/ref=pd_sim_b_1
  [2]: http://www.amazon.com/TCP-IP-Illustrated-Vol-Implementation/dp/020163354X/ref=pd_sim_b_1",4
8547221,12/17/2011 19:06:59,1020785,10/30/2011 14:57:40,80,4,Variable type specifier in C,"I just started in C programming and I know that ""%d"" defines that it will be a number value, as in:

    int x = 9;
    
    printf(""X = %d"", x);
    getchar();
    return 0;

but what are the other variable specifiers for C? (to define strings, and do they change for float, double, long, etc.?)",c,variables,,,,12/17/2011 19:24:37,not a real question,1,68,5,"Variable type specifier in C I just started in C programming and I know that ""%d"" defines that it will be a number value, as in:

    int x = 9;
    
    printf(""X = %d"", x);
    getchar();
    return 0;

but what are the other variable specifiers for C? (to define strings, and do they change for float, double, long, etc.?)",2
10367061,04/28/2012 19:58:52,1363327,04/28/2012 19:28:46,1,0,Compare a pointer to an integer in C,"I am trying to search though a linked list for an asterisk, however each time I try to use a while loop to compare the head pointer to an asterisk, the program will not compile saying that it cannot compare a pointer to an integer 

It is  in print list function:  while( pt != '*'
)

    *Description: Construction of a social network
    */

    **#include < stdio.h>**

    **#include < strings.h>**

    **#include < stdlib.h>**

    **#define SIZE 30**

    **#define PEOPLE_SIZE 20**

    **#define PRINT_NETWORK 1**

    struct people
    
    {

            char name[SIZE];
            int age;
            char gender[SIZE];
            int idnumber;
            struct friendlist *friends;
    };

    typedef struct friendlist
    
    {
    
            int friendsname[PEOPLE_SIZE];
            struct friendlist *next;
            struct people *person;
    
    }node_t;
    
    void scan_friends(FILE *input2, node_t *pt)

    {

            char *friend_name;
    
            fscanf(input2,""%s"", &pt->friendsname);
    }
    
    void  print_friends(node_t pt)
    
    {
     
           printf(""%s "", pt.friendsname);
    }
    
    void print_list(node_t *pt)
    
    {
            int friendsname[PEOPLE_SIZE];
            struct friendlist *next;
            struct people *person;
    
    }node_t;
    
     
    void  print_friends(node_t pt)
    
    {
    
            printf(""%s "", pt.friendsname);
    }
            
    void print_list (node_t *pt)
    
    {
    
            if (pt==NULL)
                    printf(""The list is empty\n"");
    

            else
    
            {
                    // traversing the list
    
                    while (pt!=NULL)
    
                    {
    
                            while (pt != '*')

                           {
                                        print_friends(*pt);
                                        pt=pt->next;
                           }
                    }
            }
    }

    int main(void)

    {

        int choice=0;
        FILE *input; //pointer to people.dat

        FILE *input_friends;
        int i=0;
        struct people people[SIZE];
        struct friendlist friendlist[PEOPLE_SIZE];
        node_t *headp, *temp, *current=NULL;
        char user_name[SIZE];
        int user;

                input_friends=fopen(""friends.dat"", ""r""); //opens friends file

                while(!feof(input_friends))
                {
                        // create a new list element
                        temp = (node_t *)malloc(sizeof(node_t));  // memory
                        scan_friends(input_friends, temp);    // initialization of element 
                        temp->next=NULL;     // setting pointer to null.

                        if (current==NULL)
                        {
                                headp=temp;  // setting the head of the list
                        }

                        else
                        {
                                    current->next=temp;   // else connecting to previous
                            }
                            current=temp;   // updating the current element
    
                            i++;   // count number of elements added
                    }
                    fclose(input_friends);
                    print_list(headp);            
                        
            }
                        
            printf(""\n"");
            return(0);
    }",c,pointers,,,,04/29/2012 05:30:58,not a real question,1,1577,8,"Compare a pointer to an integer in C I am trying to search though a linked list for an asterisk, however each time I try to use a while loop to compare the head pointer to an asterisk, the program will not compile saying that it cannot compare a pointer to an integer 

It is  in print list function:  while( pt != '*'
)

    *Description: Construction of a social network
    */

    **#include < stdio.h>**

    **#include < strings.h>**

    **#include < stdlib.h>**

    **#define SIZE 30**

    **#define PEOPLE_SIZE 20**

    **#define PRINT_NETWORK 1**

    struct people
    
    {

            char name[SIZE];
            int age;
            char gender[SIZE];
            int idnumber;
            struct friendlist *friends;
    };

    typedef struct friendlist
    
    {
    
            int friendsname[PEOPLE_SIZE];
            struct friendlist *next;
            struct people *person;
    
    }node_t;
    
    void scan_friends(FILE *input2, node_t *pt)

    {

            char *friend_name;
    
            fscanf(input2,""%s"", &pt->friendsname);
    }
    
    void  print_friends(node_t pt)
    
    {
     
           printf(""%s "", pt.friendsname);
    }
    
    void print_list(node_t *pt)
    
    {
            int friendsname[PEOPLE_SIZE];
            struct friendlist *next;
            struct people *person;
    
    }node_t;
    
     
    void  print_friends(node_t pt)
    
    {
    
            printf(""%s "", pt.friendsname);
    }
            
    void print_list (node_t *pt)
    
    {
    
            if (pt==NULL)
                    printf(""The list is empty\n"");
    

            else
    
            {
                    // traversing the list
    
                    while (pt!=NULL)
    
                    {
    
                            while (pt != '*')

                           {
                                        print_friends(*pt);
                                        pt=pt->next;
                           }
                    }
            }
    }

    int main(void)

    {

        int choice=0;
        FILE *input; //pointer to people.dat

        FILE *input_friends;
        int i=0;
        struct people people[SIZE];
        struct friendlist friendlist[PEOPLE_SIZE];
        node_t *headp, *temp, *current=NULL;
        char user_name[SIZE];
        int user;

                input_friends=fopen(""friends.dat"", ""r""); //opens friends file

                while(!feof(input_friends))
                {
                        // create a new list element
                        temp = (node_t *)malloc(sizeof(node_t));  // memory
                        scan_friends(input_friends, temp);    // initialization of element 
                        temp->next=NULL;     // setting pointer to null.

                        if (current==NULL)
                        {
                                headp=temp;  // setting the head of the list
                        }

                        else
                        {
                                    current->next=temp;   // else connecting to previous
                            }
                            current=temp;   // updating the current element
    
                            i++;   // count number of elements added
                    }
                    fclose(input_friends);
                    print_list(headp);            
                        
            }
                        
            printf(""\n"");
            return(0);
    }",2
10842389,05/31/2012 22:59:29,906153,08/22/2011 15:08:58,118,0,Problems with Implementing History in a Simple UNIX Shell,"I'm trying to implement a history feature for a simple shell. The history should hold the last 10 commands executed. I placed my code below, but I am running into some problems.

First, when I enter one (or two) commands and type in `history`to display the history, nothing is displayed. But, when I enter a few more commands, the entire history is displayed (like it should), but a string of zero's is displayed next to each history index. 

What am I doing wrong, and how can I fix this? 

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    #define MAX_LINE 80 /* 80 chars per line, per command, should be enough. */
    
    char *history[10][MAX_LINE];
    int placePointer;
    /**
     * Additional code added by: Matthew Bear
     */
    
    
    /**
     * setup() reads in the next command line, separating it into distinct tokens
     * using whitespace as delimiters. setup() sets the args parameter as a 
     * null-terminated string.
     */
    
    void setup(char inputBuffer[], char *args[],int *background)
    {
        int length, /* # of characters in the command line */
            i,      /* loop index for accessing inputBuffer array */
            start,  /* index where beginning of next command parameter is */
            ct;     /* index of where to place the next parameter into args[] */
        
        ct = 0;
        
        /* read what the user enters on the command line */
        length = read(STDIN_FILENO, inputBuffer, MAX_LINE);  
    
        start = -1;
        if (length == 0)
            exit(0);            /* ^d was entered, end of user command stream */
        if (length < 0){
            perror(""error reading the command"");
    		exit(-1);           /* terminate with error code of -1 */
        }
        
        /* examine every character in the inputBuffer */
        for (i = 0; i < length; i++) { 
            switch (inputBuffer[i]){
            case ' ':
            case '\t' :               /* argument separators */
                if(start != -1){
                    args[ct] = &inputBuffer[start];    /* set up pointer */
                    ct++;
                }
                inputBuffer[i] = '\0'; /* add a null char; make a C string */
                start = -1;
                break;
                
            case '\n':                 /* should be the final char examined */
                if (start != -1){
                    args[ct] = &inputBuffer[start];     
                    ct++;
                }
                inputBuffer[i] = '\0';
                args[ct] = NULL; /* no more arguments to this command */
                break;
    
            case '&':
                *background = 1;
                inputBuffer[i] = '\0';
                break;
                
            default :             /* some other character */
                if (start == -1)
                    start = i;
    		} 
        }    
        args[ct] = NULL; /* just in case the input line was > 80 */
    } 
    
    void displayHistory(){
    	printf(""Display History:\n"");
    	int i = placePointer;
    	int j;
    	int counter;
    	while(counter < 10) {
    		printf(""%d: "",counter);
    		for (j = 0; j < MAX_LINE; j++) {
    		  printf(""%d"",history[i][j]);
    		}
    		printf(""\n"");
    		i = (i + 1) % 10;
    		counter++;
    	}
    }
    /*
    void runHistoryAt(int index){
    	printf(""Run History At:\n"");
    	char *arg1 = &history[placePointer + index][0];
    	char *argLine[MAX_LINE/2+1];
    	int j;
    	for (j = 0; j < MAX_LINE/2+1; j++) {
    	  *argLine[j] = history[placePointer + index][j];
    	}
    	execvp(arg1,argLine);
    }*/
    
    int main(void)
    {
        char inputBuffer[MAX_LINE]; /* buffer to hold the command entered */
        int background;             /* equals 1 if a command is followed by '&' */
        char *args[MAX_LINE/2+1];/* command line (of 80) has max of 40 arguments */
        
    
        while (1){            /* Program terminates normally inside setup */
    		background = 0;
    		printf(""COMMAND->"");
    			fflush(0);
    			setup(inputBuffer, args, &background);       /* get next command */
    
    		/* the steps are:
    		 (1) fork a child process using fork()
    		 (2) the child process will invoke execvp()
    		 (3) if background == 0, the parent will wait, 
    			otherwise returns to the setup() function. */
    		
    		pid_t pid = fork();
    		printf(""Fork created.\n"");
    		
    
    		if(pid < 0){
    			printf(""Fork failed.\n"");
    		}else if(pid == 0){
    			if( strcmp(args[0],""history"") == 0){ /*  Print History */
    				displayHistory();
    			}else if(strcmp(args[0],""r"") == 0){ /*  r num */
    				int index = (int) args[1];
    				/*runHistoryAt( index - 1);*/
    			}else if(strcmp(args[0],""rr"") == 0){ /*  Run recent */
    				/*runHistoryAt(0);*/
    			}else{  /*  Execute normally */
    				printf(""executing..., adding to history buffer\n"");
    				/* Add args to history buffer */
    				int j;
    				for (j = 0; j < sizeof(args); j++) {
    					history[placePointer][j] = args[j];
    				}
    				placePointer = (placePointer + 1) % 10;
    				/* Execute!  */
    				execvp(args[0],args);
    			}
    		}
    		
    		if(background == 0){
    			wait(NULL);
    		}else{
    		  setup(inputBuffer, args, &background);
    		}
        }
    }



",c,homework,unix,,,06/04/2012 07:30:32,too localized,1,1734,9,"Problems with Implementing History in a Simple UNIX Shell I'm trying to implement a history feature for a simple shell. The history should hold the last 10 commands executed. I placed my code below, but I am running into some problems.

First, when I enter one (or two) commands and type in `history`to display the history, nothing is displayed. But, when I enter a few more commands, the entire history is displayed (like it should), but a string of zero's is displayed next to each history index. 

What am I doing wrong, and how can I fix this? 

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    
    #define MAX_LINE 80 /* 80 chars per line, per command, should be enough. */
    
    char *history[10][MAX_LINE];
    int placePointer;
    /**
     * Additional code added by: Matthew Bear
     */
    
    
    /**
     * setup() reads in the next command line, separating it into distinct tokens
     * using whitespace as delimiters. setup() sets the args parameter as a 
     * null-terminated string.
     */
    
    void setup(char inputBuffer[], char *args[],int *background)
    {
        int length, /* # of characters in the command line */
            i,      /* loop index for accessing inputBuffer array */
            start,  /* index where beginning of next command parameter is */
            ct;     /* index of where to place the next parameter into args[] */
        
        ct = 0;
        
        /* read what the user enters on the command line */
        length = read(STDIN_FILENO, inputBuffer, MAX_LINE);  
    
        start = -1;
        if (length == 0)
            exit(0);            /* ^d was entered, end of user command stream */
        if (length < 0){
            perror(""error reading the command"");
    		exit(-1);           /* terminate with error code of -1 */
        }
        
        /* examine every character in the inputBuffer */
        for (i = 0; i < length; i++) { 
            switch (inputBuffer[i]){
            case ' ':
            case '\t' :               /* argument separators */
                if(start != -1){
                    args[ct] = &inputBuffer[start];    /* set up pointer */
                    ct++;
                }
                inputBuffer[i] = '\0'; /* add a null char; make a C string */
                start = -1;
                break;
                
            case '\n':                 /* should be the final char examined */
                if (start != -1){
                    args[ct] = &inputBuffer[start];     
                    ct++;
                }
                inputBuffer[i] = '\0';
                args[ct] = NULL; /* no more arguments to this command */
                break;
    
            case '&':
                *background = 1;
                inputBuffer[i] = '\0';
                break;
                
            default :             /* some other character */
                if (start == -1)
                    start = i;
    		} 
        }    
        args[ct] = NULL; /* just in case the input line was > 80 */
    } 
    
    void displayHistory(){
    	printf(""Display History:\n"");
    	int i = placePointer;
    	int j;
    	int counter;
    	while(counter < 10) {
    		printf(""%d: "",counter);
    		for (j = 0; j < MAX_LINE; j++) {
    		  printf(""%d"",history[i][j]);
    		}
    		printf(""\n"");
    		i = (i + 1) % 10;
    		counter++;
    	}
    }
    /*
    void runHistoryAt(int index){
    	printf(""Run History At:\n"");
    	char *arg1 = &history[placePointer + index][0];
    	char *argLine[MAX_LINE/2+1];
    	int j;
    	for (j = 0; j < MAX_LINE/2+1; j++) {
    	  *argLine[j] = history[placePointer + index][j];
    	}
    	execvp(arg1,argLine);
    }*/
    
    int main(void)
    {
        char inputBuffer[MAX_LINE]; /* buffer to hold the command entered */
        int background;             /* equals 1 if a command is followed by '&' */
        char *args[MAX_LINE/2+1];/* command line (of 80) has max of 40 arguments */
        
    
        while (1){            /* Program terminates normally inside setup */
    		background = 0;
    		printf(""COMMAND->"");
    			fflush(0);
    			setup(inputBuffer, args, &background);       /* get next command */
    
    		/* the steps are:
    		 (1) fork a child process using fork()
    		 (2) the child process will invoke execvp()
    		 (3) if background == 0, the parent will wait, 
    			otherwise returns to the setup() function. */
    		
    		pid_t pid = fork();
    		printf(""Fork created.\n"");
    		
    
    		if(pid < 0){
    			printf(""Fork failed.\n"");
    		}else if(pid == 0){
    			if( strcmp(args[0],""history"") == 0){ /*  Print History */
    				displayHistory();
    			}else if(strcmp(args[0],""r"") == 0){ /*  r num */
    				int index = (int) args[1];
    				/*runHistoryAt( index - 1);*/
    			}else if(strcmp(args[0],""rr"") == 0){ /*  Run recent */
    				/*runHistoryAt(0);*/
    			}else{  /*  Execute normally */
    				printf(""executing..., adding to history buffer\n"");
    				/* Add args to history buffer */
    				int j;
    				for (j = 0; j < sizeof(args); j++) {
    					history[placePointer][j] = args[j];
    				}
    				placePointer = (placePointer + 1) % 10;
    				/* Execute!  */
    				execvp(args[0],args);
    			}
    		}
    		
    		if(background == 0){
    			wait(NULL);
    		}else{
    		  setup(inputBuffer, args, &background);
    		}
        }
    }



",3
9015476,01/26/2012 08:29:04,1170849,01/26/2012 08:21:16,1,0,Ways optimize my recursive maze solver?,"I have developed the following C program to find all possible paths out off a maze.  And it has to go through each room in the maze.  That is why the '54' is hard coded at the minute because for the 8*7 array I am passing in there are 54 open rooms.  I will work this out and pass it dynamically when I am re-writing.  However I am looking for some help in how to make the code more efficient - it finds over 300,000 possible paths to complete the maze I am passing in but it ran for almost an hour.

    #include <stdio.h>
    
    #define FALSE 0
    #define TRUE 1
    #define NROWS 8
    #define MCOLS 7
    
    // Symbols:
    //  0 = open
    // 1 = blocked
    // 2 = start
    // 3 = goal
    // '+' = path
    
    char maze[NROWS][MCOLS] = {
    
        ""2000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
    	""0000000"",
    	""3000011""
    
    };
    
    int find_path(int x, int y, int c, int *t);
    
    int main(void)
    {	
    
    	int t = 0;
    
    	if ( find_path(0, 0, 0, &t) == TRUE )
    		printf(""Success!\n"");
    	else
    		printf(""Failed\n"");
    
        return 0;
    
    }
    
    int find_path(int x, int y, int c, int *t)
    {
        if ( x < 0 || x > MCOLS - 1 || y < 0 || y > NROWS - 1 ) return FALSE;
    	
    	c++;
    	char oldMaze = maze[y][x];
    
        if ( maze[y][x] == '3' && c == 54) 
    	{
    		*t = *t+1;
    		printf(""Possible Paths are %i\n"", *t);
    		return FALSE;
    	}
    
        if ( maze[y][x] != '0' && maze[y][x] != '2' ) return FALSE;
    
        maze[y][x] = '+';
    
        if ( find_path(x, y - 1, c, t) == TRUE ) return TRUE;
    
        if ( find_path(x + 1, y, c, t) == TRUE ) return TRUE;
    
        if ( find_path(x - 1, y, c, t) == TRUE ) return TRUE;
    	
        if ( find_path(x, y + 1, c, t) == TRUE ) return TRUE;
    
        maze[y][x] = oldMaze;	
    	return FALSE;
    }  ",c,optimization,maze-solving,,,,open,0,624,6,"Ways optimize my recursive maze solver? I have developed the following C program to find all possible paths out off a maze.  And it has to go through each room in the maze.  That is why the '54' is hard coded at the minute because for the 8*7 array I am passing in there are 54 open rooms.  I will work this out and pass it dynamically when I am re-writing.  However I am looking for some help in how to make the code more efficient - it finds over 300,000 possible paths to complete the maze I am passing in but it ran for almost an hour.

    #include <stdio.h>
    
    #define FALSE 0
    #define TRUE 1
    #define NROWS 8
    #define MCOLS 7
    
    // Symbols:
    //  0 = open
    // 1 = blocked
    // 2 = start
    // 3 = goal
    // '+' = path
    
    char maze[NROWS][MCOLS] = {
    
        ""2000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
        ""0000000"",
    	""0000000"",
    	""3000011""
    
    };
    
    int find_path(int x, int y, int c, int *t);
    
    int main(void)
    {	
    
    	int t = 0;
    
    	if ( find_path(0, 0, 0, &t) == TRUE )
    		printf(""Success!\n"");
    	else
    		printf(""Failed\n"");
    
        return 0;
    
    }
    
    int find_path(int x, int y, int c, int *t)
    {
        if ( x < 0 || x > MCOLS - 1 || y < 0 || y > NROWS - 1 ) return FALSE;
    	
    	c++;
    	char oldMaze = maze[y][x];
    
        if ( maze[y][x] == '3' && c == 54) 
    	{
    		*t = *t+1;
    		printf(""Possible Paths are %i\n"", *t);
    		return FALSE;
    	}
    
        if ( maze[y][x] != '0' && maze[y][x] != '2' ) return FALSE;
    
        maze[y][x] = '+';
    
        if ( find_path(x, y - 1, c, t) == TRUE ) return TRUE;
    
        if ( find_path(x + 1, y, c, t) == TRUE ) return TRUE;
    
        if ( find_path(x - 1, y, c, t) == TRUE ) return TRUE;
    	
        if ( find_path(x, y + 1, c, t) == TRUE ) return TRUE;
    
        maze[y][x] = oldMaze;	
    	return FALSE;
    }  ",3
7975658,11/02/2011 03:54:46,977800,10/04/2011 04:49:17,137,1,Building linux kernel from source,im trying to get into linux development so for a first step im trying to compile the kernel from source can you guys provide any good tutorials for building linux kernal from source. Thanks,c,linux,build,compilation,linux-kernel,11/02/2011 03:59:11,not a real question,1,34,5,Building linux kernel from source im trying to get into linux development so for a first step im trying to compile the kernel from source can you guys provide any good tutorials for building linux kernal from source. Thanks,5
3691301,09/11/2010 14:18:33,149482,08/03/2009 03:53:31,6149,239,Accessing node data through POSIX tdelete(),"The manpage for the [POSIX binary tree functions][1] includes the following statements:

>`tdelete()` returns a pointer to the parent of the item deleted, or `NULL` if the item was not found.

>`tdelete()` frees the memory required for the node in the tree.  The user
       is responsible for freeing the memory for the corresponding data.

This means that there is no way to get access to a node's data for a given key from a `tdelete()` call. One would be required to call `tfind()` (rather than `tsearch()` so as not to add the given key), perform destruction of the node's data, and then call `tdelete()` with the same key to remove the node from the binary tree.

Have I interpreted this correctly? Is there some way around what I perceive to be limitations with this approach?

 1. If the key is heap-allocated, it can't be freed (or made useless to the comparison function in use) before the node is deleted. This requires calling `tfind()` to obtain a pointer to the data, `tdelete()` to remove the node, and then destroying the data retrieved from the `tfind()` call.
 2. Two lookups are required to delete a node and destroy it's enclosed data.


  [1]: http://linux.die.net/man/3/tsearch",c,linux,algorithm,posix,b-tree,,open,0,205,6,"Accessing node data through POSIX tdelete() The manpage for the [POSIX binary tree functions][1] includes the following statements:

>`tdelete()` returns a pointer to the parent of the item deleted, or `NULL` if the item was not found.

>`tdelete()` frees the memory required for the node in the tree.  The user
       is responsible for freeing the memory for the corresponding data.

This means that there is no way to get access to a node's data for a given key from a `tdelete()` call. One would be required to call `tfind()` (rather than `tsearch()` so as not to add the given key), perform destruction of the node's data, and then call `tdelete()` with the same key to remove the node from the binary tree.

Have I interpreted this correctly? Is there some way around what I perceive to be limitations with this approach?

 1. If the key is heap-allocated, it can't be freed (or made useless to the comparison function in use) before the node is deleted. This requires calling `tfind()` to obtain a pointer to the data, `tdelete()` to remove the node, and then destroying the data retrieved from the `tfind()` call.
 2. Two lookups are required to delete a node and destroy it's enclosed data.


  [1]: http://linux.die.net/man/3/tsearch",5
6828848,07/26/2011 10:45:27,448413,06/09/2010 10:04:01,384,2,How the given C code be interpretated by different Compiler,"I have a code below and wanted to know what could be output.What i would like to see how different compiler would interpret this particular piece of code.

    int main()
    {
    int i = -1, j = 2, k = 0, m;
    m = ++i || ++j && ++k;
    printf(""\n %d %d %d %d \n"", i, j, k, m);
    return 0;
    }

Now the question is while handling this code would compiler go by the rule which says

      This expresion can be seen as
          m = ++i || (++j && ++k); as && has higher precedence over || and the result would     be -2 2 0 1

or 

       This expresion can be seen as
          m = ++i || (++j && ++k);
    but compiler still will try to short circuit. so it evaluates ++i, since it's 1,(++j&&++k) are not evaluated.so ans is -2 2 0 1",c,,,,,11/24/2011 22:22:43,not a real question,1,201,10,"How the given C code be interpretated by different Compiler I have a code below and wanted to know what could be output.What i would like to see how different compiler would interpret this particular piece of code.

    int main()
    {
    int i = -1, j = 2, k = 0, m;
    m = ++i || ++j && ++k;
    printf(""\n %d %d %d %d \n"", i, j, k, m);
    return 0;
    }

Now the question is while handling this code would compiler go by the rule which says

      This expresion can be seen as
          m = ++i || (++j && ++k); as && has higher precedence over || and the result would     be -2 2 0 1

or 

       This expresion can be seen as
          m = ++i || (++j && ++k);
    but compiler still will try to short circuit. so it evaluates ++i, since it's 1,(++j&&++k) are not evaluated.so ans is -2 2 0 1",1
8947260,01/20/2012 20:09:09,1097106,12/14/2011 05:03:55,1,0,How to properly declare a pointer with the indirection operator set correctly in C,"When *declaring* pointers in C, I see 2 variants:

Variant A:  
`int* ptr;`

Variant B:  
`int *ptr;`

In A, the indirection operator has been appended to the type. In B, the indirection operator has been prepended to the variable.  
The way a pointer is declared differs depending on the type of documentation I read. Some authors seem to have a preference for certain variants, others use both. I now assume that it doesn't matter where one sets the indirection operator in the declaration, however, I would like to verify this thought first and, in case it is true, also ask if there is a convention for which variant one should be using in C.",c,pointers,declaration,indirection,,01/21/2012 14:17:41,not constructive,1,114,14,"How to properly declare a pointer with the indirection operator set correctly in C When *declaring* pointers in C, I see 2 variants:

Variant A:  
`int* ptr;`

Variant B:  
`int *ptr;`

In A, the indirection operator has been appended to the type. In B, the indirection operator has been prepended to the variable.  
The way a pointer is declared differs depending on the type of documentation I read. Some authors seem to have a preference for certain variants, others use both. I now assume that it doesn't matter where one sets the indirection operator in the declaration, however, I would like to verify this thought first and, in case it is true, also ask if there is a convention for which variant one should be using in C.",4
6111724,05/24/2011 14:08:40,767880,05/24/2011 14:08:40,1,0,Circular Queue Array in C,"Dear Users of StackOverflow,

I am currently having a issue at the moment and work is beginning to pile up. I have been given a task from a lecturer to produce a circular queue array. Basically the program has been provided but it is missing out the functions. 

My Knowledge of C is quite poor but I am learning.

How will I go about creating the functions to:

          - Initialise Queue
          - Show a message if queue is full
          - Show a message if queue is empty
          - Add to Queue
          - Delete an element from Queue

-------------------------------------------------------------------

*/
// pre-processor directives
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
// constants
const MAXQ = 5;
// user-defined types
typedef struct circularQADT {
int front;
int rear;
int size;
float entry [MAXQ];
};
// Function prototypes
// control modules
void menuControl();
void addControl(circularQADT&);
void deleteControl(circularQADT&);
// display modules
void displayMenu();
void displayQ(circularQADT&);
// primitive operations
void initialiseQ(circularQADT&);
int emptyQ(int);
int fullQ(int);
void addToQ(circularQADT&, float);
float deleteFromQ(circularQADT&);
// start of program
void main()
{
clrscr();
menuControl();
} // end main
void menuControl()
{
circularQADT oneQueue;
char choice;
initialiseQ(oneQueue);
displayMenu();
do {
gotoxy (1, 19);
displayQ (oneQueue);
gotoxy (17, 11);
printf (""Make your selection > "");
choice = toupper(getch());
switch (choice)
{
case '1' : initialiseQ(oneQueue);
break;
case '2' : addControl (oneQueue);
break;
case '3' : deleteControl (oneQueue);
break;
} //endswith
} while (choice != 'Q');
} // end menuControl
void displayQ (circularQADT& aQueue)
{
int indx;
printf (""Qsize : %d"", aQueue.size);
printf (""\nQfront : %d"", aQueue.front);
printf (""\nQrear : %d"",aQueue.rear);
printf (""\nQueue : "");
clreol();
if (aQueue.size == 0)
printf (""empty"");
else {
for (int i=aQueue.rear; indx !=aQueue.front; i--){
if ( i < 0)
indx = i+MAXQ;
else
indx = i;
// endif
printf (""->%.2f"", aQueue.entry[indx]);
} // endfor
} // endif
} // end displayQ
void displayMenu()
{
printf (""\n\t\t Software Development: Array Data Structures"");
printf (""\n\t\t Assessment Task 2.1 - circular queue
with counter)"");
printf (""\n\n\t\t\t1. Initialise queue."");
printf (""\n\t\t\t2. Add to queue (append)."");
printf (""\n\t\t\t3. Delete from queue (serve)."");
printf (""\n\t\t\tQ. QUIT"");
} // displayMenu

/* 	
You are required to implement the following functions
	*/
void addControl (circularQADT& aQueue)
{
/*	Displays an error message if the queue
is full, otherwise, prompts for a value
and calls addToQ().
Placing your code here.	*/
} // end addControl
void deleteControl (circularQADT& aQueue) {
/*	Displays an error message if the queue
is empty, otherwise, calls deleteFromQ().
Placing your code here.	*/
} // end deleteControl
//	 primitive operations
void initialiseQ (circularQADT& aQueue) {
/* Placing your code here	*/
} // end initialiseQ
int fullQ (int Qsize)
{
/* Placing your code here	*/
} // end fullQ
int emptyQ (int Qsize)
{
/* Placing your code here	*/
} // end emptyQ
void addToQ (circularQADT &aQueue, float aValue) {
/* Placing your code here	*/
} // end addToQ
float deleteFromQ (circularQADT &aQueue) {
/*Placing your code here	*/
} // end deleteQ




-----------------------------------------------------


Thank you for your time on reading this and I hope to recieve some feedback.

Regards,

Joe





",c,arrays,queue,program,circular,05/24/2011 14:39:29,not a real question,1,420,5,"Circular Queue Array in C Dear Users of StackOverflow,

I am currently having a issue at the moment and work is beginning to pile up. I have been given a task from a lecturer to produce a circular queue array. Basically the program has been provided but it is missing out the functions. 

My Knowledge of C is quite poor but I am learning.

How will I go about creating the functions to:

          - Initialise Queue
          - Show a message if queue is full
          - Show a message if queue is empty
          - Add to Queue
          - Delete an element from Queue

-------------------------------------------------------------------

*/
// pre-processor directives
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
// constants
const MAXQ = 5;
// user-defined types
typedef struct circularQADT {
int front;
int rear;
int size;
float entry [MAXQ];
};
// Function prototypes
// control modules
void menuControl();
void addControl(circularQADT&);
void deleteControl(circularQADT&);
// display modules
void displayMenu();
void displayQ(circularQADT&);
// primitive operations
void initialiseQ(circularQADT&);
int emptyQ(int);
int fullQ(int);
void addToQ(circularQADT&, float);
float deleteFromQ(circularQADT&);
// start of program
void main()
{
clrscr();
menuControl();
} // end main
void menuControl()
{
circularQADT oneQueue;
char choice;
initialiseQ(oneQueue);
displayMenu();
do {
gotoxy (1, 19);
displayQ (oneQueue);
gotoxy (17, 11);
printf (""Make your selection > "");
choice = toupper(getch());
switch (choice)
{
case '1' : initialiseQ(oneQueue);
break;
case '2' : addControl (oneQueue);
break;
case '3' : deleteControl (oneQueue);
break;
} //endswith
} while (choice != 'Q');
} // end menuControl
void displayQ (circularQADT& aQueue)
{
int indx;
printf (""Qsize : %d"", aQueue.size);
printf (""\nQfront : %d"", aQueue.front);
printf (""\nQrear : %d"",aQueue.rear);
printf (""\nQueue : "");
clreol();
if (aQueue.size == 0)
printf (""empty"");
else {
for (int i=aQueue.rear; indx !=aQueue.front; i--){
if ( i < 0)
indx = i+MAXQ;
else
indx = i;
// endif
printf (""->%.2f"", aQueue.entry[indx]);
} // endfor
} // endif
} // end displayQ
void displayMenu()
{
printf (""\n\t\t Software Development: Array Data Structures"");
printf (""\n\t\t Assessment Task 2.1 - circular queue
with counter)"");
printf (""\n\n\t\t\t1. Initialise queue."");
printf (""\n\t\t\t2. Add to queue (append)."");
printf (""\n\t\t\t3. Delete from queue (serve)."");
printf (""\n\t\t\tQ. QUIT"");
} // displayMenu

/* 	
You are required to implement the following functions
	*/
void addControl (circularQADT& aQueue)
{
/*	Displays an error message if the queue
is full, otherwise, prompts for a value
and calls addToQ().
Placing your code here.	*/
} // end addControl
void deleteControl (circularQADT& aQueue) {
/*	Displays an error message if the queue
is empty, otherwise, calls deleteFromQ().
Placing your code here.	*/
} // end deleteControl
//	 primitive operations
void initialiseQ (circularQADT& aQueue) {
/* Placing your code here	*/
} // end initialiseQ
int fullQ (int Qsize)
{
/* Placing your code here	*/
} // end fullQ
int emptyQ (int Qsize)
{
/* Placing your code here	*/
} // end emptyQ
void addToQ (circularQADT &aQueue, float aValue) {
/* Placing your code here	*/
} // end addToQ
float deleteFromQ (circularQADT &aQueue) {
/*Placing your code here	*/
} // end deleteQ




-----------------------------------------------------


Thank you for your time on reading this and I hope to recieve some feedback.

Regards,

Joe





",5
1183670,07/26/2009 03:48:46,68304,02/19/2009 10:15:09,253,19,How to send POST request to some website using winapi?,"I'd like to send HTTP POST request to website and retrieve the resultant page using winapi. How can I do that?

Thanks i advance.",c,c++,winapi,post,,,open,0,23,10,"How to send POST request to some website using winapi? I'd like to send HTTP POST request to website and retrieve the resultant page using winapi. How can I do that?

Thanks i advance.",4
6801390,07/23/2011 15:28:48,335355,05/07/2010 10:49:54,647,10,"How do I debug ""INT_MAX undeclared""","`printf(INT_MAX);`

limits.h is included, for some reason it's not working in this particular project. In my testbed, it just works. I have no idea how to approach this problem other than removing every single file in the entire project until it starts working. This would be an inhuman amount of work. How can I find this bug faster? What are common causes of this?",c,debugging,preprocessor,,,03/29/2012 12:45:40,too localized,1,63,6,"How do I debug ""INT_MAX undeclared"" `printf(INT_MAX);`

limits.h is included, for some reason it's not working in this particular project. In my testbed, it just works. I have no idea how to approach this problem other than removing every single file in the entire project until it starts working. This would be an inhuman amount of work. How can I find this bug faster? What are common causes of this?",3
9042419,01/28/2012 02:20:56,535522,12/08/2010 20:03:31,35,1,GTK: Infinite lazy list of widgets,"I need to display a virtually infinite scrollabe list of interactive widgets and add/remove them as necessary when new data is added or the user scrolls into an uncached area.

A TreeView ([as asked about here](http://stackoverflow.com/questions/3164262/lazy-loaded-list-view-in-gtk)) is no option, because, I need full Widgets as items (composed of standard widgets with multiple actions etc, but CellRenderer isn't for this)

Worse, I don't know my widgets' height in advance (not much variance though), so using a VBox might cause jumpiness.

Using the scrollbar should still feel as if the list was finite (i.e. updated only after scrolling has finished so the scrollbutton doesn't jump away from your mouse), and when resizing the window and the layout of the windows is updated, the scroll position shouldn't change too much (the focused widget should stay where it is, unless of course the focused widget was scrolled away).

What's the best way to do this? Maybe even a library that just sends me signals when a new widget needs to be added?

Or could the ListView be coerced to do this in a not-too-nasty way? (i.e. draw on an offscreen buffer, copy that into the cell using CellRenderer, relay mouse/keyboard events to the actual widget?)",c,gtk,vala,,,,open,0,196,6,"GTK: Infinite lazy list of widgets I need to display a virtually infinite scrollabe list of interactive widgets and add/remove them as necessary when new data is added or the user scrolls into an uncached area.

A TreeView ([as asked about here](http://stackoverflow.com/questions/3164262/lazy-loaded-list-view-in-gtk)) is no option, because, I need full Widgets as items (composed of standard widgets with multiple actions etc, but CellRenderer isn't for this)

Worse, I don't know my widgets' height in advance (not much variance though), so using a VBox might cause jumpiness.

Using the scrollbar should still feel as if the list was finite (i.e. updated only after scrolling has finished so the scrollbutton doesn't jump away from your mouse), and when resizing the window and the layout of the windows is updated, the scroll position shouldn't change too much (the focused widget should stay where it is, unless of course the focused widget was scrolled away).

What's the best way to do this? Maybe even a library that just sends me signals when a new widget needs to be added?

Or could the ListView be coerced to do this in a not-too-nasty way? (i.e. draw on an offscreen buffer, copy that into the cell using CellRenderer, relay mouse/keyboard events to the actual widget?)",3
10761713,05/25/2012 21:42:04,973794,09/30/2011 20:21:01,1,0,C - Reason behing printf ? Why not printg or just print?,"I have a very silly doubt. When I was teaching my friend C-program, he asked me ""why do we use **printf**, can't it be **printg** or just **print**"". I couldn't answer him. So is there really a reason behind choosing **printf** in C programming ?  ",c,,,,,05/26/2012 00:24:22,not a real question,1,47,12,"C - Reason behing printf ? Why not printg or just print? I have a very silly doubt. When I was teaching my friend C-program, he asked me ""why do we use **printf**, can't it be **printg** or just **print**"". I couldn't answer him. So is there really a reason behind choosing **printf** in C programming ?  ",1
8995491,01/24/2012 22:54:58,469300,10/07/2010 15:42:41,5902,292,Testing concurrent data structures,"How can you *practically* test a synchronized data structure (in C)?

Firing a couple of threads and have them compete for access to the structure for a while to see if anything goes wrong doesn't sound very safe.",c,concurrency,data-structres,,,,open,0,37,4,"Testing concurrent data structures How can you *practically* test a synchronized data structure (in C)?

Firing a couple of threads and have them compete for access to the structure for a while to see if anything goes wrong doesn't sound very safe.",3
8578071,12/20/2011 15:48:22,548504,12/20/2010 10:50:59,38,4,C-psudo code to assembly help,"My boss asked me to convert this to assembly and I don't know a lot about assembly could someone please help me out 

PLEASE I NEED HELP ASAP I HAVE HAND IT IN 1 HOUR

This is the C-psudo code given to me 

     //Global Variables 
     #define HRM_PERIOD 15
    
    int hrArr [HRM_PERIOD]
    
    int *hrPt = hrArr;
    
    /* 
    Function addtoarray
    Parameter: int np - a value to add to the array
    
    Description: Stores 16-bit value np in array using global pointer hraPt. hraPt is incremented so that the next call will add the value to the next element in the array. The pointer wraps to start when it reaches the end of the array
    */ 
    
    void addToArray(int np)
    {
    *hraPt = np;// save value
    hraPt++; // increment pointer
    // wrap around
    if (hraPt == hrArr + HRM_PERIOD) 
    hraPt = hrArr
    }

Please Please help me anything helps 

Thanks 


",c,assembly,,,,12/20/2011 16:00:57,not a real question,1,223,5,"C-psudo code to assembly help My boss asked me to convert this to assembly and I don't know a lot about assembly could someone please help me out 

PLEASE I NEED HELP ASAP I HAVE HAND IT IN 1 HOUR

This is the C-psudo code given to me 

     //Global Variables 
     #define HRM_PERIOD 15
    
    int hrArr [HRM_PERIOD]
    
    int *hrPt = hrArr;
    
    /* 
    Function addtoarray
    Parameter: int np - a value to add to the array
    
    Description: Stores 16-bit value np in array using global pointer hraPt. hraPt is incremented so that the next call will add the value to the next element in the array. The pointer wraps to start when it reaches the end of the array
    */ 
    
    void addToArray(int np)
    {
    *hraPt = np;// save value
    hraPt++; // increment pointer
    // wrap around
    if (hraPt == hrArr + HRM_PERIOD) 
    hraPt = hrArr
    }

Please Please help me anything helps 

Thanks 


",2
8257714,11/24/2011 13:19:11,1063999,11/24/2011 13:13:19,1,0,How to convert an int to string in C,"I know how to convert an str to int but, how i can do the inverse? Im trying to make a function that converts the data of an struct into an string to save it on a file.


Thanks.",c,string,integer,,,,open,0,38,9,"How to convert an int to string in C I know how to convert an str to int but, how i can do the inverse? Im trying to make a function that converts the data of an struct into an string to save it on a file.


Thanks.",3
7308045,09/05/2011 12:25:53,436802,09/01/2010 09:32:42,370,3,How do I save string tokens to char variables?,"I have a string which has been sent using udp. Now I want to read the string, tokenize it and save it to an char array. Only the first letter of each word is saved. So I just get 5 'e's from element01 to element05. I'm working in Arduino, and I know some c# but no c or c++.

    //p_params->packetBuffer contains the following string:
    //element01#element02#element03#element04#element05
    
    void packtStriper( receivedPacket * p_params )
    {
      char delims[] = ""#"";
      char *result = NULL;
      int i = 0;
    
      //Tokenize string - 'split' it on hash mark
      result = strtok( p_params->packetBuffer, delims );
    
      //Iterate through the tokens and save them to my list
      while( result != NULL )
      {
        p_params->listData[i] = *result;
        i++;
        
        result = strtok( NULL, delims );
      }
    
      //Display the data just received
      for(int j =0; j<i; j++)
      {
        Serial.print( ""Data "" );
        Serial.print( j );
        Serial.print( "": "" );
        
        Serial.println( p_params->listData[j] );
      } 
    }
    
    typedef struct receivedPacket
    {
      char            * REQType;
      char            * confName;
      unsigned  int   confData[64];
      char            listData[10];
      char            packetBuffer[UDP_BUFFER_SIZE];
      int             packetSize;
      int             inProduction;
      
    }receivedPacket;

",c,char,arduino,strtok,,,open,0,461,9,"How do I save string tokens to char variables? I have a string which has been sent using udp. Now I want to read the string, tokenize it and save it to an char array. Only the first letter of each word is saved. So I just get 5 'e's from element01 to element05. I'm working in Arduino, and I know some c# but no c or c++.

    //p_params->packetBuffer contains the following string:
    //element01#element02#element03#element04#element05
    
    void packtStriper( receivedPacket * p_params )
    {
      char delims[] = ""#"";
      char *result = NULL;
      int i = 0;
    
      //Tokenize string - 'split' it on hash mark
      result = strtok( p_params->packetBuffer, delims );
    
      //Iterate through the tokens and save them to my list
      while( result != NULL )
      {
        p_params->listData[i] = *result;
        i++;
        
        result = strtok( NULL, delims );
      }
    
      //Display the data just received
      for(int j =0; j<i; j++)
      {
        Serial.print( ""Data "" );
        Serial.print( j );
        Serial.print( "": "" );
        
        Serial.println( p_params->listData[j] );
      } 
    }
    
    typedef struct receivedPacket
    {
      char            * REQType;
      char            * confName;
      unsigned  int   confData[64];
      char            listData[10];
      char            packetBuffer[UDP_BUFFER_SIZE];
      int             packetSize;
      int             inProduction;
      
    }receivedPacket;

",4
10045449,04/06/2012 15:16:03,1317721,04/06/2012 15:10:06,1,0,looking for a free server to run a c program,I want to run a c program written for linux platform. It is a server program for chatting. So i want to run it in a server having static IP address for 24 hours. where can i get such a free server space online??,c,,,,,04/06/2012 18:35:50,off topic,1,44,10,looking for a free server to run a c program I want to run a c program written for linux platform. It is a server program for chatting. So i want to run it in a server having static IP address for 24 hours. where can i get such a free server space online??,1
3127589,06/27/2010 14:05:04,257746,01/24/2010 09:34:38,25,0,Compile EXPAT to statically-linked .a on Windows,"I am writing C program on Windows with MingW and want to use EXPAT XML library. I want to compile my program statically, so I need static .a library.

Is there any way to compile EXPAT to .a static, independent library on Windows?",c,windows,mingw,expat,,,open,0,42,7,"Compile EXPAT to statically-linked .a on Windows I am writing C program on Windows with MingW and want to use EXPAT XML library. I want to compile my program statically, so I need static .a library.

Is there any way to compile EXPAT to .a static, independent library on Windows?",4
10867995,06/03/2012 04:53:04,485498,10/24/2010 08:50:27,1661,24,Object Oriented C will not compile,"I've been going through the first couple of chapters of this pdf on OOC: http://www.planetpdf.com/codecuts/pdfs/ooc.pdf

Now I tried to implement a String class. I used to files: main.c and new2.h.

This is main.c:

    #include ""new2.h""
    #include <stdio.h>
    
    int main(){
    
    	void * stringObject = new2(String,""a"");
    	
    	printf((*stringObject).text);
    }

and this is new2.h (including blanked out code, as I got rid of everything but the bare essentials I thought I need to make this work).

    #include <stdarg.h>
    #include <assert.h>
    #include <string.h>
    #include <stdlib.h>
    
    
    struct Class{
    	size_t size;
    	void * (* ctor)(void * self, va_list * app);
    //	void * (* dtor)(void * self);
    //	void * (* clone)(const void * self);
    //	int (* differ)(const void * self, const void * b);
    
    };
    
    struct String{
    	const void * mClass;//must be first
    	char * text;
    
    };
    
    static void * String_ctor (void * _self, va_list * app)
    {
    	struct String * self = _self;
    	const char * text = va_arg(* app, const char *);
    	self->text = malloc(strlen(text)+1);
    
    	assert(self->text);
    	strcpy(self->text,text);
    	return self;
    
    }
    
    static const struct Class _String ={
    	sizeof(struct String),
    	String_ctor
    
    };
    
    
    
    const void * String =&_String;
    
    
    
    void * new2(const void * _class,...)
    {
    	const struct Class * mClass = _class;
    	void * p = calloc(1,mClass->size);
    
    	assert(p);
    	*(const struct Class **)p = mClass;
    
    	if(mClass -> ctor)
    	{
    		va_list ap;
    
    		va_start(ap,_class);
    		p=mClass->ctor(p, &ap);
    		va_end(ap);
    	}
    
    	return p;
    
    }

All of the functions in new2.h are taken mopre or less verbatim from the pdf link.
when I try to comile using gcc I get a warning. I'm dereferencing a void pointer, and an error that I can't call the string's text in main.c because my String is not a union or struct.

To be honest I find new2.h confusing. As I said I copied the functions from the pdf.
Here is what I think happens:

 1. new2 is called. The argument String tells the computer to make a pointer to a Class struct and point it to the String struct already created in new2.h.
 2. we allocate enough memory for a String object.
 3. We call the constructor (String_ctor), and use the variable argument list to get the char argument, in this case ""a"".

My understanding is fuzzy, and this code doesn't compile. Any help would be appreciated!

",c,oop,constructor,,,,open,0,606,6,"Object Oriented C will not compile I've been going through the first couple of chapters of this pdf on OOC: http://www.planetpdf.com/codecuts/pdfs/ooc.pdf

Now I tried to implement a String class. I used to files: main.c and new2.h.

This is main.c:

    #include ""new2.h""
    #include <stdio.h>
    
    int main(){
    
    	void * stringObject = new2(String,""a"");
    	
    	printf((*stringObject).text);
    }

and this is new2.h (including blanked out code, as I got rid of everything but the bare essentials I thought I need to make this work).

    #include <stdarg.h>
    #include <assert.h>
    #include <string.h>
    #include <stdlib.h>
    
    
    struct Class{
    	size_t size;
    	void * (* ctor)(void * self, va_list * app);
    //	void * (* dtor)(void * self);
    //	void * (* clone)(const void * self);
    //	int (* differ)(const void * self, const void * b);
    
    };
    
    struct String{
    	const void * mClass;//must be first
    	char * text;
    
    };
    
    static void * String_ctor (void * _self, va_list * app)
    {
    	struct String * self = _self;
    	const char * text = va_arg(* app, const char *);
    	self->text = malloc(strlen(text)+1);
    
    	assert(self->text);
    	strcpy(self->text,text);
    	return self;
    
    }
    
    static const struct Class _String ={
    	sizeof(struct String),
    	String_ctor
    
    };
    
    
    
    const void * String =&_String;
    
    
    
    void * new2(const void * _class,...)
    {
    	const struct Class * mClass = _class;
    	void * p = calloc(1,mClass->size);
    
    	assert(p);
    	*(const struct Class **)p = mClass;
    
    	if(mClass -> ctor)
    	{
    		va_list ap;
    
    		va_start(ap,_class);
    		p=mClass->ctor(p, &ap);
    		va_end(ap);
    	}
    
    	return p;
    
    }

All of the functions in new2.h are taken mopre or less verbatim from the pdf link.
when I try to comile using gcc I get a warning. I'm dereferencing a void pointer, and an error that I can't call the string's text in main.c because my String is not a union or struct.

To be honest I find new2.h confusing. As I said I copied the functions from the pdf.
Here is what I think happens:

 1. new2 is called. The argument String tells the computer to make a pointer to a Class struct and point it to the String struct already created in new2.h.
 2. we allocate enough memory for a String object.
 3. We call the constructor (String_ctor), and use the variable argument list to get the char argument, in this case ""a"".

My understanding is fuzzy, and this code doesn't compile. Any help would be appreciated!

",3
4062517,10/31/2010 09:18:33,492657,10/31/2010 09:18:33,1,0,i++ = ++i        iS THIS TRUE OR FALSE  ?  explain?,"iS THIS TRUE OR FALSE  ?  explain?

i++ = ++i",c,,,,,10/31/2010 10:42:39,not a real question,1,11,19,"i++ = ++i        iS THIS TRUE OR FALSE  ?  explain? iS THIS TRUE OR FALSE  ?  explain?

i++ = ++i",1
10154892,04/14/2012 15:42:40,1057911,11/21/2011 13:54:41,15,0,Arrays Stack Overflow,"<pre><code>    #include<stdio.h>
    int main(void)
    {
        char str[100]=""88888888888888"";
        char t[20]="""";
        gets(t);
        puts(str);
        puts(t);
        return 0;
    }</code></pre>
![enter image description here][1]


  [1]: http://i.stack.imgur.com/Nso7Z.jpg
The firts line<pre><code>555555555555555555555555555555555</code></pre>
is put in.
Why str is ""55555555555""? Why str isn't ""88888888888888888"" or ""55555555555588888""?",c,,,,,,open,0,88,3,"Arrays Stack Overflow <pre><code>    #include<stdio.h>
    int main(void)
    {
        char str[100]=""88888888888888"";
        char t[20]="""";
        gets(t);
        puts(str);
        puts(t);
        return 0;
    }</code></pre>
![enter image description here][1]


  [1]: http://i.stack.imgur.com/Nso7Z.jpg
The firts line<pre><code>555555555555555555555555555555555</code></pre>
is put in.
Why str is ""55555555555""? Why str isn't ""88888888888888888"" or ""55555555555588888""?",1
1169670,07/23/2009 04:54:02,117802,06/05/2009 05:50:00,455,16,"How to interpret ""error C2018: unknown character '0x40'?","While compiling some code I receive the following:

""error C2018: unknown character '0x40'""

I wonder how to resolve such issue?
",c,visual-studio-2008,,,,,open,0,18,8,"How to interpret ""error C2018: unknown character '0x40'? While compiling some code I receive the following:

""error C2018: unknown character '0x40'""

I wonder how to resolve such issue?
",2
10836033,05/31/2012 14:54:32,1428640,05/31/2012 14:24:42,1,0,Writing the network part of a C program,"I have begun writing (in C) a small client/server application which relies on TCP.  I lack any experience in network programming.  I chose the following approach: I prepend one byte to every message.  This byte tells the receiver about the type of the message.  The type corresponds to a struct which the receiver can impose on the message.  This approach works, but it entails a lot of redundancy.  I find myself writing switch statements over and over.  I'd be grateful, if you could point me in the right direction.

",c,networking,tcp,,,06/01/2012 01:35:48,not a real question,1,96,8,"Writing the network part of a C program I have begun writing (in C) a small client/server application which relies on TCP.  I lack any experience in network programming.  I chose the following approach: I prepend one byte to every message.  This byte tells the receiver about the type of the message.  The type corresponds to a struct which the receiver can impose on the message.  This approach works, but it entails a lot of redundancy.  I find myself writing switch statements over and over.  I'd be grateful, if you could point me in the right direction.

",3
10490509,05/07/2012 23:27:31,1368949,05/02/2012 01:10:30,13,0,Garbage value being displayed while freeing a pointer in C,"I am not sure why a garbage value is being thrown in the if loop when i try to free dataToWrite. It works fine in else loop.
Can anyone help me with this?

    FILE *readFilePointer = NULL;
	Message_buf outputMsgBuffer;
	char fileData[PIPE_BUF];
	char *dataToWrite=NULL;
	
	readFilePointer = fopen(fileToReadFrom, ""r"");
	
	if (readFilePointer == NULL)
	{
		outputMsgBuffer.messageType=1;
		dataToWrite=(char *)malloc(strlen(strcat(fileToReadFrom,"" does not exists!!""))+1);
		memset(dataToWrite,0,strlen(dataToWrite));
		dataToWrite=strcat(fileToReadFrom,"" does not exists!!"");
		strcat(outputMsgBuffer.messageText,dataToWrite);
		memset(dataToWrite,0,strlen(dataToWrite)+1);
		free(dataToWrite);
	}
	else
	{	
		//outputMsgBuffer.messageText[0] = '\0';
		while (fgets(fileData, sizeof(fileData), readFilePointer) != NULL)
		{
			dataToWrite=(char *)malloc(sizeof(fileData));
			memset(dataToWrite,0,strlen(dataToWrite));
			strcpy(dataToWrite,fileData);
			strcat(outputMsgBuffer.messageText,dataToWrite);	
			free(dataToWrite);
		}
		
		fclose(readFilePointer);
	}
	outputMsgBuffer.messageType=1;
	outputMsgBuffer.messageLength=strlen(outputMsgBuffer.messageText);
	mesg_send(fd,&outputMsgBuffer);
    }",c,pointers,,,,05/08/2012 07:31:06,too localized,1,67,10,"Garbage value being displayed while freeing a pointer in C I am not sure why a garbage value is being thrown in the if loop when i try to free dataToWrite. It works fine in else loop.
Can anyone help me with this?

    FILE *readFilePointer = NULL;
	Message_buf outputMsgBuffer;
	char fileData[PIPE_BUF];
	char *dataToWrite=NULL;
	
	readFilePointer = fopen(fileToReadFrom, ""r"");
	
	if (readFilePointer == NULL)
	{
		outputMsgBuffer.messageType=1;
		dataToWrite=(char *)malloc(strlen(strcat(fileToReadFrom,"" does not exists!!""))+1);
		memset(dataToWrite,0,strlen(dataToWrite));
		dataToWrite=strcat(fileToReadFrom,"" does not exists!!"");
		strcat(outputMsgBuffer.messageText,dataToWrite);
		memset(dataToWrite,0,strlen(dataToWrite)+1);
		free(dataToWrite);
	}
	else
	{	
		//outputMsgBuffer.messageText[0] = '\0';
		while (fgets(fileData, sizeof(fileData), readFilePointer) != NULL)
		{
			dataToWrite=(char *)malloc(sizeof(fileData));
			memset(dataToWrite,0,strlen(dataToWrite));
			strcpy(dataToWrite,fileData);
			strcat(outputMsgBuffer.messageText,dataToWrite);	
			free(dataToWrite);
		}
		
		fclose(readFilePointer);
	}
	outputMsgBuffer.messageType=1;
	outputMsgBuffer.messageLength=strlen(outputMsgBuffer.messageText);
	mesg_send(fd,&outputMsgBuffer);
    }",2
9589328,03/06/2012 18:02:57,1252907,03/06/2012 17:57:16,1,0,How to make a Game of Life using C Language,"Here`s the instruction given:

Create an ANSI C program that will read a textle containing a 25 x 25 matrix of the character x or the blank space. Display the initial generation using the function printf. Calculate the next generation using the rules mentioned above and save it in another textle. The lenames of the input and output textles should be specied as command-line parameters.



My code is:

     #include <stdio.h>  
    
     #define HEIGHT 25  
     #define WIDTH 25  
     #define LIFE_YES 1  
     #define LIFE_NO 0  
    
    
    typedef int TableType[HEIGHT][WIDTH];  
    
    
    void printTable(TableType table) 
    {  
         int height, width;  
            
             for (height = 0; height < HEIGHT; height++) 
                 {  
                 for (width = 0; width < WIDTH; width++) 
                     {  
                     if (table[height][width] == LIFE_YES) 
                        {  
                        printf(""X"");  
                        } 
                     else 
                        {  
                        printf(""-"");  
                        }  
                     }  
                 printf(""\n"");  
                 }  
              printf(""\n"");  
    }  
    
        
    void clearTable(TableType table) 
    {  
         int height, width;  
    
             for (height = 0; height < HEIGHT; height++) 
                 {  
                 for (width = 0; width < WIDTH; width++) 
                     {  
                     table[height][width] = LIFE_NO;  
                     }  
                 }  
    }  
    
        
    
    void askUser(TableType tableA) 
    {  
    
         int i;  
         int n;  
         int height, width;  
    
         printf(""Enter the amount of initial organisms: "");  
         scanf(""%d"", &n);  
    
         for (i = 0; i < n; i++) 
             {  
             printf(""Enter dimensions (x y) where organism %d will live: "", i + 1);  
             scanf(""%d %d"", &height, &width);  
             tableA[height][width] = LIFE_YES;  
             }  
         
         printTable(tableA);  
         printf(""Generation 0"");  
    
     }  
    
        
    int getNeighborValue(TableType table, int row, int col) 
    {  
    
         if (row < 0 || row >= HEIGHT || col < 0 || col >= WIDTH || table[row][col] != LIFE_YES )  
            {   
            return 0;  
            } 
         else 
            {  
            return 1;  
            }  
    }  
    
        
    int getNeighborCount(TableType table, int row, int col) 
    {  
         int neighbor = 0;  
    
         neighbor += getNeighborValue(table, row - 1, col - 1);  
         neighbor += getNeighborValue(table, row - 1, col);  
         neighbor += getNeighborValue(table, row - 1, col + 1);  
         neighbor += getNeighborValue(table, row, col - 1);  
         neighbor += getNeighborValue(table, row, col + 1);  
         neighbor += getNeighborValue(table, row + 1, col - 1);  
         neighbor += getNeighborValue(table, row + 1, col);  
         neighbor += getNeighborValue(table, row + 1, col + 1);  
        
         return neighbor;  
    }  
    
        
    void calculate(TableType tableA) 
    {  
         TableType tableB;  
         int neighbor, height, width;  
      
         for (height = 0; height < HEIGHT; height++) 
             {  
             for (width = 0; width < WIDTH; width++) 
                 {  
                 neighbor = getNeighborCount(tableA, height, width);  
                 if (neighbor==3) 
                    {
                    tableB[height][width] = LIFE_YES;  
                    } 
                 else if (neighbor == 2 && tableA[height][width] == LIFE_YES) 
                    {  
                    tableB[height][width] = LIFE_YES;  
                    } 
                 else 
                    {  
                    tableB[height][width] = LIFE_NO;  
                    }  
                 }  
             }  
    
    
         for (height = 0; height < HEIGHT; height++) 
             {  
             for (width = 0; width < WIDTH; width++) 
                 {  
                 tableA[height][width] = tableB[height][width];  
                 }  
             }  
    }  
    
    
    void loadTestData(TableType table) 
    {  
         table[3][4] = LIFE_YES;  
         table[3][5] = LIFE_YES;  
         table[3][6] = LIFE_YES;  
         table[10][4] = LIFE_YES;  
         table[10][5] = LIFE_YES;  
         table[10][6] = LIFE_YES;  
         table[11][6] = LIFE_YES;  
         table[12][5] = LIFE_YES;  
    }  
    
        
    
    int main(void) 
    {  
         TableType table;  
         char end;  
         int generation = 0;  
    
         clearTable(table);  
         loadTestData(table);  
         printTable(table);  
       
         do {  
             calculate(table);  
             printTable(table);  
             printf(""Generation %d\n"", ++generation);  
             printf(""Press q to quit or 1 to continue: "");  
             scanf("" %c"", &end);  
            } while (end != 'q') ;  
    
         return 0;  
    
    } 

I`m afraid I have it all wrong. My code works well but the instruction asks to create a program that used textfiles? I don`t really understand the instruction clearly. Should I make another code? How should it look like?
",c,conways-game-of-life,,,,03/06/2012 18:15:16,not constructive,1,2406,10,"How to make a Game of Life using C Language Here`s the instruction given:

Create an ANSI C program that will read a textle containing a 25 x 25 matrix of the character x or the blank space. Display the initial generation using the function printf. Calculate the next generation using the rules mentioned above and save it in another textle. The lenames of the input and output textles should be specied as command-line parameters.



My code is:

     #include <stdio.h>  
    
     #define HEIGHT 25  
     #define WIDTH 25  
     #define LIFE_YES 1  
     #define LIFE_NO 0  
    
    
    typedef int TableType[HEIGHT][WIDTH];  
    
    
    void printTable(TableType table) 
    {  
         int height, width;  
            
             for (height = 0; height < HEIGHT; height++) 
                 {  
                 for (width = 0; width < WIDTH; width++) 
                     {  
                     if (table[height][width] == LIFE_YES) 
                        {  
                        printf(""X"");  
                        } 
                     else 
                        {  
                        printf(""-"");  
                        }  
                     }  
                 printf(""\n"");  
                 }  
              printf(""\n"");  
    }  
    
        
    void clearTable(TableType table) 
    {  
         int height, width;  
    
             for (height = 0; height < HEIGHT; height++) 
                 {  
                 for (width = 0; width < WIDTH; width++) 
                     {  
                     table[height][width] = LIFE_NO;  
                     }  
                 }  
    }  
    
        
    
    void askUser(TableType tableA) 
    {  
    
         int i;  
         int n;  
         int height, width;  
    
         printf(""Enter the amount of initial organisms: "");  
         scanf(""%d"", &n);  
    
         for (i = 0; i < n; i++) 
             {  
             printf(""Enter dimensions (x y) where organism %d will live: "", i + 1);  
             scanf(""%d %d"", &height, &width);  
             tableA[height][width] = LIFE_YES;  
             }  
         
         printTable(tableA);  
         printf(""Generation 0"");  
    
     }  
    
        
    int getNeighborValue(TableType table, int row, int col) 
    {  
    
         if (row < 0 || row >= HEIGHT || col < 0 || col >= WIDTH || table[row][col] != LIFE_YES )  
            {   
            return 0;  
            } 
         else 
            {  
            return 1;  
            }  
    }  
    
        
    int getNeighborCount(TableType table, int row, int col) 
    {  
         int neighbor = 0;  
    
         neighbor += getNeighborValue(table, row - 1, col - 1);  
         neighbor += getNeighborValue(table, row - 1, col);  
         neighbor += getNeighborValue(table, row - 1, col + 1);  
         neighbor += getNeighborValue(table, row, col - 1);  
         neighbor += getNeighborValue(table, row, col + 1);  
         neighbor += getNeighborValue(table, row + 1, col - 1);  
         neighbor += getNeighborValue(table, row + 1, col);  
         neighbor += getNeighborValue(table, row + 1, col + 1);  
        
         return neighbor;  
    }  
    
        
    void calculate(TableType tableA) 
    {  
         TableType tableB;  
         int neighbor, height, width;  
      
         for (height = 0; height < HEIGHT; height++) 
             {  
             for (width = 0; width < WIDTH; width++) 
                 {  
                 neighbor = getNeighborCount(tableA, height, width);  
                 if (neighbor==3) 
                    {
                    tableB[height][width] = LIFE_YES;  
                    } 
                 else if (neighbor == 2 && tableA[height][width] == LIFE_YES) 
                    {  
                    tableB[height][width] = LIFE_YES;  
                    } 
                 else 
                    {  
                    tableB[height][width] = LIFE_NO;  
                    }  
                 }  
             }  
    
    
         for (height = 0; height < HEIGHT; height++) 
             {  
             for (width = 0; width < WIDTH; width++) 
                 {  
                 tableA[height][width] = tableB[height][width];  
                 }  
             }  
    }  
    
    
    void loadTestData(TableType table) 
    {  
         table[3][4] = LIFE_YES;  
         table[3][5] = LIFE_YES;  
         table[3][6] = LIFE_YES;  
         table[10][4] = LIFE_YES;  
         table[10][5] = LIFE_YES;  
         table[10][6] = LIFE_YES;  
         table[11][6] = LIFE_YES;  
         table[12][5] = LIFE_YES;  
    }  
    
        
    
    int main(void) 
    {  
         TableType table;  
         char end;  
         int generation = 0;  
    
         clearTable(table);  
         loadTestData(table);  
         printTable(table);  
       
         do {  
             calculate(table);  
             printTable(table);  
             printf(""Generation %d\n"", ++generation);  
             printf(""Press q to quit or 1 to continue: "");  
             scanf("" %c"", &end);  
            } while (end != 'q') ;  
    
         return 0;  
    
    } 

I`m afraid I have it all wrong. My code works well but the instruction asks to create a program that used textfiles? I don`t really understand the instruction clearly. Should I make another code? How should it look like?
",2
9532634,03/02/2012 11:37:44,282395,02/26/2010 21:43:12,116,1,Extract command from process (using PID),"I am implementig simple shell emulator in C. It should support running command in background (ex. sleep 5s &). So I run this command using fork() -> exec() sequence and wait for finish of that command using SIGCHLD signal handler. My question is, if there is any possibility to get process command (name), that was specified in exec() call. I give you example:

    //SIGCHLD signal handler (use for notification, when background process ends)
    void sighandler(int sig) {
        int status;
        int pid = waitpid(-1, &status, WNOHANG);
    
        if (WIFEXITED(status)) {
            if (pid != -1 && pid != 0) {
                printf(""\n[%d] Done: \n> "", (int) pid); //also need to provide user name (command) of exited process (ex. [PID] Done: sleep)
                fflush(stdout);
            }
        }
    }
    
    pid_t fork_pid = fork()
    
    if (fork_pid == 0) { //child
        execl(""sleep"", ""sleep"", ""5s"");
    } else { //parent
        ....
    }

What I need, is somehow access name of command, that was specified in exec() call (see execl(""sleep"", ""sleep"", ""5s"");) in signal handler (see signalhandler(int sig)) to output something like [PID] Done: sleep. 

I cannot use simple global variable of last runned command, because after running some command in background, more new command in foreground can appear and will rewrite that global variable. Example:

    > sleep 1m & //background command - variable is ""sleep""
    [PID of sleep process] Running in background
    > ls //foreground command - variable is ""ls""
    > cat output //foreground command - variable is ""cat""
    .
    .
    .
    [PID of sleep process] Done: sleep
    >

Any way of doing this? Thanks a lot!",c,exec,fork,signals,,,open,0,407,6,"Extract command from process (using PID) I am implementig simple shell emulator in C. It should support running command in background (ex. sleep 5s &). So I run this command using fork() -> exec() sequence and wait for finish of that command using SIGCHLD signal handler. My question is, if there is any possibility to get process command (name), that was specified in exec() call. I give you example:

    //SIGCHLD signal handler (use for notification, when background process ends)
    void sighandler(int sig) {
        int status;
        int pid = waitpid(-1, &status, WNOHANG);
    
        if (WIFEXITED(status)) {
            if (pid != -1 && pid != 0) {
                printf(""\n[%d] Done: \n> "", (int) pid); //also need to provide user name (command) of exited process (ex. [PID] Done: sleep)
                fflush(stdout);
            }
        }
    }
    
    pid_t fork_pid = fork()
    
    if (fork_pid == 0) { //child
        execl(""sleep"", ""sleep"", ""5s"");
    } else { //parent
        ....
    }

What I need, is somehow access name of command, that was specified in exec() call (see execl(""sleep"", ""sleep"", ""5s"");) in signal handler (see signalhandler(int sig)) to output something like [PID] Done: sleep. 

I cannot use simple global variable of last runned command, because after running some command in background, more new command in foreground can appear and will rewrite that global variable. Example:

    > sleep 1m & //background command - variable is ""sleep""
    [PID of sleep process] Running in background
    > ls //foreground command - variable is ""ls""
    > cat output //foreground command - variable is ""cat""
    .
    .
    .
    [PID of sleep process] Done: sleep
    >

Any way of doing this? Thanks a lot!",4
4478387,12/18/2010 14:08:56,547024,12/18/2010 14:06:29,1,0,Compiler Design Help....,"Are there any lexical, syntactic, semantic analyzers and optimizers available...???",c,,,,,12/18/2010 17:50:58,not a real question,1,10,3,"Compiler Design Help.... Are there any lexical, syntactic, semantic analyzers and optimizers available...???",1
3536779,08/21/2010 07:29:43,426980,08/21/2010 07:08:31,3,0,can any one give me the dry output for this program?,"can any one give me the dry output for this program?

#include <stdio.h>
main()
{
int a,b,c,d,e;
printf(""Enter the Number to Find it's Reverse\n"");
scanf(""%d"",&a);
while(a!=0)
{
b=a%10;
c=a/10;
printf(""%d"",b);
a=c;
}
getchar();
}",c,,,,,08/21/2010 09:59:44,too localized,1,19,11,"can any one give me the dry output for this program? can any one give me the dry output for this program?

#include <stdio.h>
main()
{
int a,b,c,d,e;
printf(""Enter the Number to Find it's Reverse\n"");
scanf(""%d"",&a);
while(a!=0)
{
b=a%10;
c=a/10;
printf(""%d"",b);
a=c;
}
getchar();
}",1
4990884,02/14/2011 10:08:13,611264,02/10/2011 11:24:15,12,0,how to jump from the if state without executing else.?,"
for(....)

if(condition)
printf(_);
*********

else
printf();

wat code ll come here....",c,,,,,02/14/2011 11:04:40,not a real question,1,5,10,"how to jump from the if state without executing else.? 
for(....)

if(condition)
printf(_);
*********

else
printf();

wat code ll come here....",1
9829769,03/22/2012 20:12:35,570689,01/11/2011 02:22:06,3175,118,"Strange ""half to even"" rounding in different languages","GNU bash, version 4.2.24:

    $> printf ""%.0f, %.0f\n"" 48.5 49.5
    48, 50


ruby 1.8.7

    > printf( ""%.0f, %.0f\n"", 48.5, 49.5 )
    48, 50

perl 5.12.4

    $> perl -e 'printf( ""%.0f, %.0f\n"", 48.5, 49.5 )'
    48, 50

gcc 4.5.3:

    > printf( ""%.0f, %.0f\n"", 48.5, 49.5 );
    48, 50

 
GHC, version 7.0.4:

    > printf ""%.0f, %.0f\n"" 48.5 49.5
    49, 50

----

Wiki said that [this kind of rounding called **round half to even**][1]. 

> This is the default rounding mode used in IEEE 754 computing functions and operators.

Why does this rounding used by default in `C`, `Perl`, `Ruby` and `Bash`, but not in `Haskell`?

Is it some sort of tradition or standard? And if it is a standard, why it's used by those languages and not used by `Haskell`? What is a point of rounding half to even?

  [1]: https://en.wikipedia.org/wiki/Rounding#Round_half_to_even",c,ruby,perl,bash,haskell,03/23/2012 09:14:51,not constructive,1,163,8,"Strange ""half to even"" rounding in different languages GNU bash, version 4.2.24:

    $> printf ""%.0f, %.0f\n"" 48.5 49.5
    48, 50


ruby 1.8.7

    > printf( ""%.0f, %.0f\n"", 48.5, 49.5 )
    48, 50

perl 5.12.4

    $> perl -e 'printf( ""%.0f, %.0f\n"", 48.5, 49.5 )'
    48, 50

gcc 4.5.3:

    > printf( ""%.0f, %.0f\n"", 48.5, 49.5 );
    48, 50

 
GHC, version 7.0.4:

    > printf ""%.0f, %.0f\n"" 48.5 49.5
    49, 50

----

Wiki said that [this kind of rounding called **round half to even**][1]. 

> This is the default rounding mode used in IEEE 754 computing functions and operators.

Why does this rounding used by default in `C`, `Perl`, `Ruby` and `Bash`, but not in `Haskell`?

Is it some sort of tradition or standard? And if it is a standard, why it's used by those languages and not used by `Haskell`? What is a point of rounding half to even?

  [1]: https://en.wikipedia.org/wiki/Rounding#Round_half_to_even",5
5819733,04/28/2011 13:52:54,729450,04/28/2011 13:52:54,1,0,Entering a 2d array in a frame in C,"I am trying to have the user input a 2d array and then it would print out that array in something like a frame, i wrote the code and it works but when it comes to printing the array the program just prints the first row of what the user inputted over and over like this:

    Enter size
    3
    Enter Array
    1 2 3
    4 5 6
    7 8 9
    
    Your Array:
         a b c    
       # # # # # 
    1  # 1 2 3 # 
    2  # 1 2 3 # 
    3  # 1 2 3 # 
       # # # # # 

Here is my code: I feel its a small error but i just can't find it.

    #include <stdio.h>
    
    int main(){
        int i,j;
        int y,x;
        int n,a,num,readNum,z;
        char ch;
    
        ch = 'a';
        num = 1;
    
        printf(""Enter size\n"");
        readNum = scanf(""%d"",&z);
    
        int Board[z][z];
        n = z+2;
        a = n+1;
       
        printf(""Enter Array\n"");
        for(x=0;x<z;x++){
            for(y=0;y<z;y++){
               readNum = scanf(""%d"",&Board[x][y]);
            }
        }
    
        printf(""\nYour Array:\n"");
        x=0;
        for(i=0;i<a;i++){
            y=0;
            for(j=0;j<a;j++){
                if(((i==0)&&(j==1))||
                   ((i==1)&&(j==0))||
                   ((i==0)&&(j==n))||
                   ((j==0)&&(i==n))){
                    printf(""   "");
                }
                if ((i==0)&&(j==0)){
                    printf(""  "");
                }
                if ((i==0 && (j>=2 && j<n))){
                    printf(""%c "",ch);
                    ch++;
                }
                if ((j==0) &&(i>=2 && i<n)){
                    printf(""%d  "",num);
                    num++;
                }
                if(((i==1) && (j>=1 && j<=n))||
                   ((i==n) && (j>=1 && j<=n))||
                   ((j==1) && (i>1  && i<n ))||
                   ((j==n) && (i>1  && i<n ))){
                    printf(""# "");
                }
                if((i>1 && i<n) && (j>1 && j<n)){ 
                    printf(""%d "",Board[x][y]);
                    y++;
                }
            }
            printf(""\n"");
        }
        return 0;
    }


",c,loops,multidimensional-array,,,,open,0,1018,9,"Entering a 2d array in a frame in C I am trying to have the user input a 2d array and then it would print out that array in something like a frame, i wrote the code and it works but when it comes to printing the array the program just prints the first row of what the user inputted over and over like this:

    Enter size
    3
    Enter Array
    1 2 3
    4 5 6
    7 8 9
    
    Your Array:
         a b c    
       # # # # # 
    1  # 1 2 3 # 
    2  # 1 2 3 # 
    3  # 1 2 3 # 
       # # # # # 

Here is my code: I feel its a small error but i just can't find it.

    #include <stdio.h>
    
    int main(){
        int i,j;
        int y,x;
        int n,a,num,readNum,z;
        char ch;
    
        ch = 'a';
        num = 1;
    
        printf(""Enter size\n"");
        readNum = scanf(""%d"",&z);
    
        int Board[z][z];
        n = z+2;
        a = n+1;
       
        printf(""Enter Array\n"");
        for(x=0;x<z;x++){
            for(y=0;y<z;y++){
               readNum = scanf(""%d"",&Board[x][y]);
            }
        }
    
        printf(""\nYour Array:\n"");
        x=0;
        for(i=0;i<a;i++){
            y=0;
            for(j=0;j<a;j++){
                if(((i==0)&&(j==1))||
                   ((i==1)&&(j==0))||
                   ((i==0)&&(j==n))||
                   ((j==0)&&(i==n))){
                    printf(""   "");
                }
                if ((i==0)&&(j==0)){
                    printf(""  "");
                }
                if ((i==0 && (j>=2 && j<n))){
                    printf(""%c "",ch);
                    ch++;
                }
                if ((j==0) &&(i>=2 && i<n)){
                    printf(""%d  "",num);
                    num++;
                }
                if(((i==1) && (j>=1 && j<=n))||
                   ((i==n) && (j>=1 && j<=n))||
                   ((j==1) && (i>1  && i<n ))||
                   ((j==n) && (i>1  && i<n ))){
                    printf(""# "");
                }
                if((i>1 && i<n) && (j>1 && j<n)){ 
                    printf(""%d "",Board[x][y]);
                    y++;
                }
            }
            printf(""\n"");
        }
        return 0;
    }


",3
4912119,02/06/2011 07:08:47,605087,02/06/2011 07:08:47,1,0,"How to I learn C programming, I have never programmed or solved a math problem?","<p>Any suggestions will be great. Though I am watching the tutorial on www.cs50.net from harvard, are they any good. Also I bought this book ""A biggners guide to C 2nd Edition"".
Am I on the right track. Also how do you think like a programmer? </p>",c,,,,,02/06/2011 07:16:49,off topic,1,45,15,"How to I learn C programming, I have never programmed or solved a math problem? <p>Any suggestions will be great. Though I am watching the tutorial on www.cs50.net from harvard, are they any good. Also I bought this book ""A biggners guide to C 2nd Edition"".
Am I on the right track. Also how do you think like a programmer? </p>",1
3617294,09/01/2010 11:00:12,432562,08/27/2010 04:55:27,1,0,maximum and minimum in c,to find minimum and maximam number,c,,,,,09/01/2010 11:05:11,not a real question,1,6,5,maximum and minimum in c to find minimum and maximam number,1
10314440,04/25/2012 11:11:57,1130397,01/04/2012 16:49:42,6,0,Recursive Function for Finding Mersenne Primes with C,"I try to write code that find Mersenne primes, but I can't do with a recusive function.


    for(int p=2; p<number; p++){
    x=pow(x,2)-1;
    x=1;
    for(r=2; r<p; r++){
    if(x<2){
    printf(""%d"",p);
    x=0;
    }
    }

How can I write recursive function truely? Any offers?
",c,function,recursion,primes,,04/26/2012 14:37:59,too localized,1,66,8,"Recursive Function for Finding Mersenne Primes with C I try to write code that find Mersenne primes, but I can't do with a recusive function.


    for(int p=2; p<number; p++){
    x=pow(x,2)-1;
    x=1;
    for(r=2; r<p; r++){
    if(x<2){
    printf(""%d"",p);
    x=0;
    }
    }

How can I write recursive function truely? Any offers?
",4
7150149,08/22/2011 15:55:06,906229,08/22/2011 15:55:06,1,0,Shouldn't This File Start With Assembly Language,"http://lxr.linux.no/#linux+v3.0.3/arch/x86/boot/header.S

This is the first file that is first read by the CPU. So shouldn't this start in Assembly Language. It starts with #include <asm/segment.h> so include is a method in C? ",c,linux,assembly,boot,,08/22/2011 17:20:53,not a real question,1,32,7,"Shouldn't This File Start With Assembly Language http://lxr.linux.no/#linux+v3.0.3/arch/x86/boot/header.S

This is the first file that is first read by the CPU. So shouldn't this start in Assembly Language. It starts with #include <asm/segment.h> so include is a method in C? ",4
7799361,10/17/2011 20:45:34,1319205,09/06/2010 17:43:04,154,4,Implement Strcpy in c,Implement String copy function. what if I give an endless string as input? What if I pass strings which don't terminate with null? Can anyone tell me is it valid question?,c,interview-questions,,,,10/17/2011 20:49:32,not a real question,1,31,4,Implement Strcpy in c Implement String copy function. what if I give an endless string as input? What if I pass strings which don't terminate with null? Can anyone tell me is it valid question?,2
3406620,08/04/2010 14:38:53,409195,08/03/2010 01:18:16,1,0,how to learn c basic easily and quickly?,how to learn c basic easily and quickly?,c,,,,,08/04/2010 14:41:54,not a real question,1,8,8,how to learn c basic easily and quickly? how to learn c basic easily and quickly?,1
9059095,01/30/2012 03:46:00,951441,09/18/2011 16:56:30,93,1,Odd behavior in C++/SDL?,"I've been working on a game in C++/SDL, but I am very puzzled by why my program is closing before the ""while"" loop ends. I looked for any loopholes, but came out empty-handed. However, after experimenting with the program, I suspect that the culprit is in my ""menu.h"" file. Here is all the code in the game. Player.h is just a bunch of definitions so far.

include_file.h

    #ifndef INCLUDE_FILE_H_INCLUDED
    #define INCLUDE_FILE_H_INCLUDED

    #include <map>
    #include <string>
    #include <SDL/SDL.h>
    #include <SDL/SDL_image.h>
    #include <SDL/SDL_mixer.h>

    using namespace std;

    struct image_struct
    {
        SDL_Surface *donkey;
        SDL_Surface *donkey_select;

        SDL_Surface *kawasaki;
        SDL_Surface *kawasaki_select;

        SDL_Surface *desert;
        SDL_Surface *desert_select;
    };

    struct sound_struct
    {
        Mix_Music *menu_theme;
    };

    struct clip_struct
    {
        SDL_Rect level_select[1];
        SDL_Rect player_select[1];
        SDL_Rect bike_select[1];
    };

    void applysurface(int x, int y, SDL_Surface *source, SDL_Surface *destination, SDL_Rect    *source_clip = NULL)
    {
        SDL_Rect offset;

        offset.x = x;
        offset.y = y;

        SDL_BlitSurface(source, source_clip, destination, &offset);
    };

    int quit;
    string level;

    image_struct image;
    sound_struct sound;
    clip_struct clip;

    SDL_Surface *screen;
    SDL_Event event;

    void variable_setvalue(void)
    {
        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
        Mix_OpenAudio(22050, MIX_DEFAULT_FORMAT, 2, 4096);

        clip.level_select[0].x = 0;
        clip.level_select[0].y = 0;
        clip.level_select[0].w = 128;
        clip.level_select[0].h = 128;

        clip.level_select[1].x = 128;
        clip.level_select[1].y = 0;
        clip.level_select[1].w = 256;
        clip.level_select[1].h = 128;

        clip.player_select[0].x = 0;
        clip.player_select[0].y = 0;
        clip.player_select[0].w = 50;
        clip.player_select[0].h = 100;

        clip.player_select[1].x = 50;
        clip.player_select[1].y = 0;
        clip.player_select[1].w = 100;
        clip.player_select[1].h = 100;

        clip.bike_select[0].x = 0;
        clip.bike_select[0].y = 0;
        clip.bike_select[0].w = 100;
        clip.bike_select[0].h = 50;

        clip.bike_select[1].x = 0;
        clip.bike_select[1].y = 50;
        clip.bike_select[1].w = 100;
        clip.bike_select[1].h = 100;

        SDL_Surface *screen = SDL_SetVideoMode(512, 512, 32, SDL_SWSURFACE);

        image.donkey = IMG_Load(""images/donkey.png"");
        image.donkey_select = IMG_Load(""images/donkey_select.png"");

        image.kawasaki = IMG_Load(""images/kawasaki.png"");
        image.kawasaki_select = IMG_Load(""images/kawasaki_select.png"");

        image.desert = IMG_Load(""images/desert.png"");
        image.desert_select = IMG_Load(""images/desert_select.png"");

        sound.menu_theme = Mix_LoadMUS(""sounds/death_desert_racing.wav"");

        level = ""desert"";
        quit = 0;

    };


    #endif // INCLUDE_FILE_H_INCLUDED

main.cpp

    #include ""include_file.h""
    #include ""player.h""
    #include ""menu.h""

    int main(int argc, char *argv[])
    {
        variable_setvalue();

        while (quit == 0)
        {
            menu_action();
            if (level == ""desert"")
            {
                SDL_WM_SetCaption(""Death Desert Racing"", NULL);
            };
        };

        SDL_FreeSurface(screen);
        Mix_CloseAudio();
        SDL_Quit();
        return 0;
    };

menu.h

    #ifndef MENU_H_INCLUDED
    #define MENU_H_INCLUDED

    #include ""include_file.h""
    #include ""player.h""

    struct menu_struct
    {
        int desert_x;
        int desert_y;
        int donkey_x;
        int donkey_y;
        int kawasaki_x;
        int kawasaki_y;

        SDL_Rect *desert;
        SDL_Rect *donkey;
        SDL_Rect *kawasaki;
    };

    menu_struct menu;

    void menu_action(void)
    {
        SDL_Event menu_event;

        string level_select = ""desert"";
        string character_select = ""donkey"";
        string vehical_select = ""kawasaki"";

        menu.desert = &clip.level_select[0];
        menu.donkey = &clip.player_select[0];
        menu.kawasaki = &clip.bike_select[0];

        menu.desert_x = 0;
        menu.desert_y = 0;

        menu.donkey_x = 0;
        menu.donkey_y = 0;

        menu.kawasaki_x = 0;
        menu.kawasaki_y = 0;

        int menu_number = 0;
        int done = 0;

        int x = 0;
        int y = 0;

        while (done == 0)
        {
            while (menu_number == 0)
            {
                if(SDL_PollEvent(&menu_event))
                {
                    x = menu_event.motion.x;
                    y = menu_event.motion.y;

                    switch(menu_event.type)
                    {
                        case SDL_MOUSEMOTION:
                            if ((x > menu.desert_x) and (x < menu.desert_x + 128) and (y > menu.desert_y) and (y < menu.desert_y + 128))
                            {menu.desert = &clip.level_select[1];}
                            else {menu.desert = &clip.level_select[0];};
                            break;
                    };
                };
         
        applysurface(menu.desert_x,menu.desert_y,image.desert_select,screen,menu.desert);
        SDL_Flip(screen);
        };
            while (menu_number == 1)
            {
                if(SDL_PollEvent(&menu_event))
                {
                    x = menu_event.motion.x;
                    y = menu_event.motion.y;

                    switch(menu_event.type)
                    {
                        case SDL_MOUSEMOTION:
                            if ((x > menu.donkey_x) and (x < menu.donkey_x + 128) and (y > menu.donkey_y) and (y < menu.donkey_y + 128))
                            {menu.donkey = &clip.player_select[1];}
                            else {menu.donkey = &clip.player_select[0];};
                            break;
                    };

                 
                applysurface(menu.donkey_x,menu.donkey_y,image.donkey,screen,menu.donkey);
                SDL_Flip(screen);
                };
            };
        };
    };

    #endif // MENU_H_INCLUDED

NOTE:
While making this post, the ""tags"" toolbar all the sudden didn't work, so I could only use ""c"" for a tag, for some reason.",c,,,,,06/06/2012 12:19:50,too localized,1,2029,4,"Odd behavior in C++/SDL? I've been working on a game in C++/SDL, but I am very puzzled by why my program is closing before the ""while"" loop ends. I looked for any loopholes, but came out empty-handed. However, after experimenting with the program, I suspect that the culprit is in my ""menu.h"" file. Here is all the code in the game. Player.h is just a bunch of definitions so far.

include_file.h

    #ifndef INCLUDE_FILE_H_INCLUDED
    #define INCLUDE_FILE_H_INCLUDED

    #include <map>
    #include <string>
    #include <SDL/SDL.h>
    #include <SDL/SDL_image.h>
    #include <SDL/SDL_mixer.h>

    using namespace std;

    struct image_struct
    {
        SDL_Surface *donkey;
        SDL_Surface *donkey_select;

        SDL_Surface *kawasaki;
        SDL_Surface *kawasaki_select;

        SDL_Surface *desert;
        SDL_Surface *desert_select;
    };

    struct sound_struct
    {
        Mix_Music *menu_theme;
    };

    struct clip_struct
    {
        SDL_Rect level_select[1];
        SDL_Rect player_select[1];
        SDL_Rect bike_select[1];
    };

    void applysurface(int x, int y, SDL_Surface *source, SDL_Surface *destination, SDL_Rect    *source_clip = NULL)
    {
        SDL_Rect offset;

        offset.x = x;
        offset.y = y;

        SDL_BlitSurface(source, source_clip, destination, &offset);
    };

    int quit;
    string level;

    image_struct image;
    sound_struct sound;
    clip_struct clip;

    SDL_Surface *screen;
    SDL_Event event;

    void variable_setvalue(void)
    {
        SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
        Mix_OpenAudio(22050, MIX_DEFAULT_FORMAT, 2, 4096);

        clip.level_select[0].x = 0;
        clip.level_select[0].y = 0;
        clip.level_select[0].w = 128;
        clip.level_select[0].h = 128;

        clip.level_select[1].x = 128;
        clip.level_select[1].y = 0;
        clip.level_select[1].w = 256;
        clip.level_select[1].h = 128;

        clip.player_select[0].x = 0;
        clip.player_select[0].y = 0;
        clip.player_select[0].w = 50;
        clip.player_select[0].h = 100;

        clip.player_select[1].x = 50;
        clip.player_select[1].y = 0;
        clip.player_select[1].w = 100;
        clip.player_select[1].h = 100;

        clip.bike_select[0].x = 0;
        clip.bike_select[0].y = 0;
        clip.bike_select[0].w = 100;
        clip.bike_select[0].h = 50;

        clip.bike_select[1].x = 0;
        clip.bike_select[1].y = 50;
        clip.bike_select[1].w = 100;
        clip.bike_select[1].h = 100;

        SDL_Surface *screen = SDL_SetVideoMode(512, 512, 32, SDL_SWSURFACE);

        image.donkey = IMG_Load(""images/donkey.png"");
        image.donkey_select = IMG_Load(""images/donkey_select.png"");

        image.kawasaki = IMG_Load(""images/kawasaki.png"");
        image.kawasaki_select = IMG_Load(""images/kawasaki_select.png"");

        image.desert = IMG_Load(""images/desert.png"");
        image.desert_select = IMG_Load(""images/desert_select.png"");

        sound.menu_theme = Mix_LoadMUS(""sounds/death_desert_racing.wav"");

        level = ""desert"";
        quit = 0;

    };


    #endif // INCLUDE_FILE_H_INCLUDED

main.cpp

    #include ""include_file.h""
    #include ""player.h""
    #include ""menu.h""

    int main(int argc, char *argv[])
    {
        variable_setvalue();

        while (quit == 0)
        {
            menu_action();
            if (level == ""desert"")
            {
                SDL_WM_SetCaption(""Death Desert Racing"", NULL);
            };
        };

        SDL_FreeSurface(screen);
        Mix_CloseAudio();
        SDL_Quit();
        return 0;
    };

menu.h

    #ifndef MENU_H_INCLUDED
    #define MENU_H_INCLUDED

    #include ""include_file.h""
    #include ""player.h""

    struct menu_struct
    {
        int desert_x;
        int desert_y;
        int donkey_x;
        int donkey_y;
        int kawasaki_x;
        int kawasaki_y;

        SDL_Rect *desert;
        SDL_Rect *donkey;
        SDL_Rect *kawasaki;
    };

    menu_struct menu;

    void menu_action(void)
    {
        SDL_Event menu_event;

        string level_select = ""desert"";
        string character_select = ""donkey"";
        string vehical_select = ""kawasaki"";

        menu.desert = &clip.level_select[0];
        menu.donkey = &clip.player_select[0];
        menu.kawasaki = &clip.bike_select[0];

        menu.desert_x = 0;
        menu.desert_y = 0;

        menu.donkey_x = 0;
        menu.donkey_y = 0;

        menu.kawasaki_x = 0;
        menu.kawasaki_y = 0;

        int menu_number = 0;
        int done = 0;

        int x = 0;
        int y = 0;

        while (done == 0)
        {
            while (menu_number == 0)
            {
                if(SDL_PollEvent(&menu_event))
                {
                    x = menu_event.motion.x;
                    y = menu_event.motion.y;

                    switch(menu_event.type)
                    {
                        case SDL_MOUSEMOTION:
                            if ((x > menu.desert_x) and (x < menu.desert_x + 128) and (y > menu.desert_y) and (y < menu.desert_y + 128))
                            {menu.desert = &clip.level_select[1];}
                            else {menu.desert = &clip.level_select[0];};
                            break;
                    };
                };
         
        applysurface(menu.desert_x,menu.desert_y,image.desert_select,screen,menu.desert);
        SDL_Flip(screen);
        };
            while (menu_number == 1)
            {
                if(SDL_PollEvent(&menu_event))
                {
                    x = menu_event.motion.x;
                    y = menu_event.motion.y;

                    switch(menu_event.type)
                    {
                        case SDL_MOUSEMOTION:
                            if ((x > menu.donkey_x) and (x < menu.donkey_x + 128) and (y > menu.donkey_y) and (y < menu.donkey_y + 128))
                            {menu.donkey = &clip.player_select[1];}
                            else {menu.donkey = &clip.player_select[0];};
                            break;
                    };

                 
                applysurface(menu.donkey_x,menu.donkey_y,image.donkey,screen,menu.donkey);
                SDL_Flip(screen);
                };
            };
        };
    };

    #endif // MENU_H_INCLUDED

NOTE:
While making this post, the ""tags"" toolbar all the sudden didn't work, so I could only use ""c"" for a tag, for some reason.",1
6825972,07/26/2011 06:08:31,451221,09/18/2010 04:57:48,474,23,C program that will generate a table of compound interest factors,"How to write a complete C program that will generate a table of compound interest factors, `F/P`, where
`F/P =(1 + i/100)n`


In this formula 

- `F` represents the future value of a given sum of money, 
- `P` represents its present value, 
- `i` represents the annual interest rate, expressed as a percentage, 
- `n` represents the number of years.

Let each row in the table correspond to different value of n, with n ranging from 1 to 30 (hence
30 rows). Let each column represent a different interest rate. 

Include the following interest rates: `4,
4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 11, 12, and 15 percent` (hence the total of `16 columns`). Be
sure to label the rows and columns appropriately.


I have got he above problem but it cannot be displayed as in table since the columns are 16 and its values are float so even if I restrict it to a one bit precision after decimal point still the 16 values are not displayed in a row and they fall on next line.",c,logical-programming,,,,07/29/2011 11:03:17,not a real question,1,176,11,"C program that will generate a table of compound interest factors How to write a complete C program that will generate a table of compound interest factors, `F/P`, where
`F/P =(1 + i/100)n`


In this formula 

- `F` represents the future value of a given sum of money, 
- `P` represents its present value, 
- `i` represents the annual interest rate, expressed as a percentage, 
- `n` represents the number of years.

Let each row in the table correspond to different value of n, with n ranging from 1 to 30 (hence
30 rows). Let each column represent a different interest rate. 

Include the following interest rates: `4,
4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 11, 12, and 15 percent` (hence the total of `16 columns`). Be
sure to label the rows and columns appropriately.


I have got he above problem but it cannot be displayed as in table since the columns are 16 and its values are float so even if I restrict it to a one bit precision after decimal point still the 16 values are not displayed in a row and they fall on next line.",2
11711995,07/29/2012 18:52:49,1558283,07/27/2012 16:54:49,11,1,"Are there any drawbacks to using cascading ""else if"" statements?","This question pertains to pretty much all C-like ""curly bracket"" programming languages.

I'm talking about using the following:

<!-- language-all: lang-c -->

    if(condition)
        meh();
    else if(condition1)
        bleh();
    else if(condition2)
        moo();
    else
        foo();

Are there any caveats to be aware of when using this idiom in code? I'm looking for things like performance penalties, compiler limits, etc. What would a typical compiler do with something like this?

I ask because even though it looks nice and flat to the human eye, it would actually be strictly parsed as equivalent to the following, with the braces added:

    if(condition)
    {
         meh();
    }
    else
    {
        if(condition1)
        {
            bleh();
        }
        else
        {
            //...
        }
    }

i.e. the `else if` is not really a delimiter; instead each `if` would be nested inside the preceding `else`. It would be like parsing x+y+z+... as x+(y+(z+...)).

Do compilers actually treat it this way, or would they treat `else if` as a special case? If the former, what caveats would I have to be aware of?

(This is my first question on StackOverflow.)",c,if-statement,elseif,curly-brackets,,,open,0,296,10,"Are there any drawbacks to using cascading ""else if"" statements? This question pertains to pretty much all C-like ""curly bracket"" programming languages.

I'm talking about using the following:

<!-- language-all: lang-c -->

    if(condition)
        meh();
    else if(condition1)
        bleh();
    else if(condition2)
        moo();
    else
        foo();

Are there any caveats to be aware of when using this idiom in code? I'm looking for things like performance penalties, compiler limits, etc. What would a typical compiler do with something like this?

I ask because even though it looks nice and flat to the human eye, it would actually be strictly parsed as equivalent to the following, with the braces added:

    if(condition)
    {
         meh();
    }
    else
    {
        if(condition1)
        {
            bleh();
        }
        else
        {
            //...
        }
    }

i.e. the `else if` is not really a delimiter; instead each `if` would be nested inside the preceding `else`. It would be like parsing x+y+z+... as x+(y+(z+...)).

Do compilers actually treat it this way, or would they treat `else if` as a special case? If the former, what caveats would I have to be aware of?

(This is my first question on StackOverflow.)",4
7599210,09/29/2011 14:53:49,811678,06/23/2011 06:34:41,65,0,Can't understand what this code do,"Can anyone help me with explanation what this line do 

    (UserList *) malloc(sizeof(UserList)); 

I'm new to C world. What I understand is that allocate memory for Userlist type. 
If so why definition is not just 

    Userlist malloc(sizeof(UserList))  ?

",c,,,,,09/29/2011 15:03:39,not constructive,1,47,6,"Can't understand what this code do Can anyone help me with explanation what this line do 

    (UserList *) malloc(sizeof(UserList)); 

I'm new to C world. What I understand is that allocate memory for Userlist type. 
If so why definition is not just 

    Userlist malloc(sizeof(UserList))  ?

",1
7027715,08/11/2011 14:32:06,742298,05/06/2011 18:35:00,11,0,How to use binary search algorithm?,"Suppose DATA array contains 1000000 elements. Using the binary search algorithm, if one requires about n comparisons to find the location of an item in the DATA array, then what is the value of n?

Please explain in detail!! ",c,list,linked,,,08/11/2011 14:46:10,not a real question,1,39,6,"How to use binary search algorithm? Suppose DATA array contains 1000000 elements. Using the binary search algorithm, if one requires about n comparisons to find the location of an item in the DATA array, then what is the value of n?

Please explain in detail!! ",3
10558578,05/11/2012 21:01:19,898390,08/17/2011 10:00:27,461,14,Duplicate error: C file include,"One of my questions, as I'm pretty new to C is about ways to avoid getting the duplication error. Basically, when I build the project in Netbeans if I have the file in the project and also include it, I get that error.  
  
Defining the functions static, is a correct way to avoid it? What other solutions are there? Thanks",c,,,,,,open,0,63,5,"Duplicate error: C file include One of my questions, as I'm pretty new to C is about ways to avoid getting the duplication error. Basically, when I build the project in Netbeans if I have the file in the project and also include it, I get that error.  
  
Defining the functions static, is a correct way to avoid it? What other solutions are there? Thanks",1
6971333,08/07/2011 07:18:21,871326,07/31/2011 06:25:07,5,0,How to use themes with gtk+ in windows,"I am trying to learn gtk+. I use windows.
By default gtk+ gives a look of Windows 98/2000.

But on linux there are different themes available.
I have downloaded the aurora theme engine and theme. I have also successfully complied it on windows. But don't know how to use it.

I am using Mingw/MSYS.",c,themes,mingw,gtk+,,08/09/2011 15:13:33,off topic,1,50,8,"How to use themes with gtk+ in windows I am trying to learn gtk+. I use windows.
By default gtk+ gives a look of Windows 98/2000.

But on linux there are different themes available.
I have downloaded the aurora theme engine and theme. I have also successfully complied it on windows. But don't know how to use it.

I am using Mingw/MSYS.",4
5581047,04/07/2011 12:30:57,692791,04/05/2011 11:38:51,17,0,invalid operands in linked list,"I was working with my code and I have this problem



#include<stdio.h>
#include<stdlib.h>
#include<conio.h>

struct stackNode
{
       int data;
       struct stackNode *nextPtr;
       };
       
      
        void instructions()
  {
       printf(""[1]Push a value on the stack\n"");
       printf(""[2]Pop a value off the stack\n"");
       printf(""[3]Display the whole stack\n"");
       printf(""[4]Exit"");
       } 
            
            void push(struct stackPtr *topPtr, int info)
{
     struct stackNode *newPtr;
     {
     newPtr= malloc(sizeof(struct stackNode));
     if(newPtr !=NULL)
     info=newPtr->data 
     *topPtr=newPtr->nextPtr
     *topPtr=newPtr;
     }
     

}
              
       
       
       
            
int main()
{
  
   struct StackNodePtr *stackPtr;
   stackPtr = NULL;
    int choice, value;
    
      do
     {
  
        
         instructions();
         printf(""\nEnter Your Choice: "");
         scanf(""%d"",&choice);
         if(choice == 1)
             {
                  
                 printf(""Enter  a value for the stack"");
                 
                                       }
                     
              if(choice == 2)
              {
                        printf("" ""); 
                        }       
              if(choice == 3)
              {
                        
                        printf("" "");
                        }
                if(choice == 4 )
                {
                          
                          printf(""bye!"");
                          return 0;
                          }      
                          
                          
               
         }while(choice !=4);
   
    
    system(""pause"");
    }


what's wrong ?",c,list,stack,push,linked,04/07/2011 13:04:52,not a real question,1,882,5,"invalid operands in linked list I was working with my code and I have this problem



#include<stdio.h>
#include<stdlib.h>
#include<conio.h>

struct stackNode
{
       int data;
       struct stackNode *nextPtr;
       };
       
      
        void instructions()
  {
       printf(""[1]Push a value on the stack\n"");
       printf(""[2]Pop a value off the stack\n"");
       printf(""[3]Display the whole stack\n"");
       printf(""[4]Exit"");
       } 
            
            void push(struct stackPtr *topPtr, int info)
{
     struct stackNode *newPtr;
     {
     newPtr= malloc(sizeof(struct stackNode));
     if(newPtr !=NULL)
     info=newPtr->data 
     *topPtr=newPtr->nextPtr
     *topPtr=newPtr;
     }
     

}
              
       
       
       
            
int main()
{
  
   struct StackNodePtr *stackPtr;
   stackPtr = NULL;
    int choice, value;
    
      do
     {
  
        
         instructions();
         printf(""\nEnter Your Choice: "");
         scanf(""%d"",&choice);
         if(choice == 1)
             {
                  
                 printf(""Enter  a value for the stack"");
                 
                                       }
                     
              if(choice == 2)
              {
                        printf("" ""); 
                        }       
              if(choice == 3)
              {
                        
                        printf("" "");
                        }
                if(choice == 4 )
                {
                          
                          printf(""bye!"");
                          return 0;
                          }      
                          
                          
               
         }while(choice !=4);
   
    
    system(""pause"");
    }


what's wrong ?",5
6247588,06/06/2011 03:50:02,777036,05/31/2011 03:37:40,8,0,What do I have to Learn to Build a Linux Keylogger?,"I'm very interested in C, Linux, and security but I only know basics of them so I thought of starting a project to expand my skills in those areas -- a simple Linux keylogger. I figure this is a good project because I can start simple and start with features like:

- log all keyboard inputs to a file
- email the log to my gmail account
- start automatically after booting

and just add as I go. The problem is I'm not sure where to start. Do I need to have knowledge of the kernel in order to do this? Any general advice or resources you guys can point me to? Thanks!",c,linux,security,,,06/06/2011 03:56:04,not a real question,1,109,11,"What do I have to Learn to Build a Linux Keylogger? I'm very interested in C, Linux, and security but I only know basics of them so I thought of starting a project to expand my skills in those areas -- a simple Linux keylogger. I figure this is a good project because I can start simple and start with features like:

- log all keyboard inputs to a file
- email the log to my gmail account
- start automatically after booting

and just add as I go. The problem is I'm not sure where to start. Do I need to have knowledge of the kernel in order to do this? Any general advice or resources you guys can point me to? Thanks!",3
4161562,11/12/2010 04:16:56,505344,11/12/2010 04:16:56,1,0,Regarding C programming,"I am working on scalable font.
Que-Are TTF file provide seed points for filling the character.?

I am reading the .ttf file and I created the outlines of characters.
Now I am trying to fill this character. Floodfill as well as scanline fill are not suitable .I want solution .",c,,,,,11/14/2010 12:55:39,not a real question,1,47,3,"Regarding C programming I am working on scalable font.
Que-Are TTF file provide seed points for filling the character.?

I am reading the .ttf file and I created the outlines of characters.
Now I am trying to fill this character. Floodfill as well as scanline fill are not suitable .I want solution .",1
11699770,07/28/2012 09:17:27,1319392,04/07/2012 17:31:31,1,0,OS X Lion deleted my C program,"I have recently bought a new macbook with OS X Lion on it, being rather pleased I will be able to write programs without any trouble. Java developping was indeed all right.

However, my problems began when I started to write in C. Several programs were accepted (for instance my homework in university), but the last one ended up in a request for restarting the computer.

OK, I restarted it - once, twice. After the third reboot my program disappeared!! Not exactly the source file, but the text has been converted into strange symbols of another encoding. And I have very big doubts that after decoding into UTF-8 it will be back my program.

Has anyone ever come across such behavior of Mac OS X? What caused Macbook delete my source code? Maybe the fact that I was writing a linked list using pointers (I know it's a dangerous issue)? Also I would like to know how to return my code!

Anyway, I would really appreciate any help. I am a programmer on VUT, and the next semester will be mostly in C ... I am already afraid of writing in C on my Mac cause  all the results can easily disappear and all my effort will be in vain.

",c,osx,pointers,,,07/28/2012 09:22:10,off topic,1,207,7,"OS X Lion deleted my C program I have recently bought a new macbook with OS X Lion on it, being rather pleased I will be able to write programs without any trouble. Java developping was indeed all right.

However, my problems began when I started to write in C. Several programs were accepted (for instance my homework in university), but the last one ended up in a request for restarting the computer.

OK, I restarted it - once, twice. After the third reboot my program disappeared!! Not exactly the source file, but the text has been converted into strange symbols of another encoding. And I have very big doubts that after decoding into UTF-8 it will be back my program.

Has anyone ever come across such behavior of Mac OS X? What caused Macbook delete my source code? Maybe the fact that I was writing a linked list using pointers (I know it's a dangerous issue)? Also I would like to know how to return my code!

Anyway, I would really appreciate any help. I am a programmer on VUT, and the next semester will be mostly in C ... I am already afraid of writing in C on my Mac cause  all the results can easily disappear and all my effort will be in vain.

",3
10058273,04/07/2012 20:50:09,1007059,10/21/2011 12:13:02,125,0,Can't include iostream in C using MS Visual C++?,"I've been trying to learn C, and I'm stuck on including libraries. I need to use strcpy(), but that method is included in the iostream library, but whenever I try to include the library, the program gives me errors. I've tried using ""iostream"", ""iostream.h"", <iostream>, <iostream.h>, but it either gives me a ""can't find iostream.h"" error, or the program exceeds 100 errors and just crashes. Even if my code is empty, I still get the same thing. Here's the code: 


    #include ""iostream""
    
    int main(void)
    {
    }

Yup, just that much makes it crash already. And here's a part of the errors I'm getting (could never paste them all here): 

    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(37): error C2061: syntax error : identifier 'abs'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(37): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2061: syntax error : identifier 'acos'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2061: syntax error : identifier 'asin'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'atan'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'atan2'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'ceil'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(41): error C2061: syntax error : identifier 'cos'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(41): fatal error C1003: error count exceeds 100; stopping compilation
    ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========


So yeah it even exceeds the 100 errors and the program just stops counting. I don't understand why, I'm just including a regular library. Is there an equivalent of strcpy()? I mainly wanted to use it like this (for practice): 


    #include ""stdafx.h""
    #include ""stdlib.h""
    #include ""stdio.h""
    #include ""conio.h""
    #include ""iostream""
    
    int main(void)
    {
    	struct person 
    	{ 
    		int id; 
    		char name[50];
    		int age;
    	}; 
    
    	struct person p1;
    
    	p1.id = 5595; 
    	strcpy(p1.name, ""Myname"");
    	p1.age = 18;
    
    	printf(""%d%s%d"", p1.id, p1.name, p1.age);
    }

",c,struct,iostream,strcpy,,,open,0,517,9,"Can't include iostream in C using MS Visual C++? I've been trying to learn C, and I'm stuck on including libraries. I need to use strcpy(), but that method is included in the iostream library, but whenever I try to include the library, the program gives me errors. I've tried using ""iostream"", ""iostream.h"", <iostream>, <iostream.h>, but it either gives me a ""can't find iostream.h"" error, or the program exceeds 100 errors and just crashes. Even if my code is empty, I still get the same thing. Here's the code: 


    #include ""iostream""
    
    int main(void)
    {
    }

Yup, just that much makes it crash already. And here's a part of the errors I'm getting (could never paste them all here): 

    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(37): error C2061: syntax error : identifier 'abs'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(37): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2061: syntax error : identifier 'acos'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2061: syntax error : identifier 'asin'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(39): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'atan'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'atan2'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2061: syntax error : identifier 'ceil'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(40): error C2059: syntax error : ';'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(41): error C2061: syntax error : identifier 'cos'
    1>c:\program files (x86)\microsoft visual studio 10.0\vc\include\cmath(41): fatal error C1003: error count exceeds 100; stopping compilation
    ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========


So yeah it even exceeds the 100 errors and the program just stops counting. I don't understand why, I'm just including a regular library. Is there an equivalent of strcpy()? I mainly wanted to use it like this (for practice): 


    #include ""stdafx.h""
    #include ""stdlib.h""
    #include ""stdio.h""
    #include ""conio.h""
    #include ""iostream""
    
    int main(void)
    {
    	struct person 
    	{ 
    		int id; 
    		char name[50];
    		int age;
    	}; 
    
    	struct person p1;
    
    	p1.id = 5595; 
    	strcpy(p1.name, ""Myname"");
    	p1.age = 18;
    
    	printf(""%d%s%d"", p1.id, p1.name, p1.age);
    }

",4
5372763,03/21/2011 00:49:27,461649,09/29/2010 11:10:25,13,1,Formatting C code for a document,"I am working on a book containing a number of C examples.  I am looking for a way I can spit the code through a processor that will give it to me with alternating grey/white lines with line numbers and b&w only syntax highlighting.

Any suggestions?

Thanks,

Alan
",c,documentation,ms-word,,,,open,0,46,6,"Formatting C code for a document I am working on a book containing a number of C examples.  I am looking for a way I can spit the code through a processor that will give it to me with alternating grey/white lines with line numbers and b&w only syntax highlighting.

Any suggestions?

Thanks,

Alan
",3
6943806,08/04/2011 15:05:23,778245,05/31/2011 19:25:38,113,13,Store binary values in an array in C,"I wish to store some binary values in an array in C. How it can be done and how can i access any bit of a binary number.

Plz let me know if i i am unclear in posting the doubt.",c,arrays,binary,,,08/30/2011 00:07:14,not a real question,1,40,8,"Store binary values in an array in C I wish to store some binary values in an array in C. How it can be done and how can i access any bit of a binary number.

Plz let me know if i i am unclear in posting the doubt.",3
9985818,04/03/2012 00:59:42,1060036,11/22/2011 15:02:56,107,0,Why am I getting core dumped?,"Please help me. I can't figure out why I get a core dumped when I run this program. Before returning anything I can print `all_albums_p` just fine. Why am I getting `core dumped`?

    #include ""music_server.h""
    
    struct album_ {
      int num_tracks;
      char **tracks;
      int **playlist_hits;
      
    };
    typedef struct album_ album;
    
    album *parse_album(FILE *album_file,int *number_of_albums){
    
      int number_of_album,number_of_tracks,number_of_charaters;
      int i,j;
      char dummy_space;
      int *p;
    
      fscanf(album_file,""%d"", &number_of_album);
    
      *number_of_albums = number_of_album;
    
      album *all_albums_p = (album *)malloc(sizeof(album)*number_of_album);
    
      for(j=0;j<number_of_album;j++){
    
        fscanf(album_file,""%d"", &all_albums_p[j].num_tracks);
    
        all_albums_p[j].tracks = calloc(all_albums_p[j].num_tracks,sizeof(char));
        all_albums_p[j].playlist_hits = calloc(all_albums_p[j].num_tracks,sizeof(int));
    
        for(i=0;i<all_albums_p[j].num_tracks;i++){
    
          fscanf(album_file,""%d"", &number_of_charaters);
    
          all_albums_p[j].tracks[i] = (char *)calloc(number_of_charaters+1,sizeof(char));
          all_albums_p[j].playlist_hits[i] = (int *)malloc(sizeof(int));
          all_albums_p[j].playlist_hits[i] = 0;
          fscanf(album_file,"" "",dummy_space);
          fscanf(album_file, ""%[^\n]s"", all_albums_p[j].tracks[i]);
        }
      }
      return all_albums_p;
    }
    
    int main(){
    
        album *all_tracks_ptr;
        all_tracks_ptr = parse_album(album_file,number_of_albums);
    }

errors:

`Bus Error (core dumped)`
",c,pointers,,,,04/03/2012 05:20:04,too localized,1,369,6,"Why am I getting core dumped? Please help me. I can't figure out why I get a core dumped when I run this program. Before returning anything I can print `all_albums_p` just fine. Why am I getting `core dumped`?

    #include ""music_server.h""
    
    struct album_ {
      int num_tracks;
      char **tracks;
      int **playlist_hits;
      
    };
    typedef struct album_ album;
    
    album *parse_album(FILE *album_file,int *number_of_albums){
    
      int number_of_album,number_of_tracks,number_of_charaters;
      int i,j;
      char dummy_space;
      int *p;
    
      fscanf(album_file,""%d"", &number_of_album);
    
      *number_of_albums = number_of_album;
    
      album *all_albums_p = (album *)malloc(sizeof(album)*number_of_album);
    
      for(j=0;j<number_of_album;j++){
    
        fscanf(album_file,""%d"", &all_albums_p[j].num_tracks);
    
        all_albums_p[j].tracks = calloc(all_albums_p[j].num_tracks,sizeof(char));
        all_albums_p[j].playlist_hits = calloc(all_albums_p[j].num_tracks,sizeof(int));
    
        for(i=0;i<all_albums_p[j].num_tracks;i++){
    
          fscanf(album_file,""%d"", &number_of_charaters);
    
          all_albums_p[j].tracks[i] = (char *)calloc(number_of_charaters+1,sizeof(char));
          all_albums_p[j].playlist_hits[i] = (int *)malloc(sizeof(int));
          all_albums_p[j].playlist_hits[i] = 0;
          fscanf(album_file,"" "",dummy_space);
          fscanf(album_file, ""%[^\n]s"", all_albums_p[j].tracks[i]);
        }
      }
      return all_albums_p;
    }
    
    int main(){
    
        album *all_tracks_ptr;
        all_tracks_ptr = parse_album(album_file,number_of_albums);
    }

errors:

`Bus Error (core dumped)`
",2
4059443,10/30/2010 15:56:30,438006,09/02/2010 13:16:02,51,14,Interface a microcontroller and a printer .. code it in C programming.,"Guide me how to program in ""C"" to interface a microcontroller with a printer.??
Also explain me the procedure of how actually printing is related to a micro controller.??
",c,printing,microcontroller,,,11/01/2010 04:34:10,not a real question,1,28,12,"Interface a microcontroller and a printer .. code it in C programming. Guide me how to program in ""C"" to interface a microcontroller with a printer.??
Also explain me the procedure of how actually printing is related to a micro controller.??
",3
5198414,03/04/2011 19:37:39,642080,03/02/2011 22:38:18,1,0,how to start tcp session by connecting to a server,"i am new to socket programming and i just started to develop a client application.
At my connection to server, it assigns a session id to my client.But i dont know how to remain connected to that session.I am using c programming language for developement..
PLZ help...",c,session,bsd-sockets,,,03/04/2011 22:55:47,not a real question,1,45,10,"how to start tcp session by connecting to a server i am new to socket programming and i just started to develop a client application.
At my connection to server, it assigns a session id to my client.But i dont know how to remain connected to that session.I am using c programming language for developement..
PLZ help...",3
11032336,06/14/2012 11:42:30,440844,09/06/2010 18:06:17,404,3,What persistence layer / database do the main GAME engines use?,"I have a keen interest in ""embedded databases"" like Berkeley DB, SQLite, eXtremeDB etc and am very curious as to what ""databases"" the major Game engines (or games in general) use to persist thier data?

I would assume some of them use thier own ""in house"" persistence layers / databases...

Any ideas?

Thanks

Lynton",c,lua,game-engine,,,06/15/2012 14:56:01,off topic,1,50,11,"What persistence layer / database do the main GAME engines use? I have a keen interest in ""embedded databases"" like Berkeley DB, SQLite, eXtremeDB etc and am very curious as to what ""databases"" the major Game engines (or games in general) use to persist thier data?

I would assume some of them use thier own ""in house"" persistence layers / databases...

Any ideas?

Thanks

Lynton",3
11231247,06/27/2012 16:48:24,791713,06/09/2011 20:57:13,716,80,Naming convention for methods on structure for multiple uses,"I'm writing a little library and struggling with the naming conventions. There is a structure called `gk_Stream` defined as follows:

    typedef struct gk_Stream {
        gk_Stream_writeProc write;
        gk_Stream_readProc read;
        void* data;                 // Pointer to data needed by read and write procedures.
    } gk_Stream;

Now, I want to supply 2 built-in uses for this structure.

 1. Reading/Writing from/to a `FILE*`
 2. Reading/Writing from/to a buffer

I first called the functions like the following:

    gk_Stream_initWithFile(gk_Stream* stream, FILE* fl);

    gk_Stream_initWithBufferSize(gk_Stream* stream, size_t bufferSize);
    gk_Stream_initWithStringAndBufferSize(gk_Stream* stream, char* string, size_t string_length, size_t buffer_size);
    gk_Stream_deallocBuffer(gk_Stream* stream);

But another possibility would be to call them like this:

    gk_Stream_file_init(/* */);
    gk_Stream_buffered_initWithSize(/* */);
    gk_Stream_buffered_initWithStringAndSize(/* */);
    gk_Stream_buffered_dealloc(/* */);

What names do you think make most sense or look/sound best? What are the names you would want to work with when using the library?",c,naming-conventions,naming,,,,open,0,195,9,"Naming convention for methods on structure for multiple uses I'm writing a little library and struggling with the naming conventions. There is a structure called `gk_Stream` defined as follows:

    typedef struct gk_Stream {
        gk_Stream_writeProc write;
        gk_Stream_readProc read;
        void* data;                 // Pointer to data needed by read and write procedures.
    } gk_Stream;

Now, I want to supply 2 built-in uses for this structure.

 1. Reading/Writing from/to a `FILE*`
 2. Reading/Writing from/to a buffer

I first called the functions like the following:

    gk_Stream_initWithFile(gk_Stream* stream, FILE* fl);

    gk_Stream_initWithBufferSize(gk_Stream* stream, size_t bufferSize);
    gk_Stream_initWithStringAndBufferSize(gk_Stream* stream, char* string, size_t string_length, size_t buffer_size);
    gk_Stream_deallocBuffer(gk_Stream* stream);

But another possibility would be to call them like this:

    gk_Stream_file_init(/* */);
    gk_Stream_buffered_initWithSize(/* */);
    gk_Stream_buffered_initWithStringAndSize(/* */);
    gk_Stream_buffered_dealloc(/* */);

What names do you think make most sense or look/sound best? What are the names you would want to work with when using the library?",3
10273391,04/23/2012 00:21:15,994165,10/13/2011 18:58:13,179,3,"New Thread and Program received signal SIGABRT, Aborted","My program runs fine on Linux but in Cygwin when I execute it in Cygwin terminal, I see this in the console for some reason (I didn't create any new threads):
[New Thread 6188.0x1824]
[New Thread 6188.0x1cf4]

After the program reads input I get:

Program received signal SIGABRT, Aborted.
0x00000000 in ?? ()

I do a backtrace and get:

    #0  0x00000000 in ?? ()
    #1  0x7c90df5a in ntdll!ZwWaitForSingleObject () from /cygdrive/c/WINDOWS/system32/ntdll.
    #2  0x7c8025db in WaitForSingleObjectEx () from /cygdrive/c/WINDOWS/system32/kernel32.dll
    #3  0x00000714 in ?? ()
    #4  0x00000000 in ?? ()

so i can't narrow down where the problem is.

    The stacktrace prints out:
    Exception: STATUS_ACCESS_VIOLATION at eip=004010A2
    eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=20028210 edi=6119DD9F
    ebp=0022CBF8 esp=0022CBE0 program=C:\EclipseWorkspaces\csse120\psh3\Debug\psh3.exe, pid 6308, thread main
    cs=001B ds=0023 es=0023 fs=003B gs=0000 ss=0023
    Stack trace:
    Frame     Function  Args
    0022CBF8  004010A2  (20083368, 0022CC14, 00000000, 00000400)
    0022CC18  00401AF4  (20083368, 61183630, 20062EE0, 00000000)
    0022CC38  00401B9F  (61183630, 00403100, 00000000, 00403100)
    0022CC58  00401C76  (0022CCA0, 6119DDB6, 200280E8, 00401B35)
    0022CC78  00401B45  (00000001, 0022CCA0, 200280E8, 200622B9)
    0022CD58  61006F58  (00000000, 0022CDA8, 61006550, 00000000)
    End of stack trace

If I run instead of debug in Eclipse I am able to get to the program prompt.  After typing in some text I get:
      2 [main] psh3 2668 exception::handle: Exception: STATUS_ACCESS_VIOLATION
   1491 [main] psh3 2668 open_stackdumpfile: Dumping stack trace to psh3.exe.stackdump

A few times when I ran this I was able to debug but didn't get far enough to get an idea of what the problem was.  Does anyone have an idea of what causes the the new threads to be created?
Without trying to paste everything in here, the function where I loop through:

    void process_main_loop(FILE *fp, char *prompt) {
    	char *cmdline, **arglist;
    
    	int result, parse_forprocess(char **);
    
    	setup(); //Ignore signals
    	while ((cmdline = next_cmd(prompt, fp)) != NULL) {
    		char *cmdline_sub;	//The command line with variable substitution
    		cmdline_sub = substitutevars(cmdline);
    		if ((arglist = splitline(cmdline_sub)) != NULL) {
    			result = process(arglist);
    			freelist(arglist);
    		}
    		free(cmdline);	//Free the original command line
    		free(cmdline_sub);	//Free the substituted command line
    	}
    	VLfree();
    }

Actually reading in at the prompt:

    char * next_cmd(char *prompt, FILE *fp)
    /*
     * purpose: read next command line from fp
     * returns: dynamically allocated string holding command line
     *  errors: NULL at EOF (not really an error)
     *          calls fatal from emalloc()
     *   notes: allocates space in BUFSIZ chunks.  
     */
    {
    	char *buf; /* the buffer		*/
    	int bufspace = 0; /* total size		*/
    	int pos = 0; /* current position	*/
    	int c; /* input char		*/
    
    	if (get_state() != READ_BLOCK) //Don't print the prompt if in the Read block
    		printf(""%s"", prompt); /* prompt user	*/
    	while (((c = getc(fp)) != EOF)) {
    
    		/* need space? */
    		if (pos + 1 >= bufspace) { /* 1 for \0	*/
    			if (bufspace == 0) /* y: 1st time	*/
    				buf = emalloc(BUFSIZ);
    			else
    				/* or expand	*/
    				buf = erealloc(buf, bufspace + BUFSIZ);
    			bufspace += BUFSIZ; /* update size	*/
    		}
    
    		/* end of command? */
    		if ((c == '\n') || (c == '\r')) //'\r added for files created in Windows.
    			break;
    
    		/* no, add to buffer */
    		buf[pos++] = c;
    	}
    	if (c == EOF && pos == 0) /* EOF and no input	*/
    		return NULL; /* say so		*/
    	buf[pos] = '\0';
    	return buf;
    }



",c,,,,,,open,0,799,8,"New Thread and Program received signal SIGABRT, Aborted My program runs fine on Linux but in Cygwin when I execute it in Cygwin terminal, I see this in the console for some reason (I didn't create any new threads):
[New Thread 6188.0x1824]
[New Thread 6188.0x1cf4]

After the program reads input I get:

Program received signal SIGABRT, Aborted.
0x00000000 in ?? ()

I do a backtrace and get:

    #0  0x00000000 in ?? ()
    #1  0x7c90df5a in ntdll!ZwWaitForSingleObject () from /cygdrive/c/WINDOWS/system32/ntdll.
    #2  0x7c8025db in WaitForSingleObjectEx () from /cygdrive/c/WINDOWS/system32/kernel32.dll
    #3  0x00000714 in ?? ()
    #4  0x00000000 in ?? ()

so i can't narrow down where the problem is.

    The stacktrace prints out:
    Exception: STATUS_ACCESS_VIOLATION at eip=004010A2
    eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=20028210 edi=6119DD9F
    ebp=0022CBF8 esp=0022CBE0 program=C:\EclipseWorkspaces\csse120\psh3\Debug\psh3.exe, pid 6308, thread main
    cs=001B ds=0023 es=0023 fs=003B gs=0000 ss=0023
    Stack trace:
    Frame     Function  Args
    0022CBF8  004010A2  (20083368, 0022CC14, 00000000, 00000400)
    0022CC18  00401AF4  (20083368, 61183630, 20062EE0, 00000000)
    0022CC38  00401B9F  (61183630, 00403100, 00000000, 00403100)
    0022CC58  00401C76  (0022CCA0, 6119DDB6, 200280E8, 00401B35)
    0022CC78  00401B45  (00000001, 0022CCA0, 200280E8, 200622B9)
    0022CD58  61006F58  (00000000, 0022CDA8, 61006550, 00000000)
    End of stack trace

If I run instead of debug in Eclipse I am able to get to the program prompt.  After typing in some text I get:
      2 [main] psh3 2668 exception::handle: Exception: STATUS_ACCESS_VIOLATION
   1491 [main] psh3 2668 open_stackdumpfile: Dumping stack trace to psh3.exe.stackdump

A few times when I ran this I was able to debug but didn't get far enough to get an idea of what the problem was.  Does anyone have an idea of what causes the the new threads to be created?
Without trying to paste everything in here, the function where I loop through:

    void process_main_loop(FILE *fp, char *prompt) {
    	char *cmdline, **arglist;
    
    	int result, parse_forprocess(char **);
    
    	setup(); //Ignore signals
    	while ((cmdline = next_cmd(prompt, fp)) != NULL) {
    		char *cmdline_sub;	//The command line with variable substitution
    		cmdline_sub = substitutevars(cmdline);
    		if ((arglist = splitline(cmdline_sub)) != NULL) {
    			result = process(arglist);
    			freelist(arglist);
    		}
    		free(cmdline);	//Free the original command line
    		free(cmdline_sub);	//Free the substituted command line
    	}
    	VLfree();
    }

Actually reading in at the prompt:

    char * next_cmd(char *prompt, FILE *fp)
    /*
     * purpose: read next command line from fp
     * returns: dynamically allocated string holding command line
     *  errors: NULL at EOF (not really an error)
     *          calls fatal from emalloc()
     *   notes: allocates space in BUFSIZ chunks.  
     */
    {
    	char *buf; /* the buffer		*/
    	int bufspace = 0; /* total size		*/
    	int pos = 0; /* current position	*/
    	int c; /* input char		*/
    
    	if (get_state() != READ_BLOCK) //Don't print the prompt if in the Read block
    		printf(""%s"", prompt); /* prompt user	*/
    	while (((c = getc(fp)) != EOF)) {
    
    		/* need space? */
    		if (pos + 1 >= bufspace) { /* 1 for \0	*/
    			if (bufspace == 0) /* y: 1st time	*/
    				buf = emalloc(BUFSIZ);
    			else
    				/* or expand	*/
    				buf = erealloc(buf, bufspace + BUFSIZ);
    			bufspace += BUFSIZ; /* update size	*/
    		}
    
    		/* end of command? */
    		if ((c == '\n') || (c == '\r')) //'\r added for files created in Windows.
    			break;
    
    		/* no, add to buffer */
    		buf[pos++] = c;
    	}
    	if (c == EOF && pos == 0) /* EOF and no input	*/
    		return NULL; /* say so		*/
    	buf[pos] = '\0';
    	return buf;
    }



",1
8706527,01/02/2012 23:51:49,731914,04/30/2011 00:05:59,47,1,Is the following control expression incremented in the for loop?,"In the following code, in the innermost loop, when d < p is **true** and p % d == 0 is **false**,
is variable d being incremented or is incrementing being skipped?
    
    // Program to generate a table of prime numbers

    #include <stdio.h>

    int main (void)
    {
        int p, d;
        _Bool isPrime;

        for ( p = 2; p <= 50; ++p ) {
            isPrime = 1;

            for ( d = 2; d < p; ++d )
                if ( p % d == 0 )
                    isPrime = 0;

                if ( isPrime != 0 )
                    printf (""%i  "", p);
        }
        printf (""\n"");
        return 0;
    }",c,for-loop,language-learning,,,03/31/2012 06:54:08,too localized,1,254,10,"Is the following control expression incremented in the for loop? In the following code, in the innermost loop, when d < p is **true** and p % d == 0 is **false**,
is variable d being incremented or is incrementing being skipped?
    
    // Program to generate a table of prime numbers

    #include <stdio.h>

    int main (void)
    {
        int p, d;
        _Bool isPrime;

        for ( p = 2; p <= 50; ++p ) {
            isPrime = 1;

            for ( d = 2; d < p; ++d )
                if ( p % d == 0 )
                    isPrime = 0;

                if ( isPrime != 0 )
                    printf (""%i  "", p);
        }
        printf (""\n"");
        return 0;
    }",3
6204971,06/01/2011 17:03:07,435645,08/31/2010 07:01:49,1083,1,c parse question. Must use C. Not other scripting language,"in my buffer. I have contents like this""(only show part of it, others are same record)

    (name) 
    tom 
    
    (tel)
    917 098 0000
    652 009 1111

How can I parse this into structure 


    typedef struct
    {
    	string name;
    	string[10]  tel;
    	
    }

thank you

",c,,,,,06/01/2011 17:10:05,not a real question,1,82,10,"c parse question. Must use C. Not other scripting language in my buffer. I have contents like this""(only show part of it, others are same record)

    (name) 
    tom 
    
    (tel)
    917 098 0000
    652 009 1111

How can I parse this into structure 


    typedef struct
    {
    	string name;
    	string[10]  tel;
    	
    }

thank you

",1
7042368,08/12/2011 15:22:38,71074,02/25/2009 21:20:12,7481,228,c89: Convert an int to void* and back,"First off, this is not a dupe of:

[Is it safe to cast an int to void pointer and back to int again?][1]

The difference in the questions is this: I'm only using the void* to store the int, but I never actually use it as a void*.  

So the question really comes down to this:

Is a void * guaranteed to be at least as wide as an int
 
I can't use intptr_t because I'm using c89 / ANSI C.


  [1]: http://stackoverflow.com/questions/3568069/is-it-safe-to-cast-an-int-to-void-pointer-and-back-to-int-again",c,c89,,,,,open,0,82,8,"c89: Convert an int to void* and back First off, this is not a dupe of:

[Is it safe to cast an int to void pointer and back to int again?][1]

The difference in the questions is this: I'm only using the void* to store the int, but I never actually use it as a void*.  

So the question really comes down to this:

Is a void * guaranteed to be at least as wide as an int
 
I can't use intptr_t because I'm using c89 / ANSI C.


  [1]: http://stackoverflow.com/questions/3568069/is-it-safe-to-cast-an-int-to-void-pointer-and-back-to-int-again",2
11602545,07/22/2012 17:44:21,1544243,07/22/2012 17:05:51,1,0,Minesweeper game in C," Hi guys i'm just building a minesweeper game in C. My block opening algorithm works well when looking any of the three sides(up,down,left,right). But when i try to use all the sides there is a runtime error. Here is my code:

    int checkleft(int rarea[][L],int x,int y){
        if(y==0) return 0;
        if(x==0 && (rarea[x][y-1]==9 || rarea[x+1][y-1]==9)) return 0;
        if(x==L-1 && (rarea[x][y-1]==9 || rarea[x-1][y-1]==9)) return 0;
        if(rarea[x-1][y-1]==9 || rarea[x][y-1]==9 || rarea[x+1][y-1]==9 ) return 0;
        return 1;
    }
    int checkright(int rarea[][L],int x,int y){
        if(y==L-1) return 0;
        if(x==0 && (rarea[x][y+1]==9 || rarea[x+1][y+1]==9)) return 0;
        if(x==L-1 && (rarea[x][y+1]==9 || rarea[x-1][y+1]==9)) return 0;
        if(rarea[x-1][y+1]==9 || rarea[x][y+1]==9 || rarea[x+1][y+1]==9 ) return 0;
        return 1;
    }
    int checkup(int rarea[][L],int x,int y){
        if(x==0) return 0;
        if(y==0 && (rarea[x-1][y]==9 || rarea[x-1][y+1]==9)) return 0;
        if(y==L-1 && (rarea[x-1][y-1]==9 || rarea[x-1][y]==9)) return 0;
        if(rarea[x-1][y-1]==9 || rarea[x-1][y]==9 || rarea[x-1][y+1]==9 ) return 0;
        return 1;
    }
    int checkdown(int rarea[][L],int x,int y){
        if(x==L-1) return 0;
        if(y==0 && (rarea[x+1][y]==9 || rarea[x+1][y+1]==9)) return 0;
        if(y==L-1 && (rarea[x+1][y-1]==9 || rarea[x+1][y]==9)) return 0;
        if(rarea[x+1][y-1]==9 || rarea[x+1][y]==9 || rarea[x+1][y+1]==9 ) return 0;
        return 1;
    }
    int open(char darea[][L],int rarea[][L],int x, int y,int from){
        
        if(rarea[x][y]==9 )
            return 0;
        else{
            if(rarea[x][y]!=0){
                darea[x][y]=rarea[x][y]+48;
            }
            else{
                darea[x][y]='0';
            }
            if(checkleft(rarea,x,y)==1 && from!=2)
                open(darea,rarea,x,y-1,1);
            if(checkright(rarea,x,y)==1 && from!=1)
                open(darea,rarea,x,y+1,2);
            if(checkdown(rarea,x,y)==1 && from!=4)
                open(darea,rarea,x+1,y,3);
            if(checkup(rarea,x,y)==1 && from!=3)
                open(darea,rarea,x-1,y,4);
            return 1;
        }
    }
The checkleft,checkright,checkdown,checkup functions look for that direction if there is a minesweeper.Darea is the matrix shown to user and rarea is the main matrix.

PS:Sorry for bad english :(",c,runtime-error,minesweeper,,,07/23/2012 01:08:57,too localized,1,639,4,"Minesweeper game in C  Hi guys i'm just building a minesweeper game in C. My block opening algorithm works well when looking any of the three sides(up,down,left,right). But when i try to use all the sides there is a runtime error. Here is my code:

    int checkleft(int rarea[][L],int x,int y){
        if(y==0) return 0;
        if(x==0 && (rarea[x][y-1]==9 || rarea[x+1][y-1]==9)) return 0;
        if(x==L-1 && (rarea[x][y-1]==9 || rarea[x-1][y-1]==9)) return 0;
        if(rarea[x-1][y-1]==9 || rarea[x][y-1]==9 || rarea[x+1][y-1]==9 ) return 0;
        return 1;
    }
    int checkright(int rarea[][L],int x,int y){
        if(y==L-1) return 0;
        if(x==0 && (rarea[x][y+1]==9 || rarea[x+1][y+1]==9)) return 0;
        if(x==L-1 && (rarea[x][y+1]==9 || rarea[x-1][y+1]==9)) return 0;
        if(rarea[x-1][y+1]==9 || rarea[x][y+1]==9 || rarea[x+1][y+1]==9 ) return 0;
        return 1;
    }
    int checkup(int rarea[][L],int x,int y){
        if(x==0) return 0;
        if(y==0 && (rarea[x-1][y]==9 || rarea[x-1][y+1]==9)) return 0;
        if(y==L-1 && (rarea[x-1][y-1]==9 || rarea[x-1][y]==9)) return 0;
        if(rarea[x-1][y-1]==9 || rarea[x-1][y]==9 || rarea[x-1][y+1]==9 ) return 0;
        return 1;
    }
    int checkdown(int rarea[][L],int x,int y){
        if(x==L-1) return 0;
        if(y==0 && (rarea[x+1][y]==9 || rarea[x+1][y+1]==9)) return 0;
        if(y==L-1 && (rarea[x+1][y-1]==9 || rarea[x+1][y]==9)) return 0;
        if(rarea[x+1][y-1]==9 || rarea[x+1][y]==9 || rarea[x+1][y+1]==9 ) return 0;
        return 1;
    }
    int open(char darea[][L],int rarea[][L],int x, int y,int from){
        
        if(rarea[x][y]==9 )
            return 0;
        else{
            if(rarea[x][y]!=0){
                darea[x][y]=rarea[x][y]+48;
            }
            else{
                darea[x][y]='0';
            }
            if(checkleft(rarea,x,y)==1 && from!=2)
                open(darea,rarea,x,y-1,1);
            if(checkright(rarea,x,y)==1 && from!=1)
                open(darea,rarea,x,y+1,2);
            if(checkdown(rarea,x,y)==1 && from!=4)
                open(darea,rarea,x+1,y,3);
            if(checkup(rarea,x,y)==1 && from!=3)
                open(darea,rarea,x-1,y,4);
            return 1;
        }
    }
The checkleft,checkright,checkdown,checkup functions look for that direction if there is a minesweeper.Darea is the matrix shown to user and rarea is the main matrix.

PS:Sorry for bad english :(",3
7693540,10/07/2011 22:41:45,538774,12/11/2010 09:44:00,1,0,Removing duplicates from an array in C/C++ in O(n) time,"Suppose i have an array like 
int array[] = {1,1,1,4,5,7,7,9,11};
I should be able to remove all the duplicates and hence my output should be {1,4,5,7,9,11}. 

Constraints:
I am not allowed to use any king of extra memory apart from variables 
I should be able to resize the array
I am not allowed to use containers like Hashset or set etc:
Should be done in o(n) time

Thanks in advance,",c,,,,,10/07/2011 23:06:35,too localized,1,65,10,"Removing duplicates from an array in C/C++ in O(n) time Suppose i have an array like 
int array[] = {1,1,1,4,5,7,7,9,11};
I should be able to remove all the duplicates and hence my output should be {1,4,5,7,9,11}. 

Constraints:
I am not allowed to use any king of extra memory apart from variables 
I should be able to resize the array
I am not allowed to use containers like Hashset or set etc:
Should be done in o(n) time

Thanks in advance,",1
6844339,07/27/2011 12:32:05,804790,06/18/2011 19:15:47,40,0,Function to create an window in GTK,"I created this code, but I think he is not working properly, rather, I'm afraid the code, I wonder if he's right:

    // forma de compilar:
    // gcc -c say.c `pkg-config --cflags --libs gtk+-2.0`
    // cobc -x -o hello hello.cob say.o `pkg-config --cflags --libs gtk+-2.0`

    #include <stdio.h>
    #include <gtk/gtk.h>

    static void settings_fnc(GtkWidget *widget, gpointer data)
    {
        printf(""Ola mundo, settings_fnc\n"");
    }

    static void new_dlg(char *title)
    {
        GtkWidget *window;
	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_widget_show(window);

	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));

	gtk_main();
    }

    GtkWidget *_window()
    {
	GtkWidget *teste;
	return teste;
    }

    static void teste_dlg(GtkWidget *window, char *title)
    {
	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_widget_show(window);
	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));
	gtk_main();
    }

    void gtk(char *title)
    {
	GtkWidget *window;
	GtkWidget *vbox;

	GtkWidget *settings;
	GtkWidget *accounts;
	GtkWidget *loans;
	GtkWidget *cash;
	GtkWidget *debts;

	GtkWidget teste = *_window();

	gtk_init(0, NULL);

	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
	gtk_window_set_default_size(GTK_WINDOW(window), 230, 250);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_container_set_border_width(GTK_CONTAINER(window), 5);

	vbox = gtk_vbox_new(TRUE, 1);
	gtk_container_add(GTK_CONTAINER(window), vbox);

	settings = gtk_button_new_with_label(""Settings"");
	accounts = gtk_button_new_with_label(""Accounts"");
	loans = gtk_button_new_with_label(""Loans"");
	cash = gtk_button_new_with_label(""Cash"");
	debts = gtk_button_new_with_label(""Debts"");

	gtk_box_pack_start(GTK_BOX(vbox), settings, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), accounts, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), loans, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), cash, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), debts, TRUE, TRUE, 0);

	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));

	g_signal_connect(settings, ""clicked"", G_CALLBACK(settings_fnc), NULL);
	g_signal_connect(accounts, ""clicked"", G_CALLBACK(new_dlg), NULL);
	g_signal_connect(loans, ""clicked"", G_CALLBACK(teste_dlg), NULL);

	gtk_widget_show_all(window);

	teste_dlg(&teste, ""teste"");
	
	gtk_main();	
    }

    int main(int argc, char *argv[])
    {
        gtk(""Ola"");
	return 0;
    }",c,gtk+,,,,07/27/2011 21:11:05,not a real question,1,260,7,"Function to create an window in GTK I created this code, but I think he is not working properly, rather, I'm afraid the code, I wonder if he's right:

    // forma de compilar:
    // gcc -c say.c `pkg-config --cflags --libs gtk+-2.0`
    // cobc -x -o hello hello.cob say.o `pkg-config --cflags --libs gtk+-2.0`

    #include <stdio.h>
    #include <gtk/gtk.h>

    static void settings_fnc(GtkWidget *widget, gpointer data)
    {
        printf(""Ola mundo, settings_fnc\n"");
    }

    static void new_dlg(char *title)
    {
        GtkWidget *window;
	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_widget_show(window);

	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));

	gtk_main();
    }

    GtkWidget *_window()
    {
	GtkWidget *teste;
	return teste;
    }

    static void teste_dlg(GtkWidget *window, char *title)
    {
	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_widget_show(window);
	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));
	gtk_main();
    }

    void gtk(char *title)
    {
	GtkWidget *window;
	GtkWidget *vbox;

	GtkWidget *settings;
	GtkWidget *accounts;
	GtkWidget *loans;
	GtkWidget *cash;
	GtkWidget *debts;

	GtkWidget teste = *_window();

	gtk_init(0, NULL);

	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
	gtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);
	gtk_window_set_default_size(GTK_WINDOW(window), 230, 250);
	gtk_window_set_title(GTK_WINDOW(window), title);
	gtk_container_set_border_width(GTK_CONTAINER(window), 5);

	vbox = gtk_vbox_new(TRUE, 1);
	gtk_container_add(GTK_CONTAINER(window), vbox);

	settings = gtk_button_new_with_label(""Settings"");
	accounts = gtk_button_new_with_label(""Accounts"");
	loans = gtk_button_new_with_label(""Loans"");
	cash = gtk_button_new_with_label(""Cash"");
	debts = gtk_button_new_with_label(""Debts"");

	gtk_box_pack_start(GTK_BOX(vbox), settings, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), accounts, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), loans, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), cash, TRUE, TRUE, 0);
	gtk_box_pack_start(GTK_BOX(vbox), debts, TRUE, TRUE, 0);

	g_signal_connect_swapped(G_OBJECT(window), ""destroy"",
		G_CALLBACK(gtk_main_quit), G_OBJECT(window));

	g_signal_connect(settings, ""clicked"", G_CALLBACK(settings_fnc), NULL);
	g_signal_connect(accounts, ""clicked"", G_CALLBACK(new_dlg), NULL);
	g_signal_connect(loans, ""clicked"", G_CALLBACK(teste_dlg), NULL);

	gtk_widget_show_all(window);

	teste_dlg(&teste, ""teste"");
	
	gtk_main();	
    }

    int main(int argc, char *argv[])
    {
        gtk(""Ola"");
	return 0;
    }",2
7514858,09/22/2011 12:40:51,249740,01/13/2010 11:15:57,143,17,Detecting the unplugging of a SATA/ACHI drive marked for safe removal,"I have used `CM_Request_Device_Eject()` to mark a SATA drive as ready for safe removal (i have ACHI enabled), and would like to detect (or be notified) when the drive has been physically disconnected. I had a look at `RegisterDeviceNotification()` but the `DBT_DEVICEREMOVECOMPLETE` messages i get as a result of that are for logical removal rather than physical. 

I know how to trigger a bus rescan which makes Windows realise the drive is gone and makes it ready for a reinsertion, but i still need to know about the physical removal before i call this. Windows also seems to have subtle differences in how it treats USB and ACHI devices.",c,winapi,,,,,open,0,109,11,"Detecting the unplugging of a SATA/ACHI drive marked for safe removal I have used `CM_Request_Device_Eject()` to mark a SATA drive as ready for safe removal (i have ACHI enabled), and would like to detect (or be notified) when the drive has been physically disconnected. I had a look at `RegisterDeviceNotification()` but the `DBT_DEVICEREMOVECOMPLETE` messages i get as a result of that are for logical removal rather than physical. 

I know how to trigger a bus rescan which makes Windows realise the drive is gone and makes it ready for a reinsertion, but i still need to know about the physical removal before i call this. Windows also seems to have subtle differences in how it treats USB and ACHI devices.",2
10575208,05/13/2012 20:59:53,772249,05/27/2011 00:01:47,154,1,Understanding multi-core SMP systems,"I'm trying to understand how does **multi-core** systems work and how to program efficient programs for systems with **many cores**. I know this is very hard topic but i'm very interested in fastest solutions possible.

First of all, i'm trying to understand how does threading work. It's obvious, that in most cases multithreading can increase the performance dramatically. According to [this][1] page, this is how multithreading work:

![enter image description here][2]

But why is switching between **N** threads is faster than just running **N** threads one by one ? How can threading work on system with only one CPU ?

Next, what is the **point or multi-core programming**? I assume that the point is to split threads between cores and split tasks between them ? But how can i split 8 threads on 4 CPU's system equally ?

Do i have to use [processor affinity][3] (cpu_affinity) to split **threads/processes** between CPU's ? Can i create 4 threads using **pthread_create** on system with 4 CPU's to run each thread on each CPU ?

How [hyper-threading][4] helps and is it helps at all ? How can we use **CPU cache** programming for multi-core systems ?

I'm interested in theory of this problem and also in practical solutions/examples/projects/books/articles for **Linux** systems (using C). 

I know this is increasingly important topic and I hopes I'm not only one interested.

  [1]: http://en.wikipedia.org/wiki/Thread_%28computing%29
  [2]: http://i.stack.imgur.com/pZpdg.png
  [3]: http://en.wikipedia.org/wiki/Processor_affinity
  [4]: http://en.wikipedia.org/wiki/Hyper-threading",c,linux,multithreading,multicore,,05/14/2012 16:40:26,off topic,1,230,4,"Understanding multi-core SMP systems I'm trying to understand how does **multi-core** systems work and how to program efficient programs for systems with **many cores**. I know this is very hard topic but i'm very interested in fastest solutions possible.

First of all, i'm trying to understand how does threading work. It's obvious, that in most cases multithreading can increase the performance dramatically. According to [this][1] page, this is how multithreading work:

![enter image description here][2]

But why is switching between **N** threads is faster than just running **N** threads one by one ? How can threading work on system with only one CPU ?

Next, what is the **point or multi-core programming**? I assume that the point is to split threads between cores and split tasks between them ? But how can i split 8 threads on 4 CPU's system equally ?

Do i have to use [processor affinity][3] (cpu_affinity) to split **threads/processes** between CPU's ? Can i create 4 threads using **pthread_create** on system with 4 CPU's to run each thread on each CPU ?

How [hyper-threading][4] helps and is it helps at all ? How can we use **CPU cache** programming for multi-core systems ?

I'm interested in theory of this problem and also in practical solutions/examples/projects/books/articles for **Linux** systems (using C). 

I know this is increasingly important topic and I hopes I'm not only one interested.

  [1]: http://en.wikipedia.org/wiki/Thread_%28computing%29
  [2]: http://i.stack.imgur.com/pZpdg.png
  [3]: http://en.wikipedia.org/wiki/Processor_affinity
  [4]: http://en.wikipedia.org/wiki/Hyper-threading",4
3179203,07/05/2010 11:46:48,383627,07/05/2010 11:46:48,1,0,To set C language Direcories path,please help me to set directories path of C language compiler,c,,,,,07/05/2010 21:52:41,not a real question,1,11,6,To set C language Direcories path please help me to set directories path of C language compiler,1
6382205,06/17/2011 06:38:44,802787,06/17/2011 06:38:44,1,0,SD CARD interfacing with lpc2929,"I am trying to interface SD CARD with lpc2929,it performs well at initial stage ,but after sending data via spi for writing,it does not return 0x05,instead it returns  oxFF",c,,,,,06/18/2011 01:13:40,not a real question,1,30,5,"SD CARD interfacing with lpc2929 I am trying to interface SD CARD with lpc2929,it performs well at initial stage ,but after sending data via spi for writing,it does not return 0x05,instead it returns  oxFF",1
3227030,07/12/2010 08:57:03,387611,07/09/2010 10:19:00,44,0,what is the ascii value of \n?," i want to ascii value of '\n',",c,,,,,07/12/2010 16:07:47,not a real question,1,8,7,"what is the ascii value of \n?  i want to ascii value of '\n',",1
7446489,09/16/2011 14:50:16,265804,02/04/2010 00:45:48,9859,294,Casting a pointer does not produce an lvalue. Why?,"After posting one of my most controversial answers [here][1], I dare to ask a few questions and eventually fill some gaps in my knowledge.

Why isn't an expression of the kind `((type_t *) x)` considered a valid lvalue, assuming that `x` itself is a pointer and an lvalue, not just some expression?

I know many will say ""the standard disallows it"", but from a logical standpoint it seems reasonable. What is the reason that the standard disallows it? After all, any two pointers are of the same size and the pointer type is just a compile-time abstraction that indicates the appropriate offset that should be applied when doing pointer arithmetic.

  [1]: http://stackoverflow.com/questions/7444464/read-bytes-methods-in-c-c/7444502#7444502",c,pointers,casting,lvalue,,,open,0,111,9,"Casting a pointer does not produce an lvalue. Why? After posting one of my most controversial answers [here][1], I dare to ask a few questions and eventually fill some gaps in my knowledge.

Why isn't an expression of the kind `((type_t *) x)` considered a valid lvalue, assuming that `x` itself is a pointer and an lvalue, not just some expression?

I know many will say ""the standard disallows it"", but from a logical standpoint it seems reasonable. What is the reason that the standard disallows it? After all, any two pointers are of the same size and the pointer type is just a compile-time abstraction that indicates the appropriate offset that should be applied when doing pointer arithmetic.

  [1]: http://stackoverflow.com/questions/7444464/read-bytes-methods-in-c-c/7444502#7444502",4
11554167,07/19/2012 04:55:50,1179653,01/31/2012 06:21:29,44,13,ipv6 router advertisement issue,"As per RFC, curhoplimit of router advertisement(ra) should be kept as hoplimit for the routing table entry. It expects that the hoplimit of a routing path should not affected if a ra comes for the path with curhoplimit is 0. But in the case of kernel-3.0.26, the value is altered to 255. But it happens only in the router cache(#ip -6 route show cached) not in the main routing table (#ip -6 route show). But if I disable 'multiple routing table' option while building the kernel, it also affects the main routing table.

Timer expiry for a routing table entry. I am facing this scenario. I have the gc_interval value 30 seconds. I am receinving a ra with preferred lifetime 20 seconds. So the routing table entry expirs and removed from the routing table in 20 seconds. But the cache remains with the expired routing entry till next flush.

As per my knowledge MTU value is not stored in the routing table. I can see the the MTU value in routing cache but not in the main routing table. So in my case, once the routing cahce is flushed, the kernel not properly fragments the packet according to the MTU value even the timer doesn't expire. I don't know am I right or wrong. I will tell what is happening. I have a router connected with a target board. The router sends a ra with mtu 1200 and sends a ICMP_REQUEST with length 1500. And it expects the target board to send ICMP_REPLY as fragmented into two packets (1200 and 300). But the target board does correctly if the cache is present. But once the cache is flushed, it fails.

Note: I am using Kernel-3.0.26 for arm architecture.

Thank you,",c,network-programming,linux-kernel,ipv6,kernel-programming,07/20/2012 01:04:22,off topic,1,286,4,"ipv6 router advertisement issue As per RFC, curhoplimit of router advertisement(ra) should be kept as hoplimit for the routing table entry. It expects that the hoplimit of a routing path should not affected if a ra comes for the path with curhoplimit is 0. But in the case of kernel-3.0.26, the value is altered to 255. But it happens only in the router cache(#ip -6 route show cached) not in the main routing table (#ip -6 route show). But if I disable 'multiple routing table' option while building the kernel, it also affects the main routing table.

Timer expiry for a routing table entry. I am facing this scenario. I have the gc_interval value 30 seconds. I am receinving a ra with preferred lifetime 20 seconds. So the routing table entry expirs and removed from the routing table in 20 seconds. But the cache remains with the expired routing entry till next flush.

As per my knowledge MTU value is not stored in the routing table. I can see the the MTU value in routing cache but not in the main routing table. So in my case, once the routing cahce is flushed, the kernel not properly fragments the packet according to the MTU value even the timer doesn't expire. I don't know am I right or wrong. I will tell what is happening. I have a router connected with a target board. The router sends a ra with mtu 1200 and sends a ICMP_REQUEST with length 1500. And it expects the target board to send ICMP_REPLY as fragmented into two packets (1200 and 300). But the target board does correctly if the cache is present. But once the cache is flushed, it fails.

Note: I am using Kernel-3.0.26 for arm architecture.

Thank you,",5
2029428,01/08/2010 17:35:41,133466,07/05/2009 23:02:59,418,1,Dictionary Matching / Spell Check Program ,"Please help me with a spellcheck program in C. The majority of the coding are complete (I think...). I'm really stuck because I'm not sure why the program wouldn't compile. Admittedly, I'm still an amateur coder, would you also provide a few suggestions on some of the bad coding habits that I have in the code? Thank you!

What's required...
There is only one stage on this project, writing the spellCheck routine. The spellCheck function has two parameters. The first parameter (article[]) is a pointer to an array of characters. The contents of this array are an article that you need to spell check. The end of the article is marked with the normal 0 (marking the end of a string). The article includes punctuation, upper and lower case words, numbers, and abbreviations. Your function must print every word in the article that cannot be found in the dictionary. The dictionary is the second parameter to the function (more on this later).

    #include <stdio.h>
    #include<string.h>
    
    char dictionary[1000000];
    char article[100000];
    
    void spellCheck(char[], char[]);
    
    int main(void) {
    	FILE* dict_file;
    	FILE* article_file;
    	int bytes_read;
    	char* p;
    
    	dict_file = fopen(""american-english.txt"", ""r"");
    	if (dict_file == 0) {
    		printf(""unable to open dictionary file \""american-english.txt\""\n"");
    		return -1;
    	}
    	
    	article_file = fopen(""article.txt"", ""r"");
    	if (article_file == 0) {
    		printf(""unable to open file \""article.txt\""\n"");
    		return -1;
    	}
    
    	/* read dictionary */
    	p = dictionary;
    	p = fgets(p, 100, dict_file);
    	while (p != 0) {
    		while (*p != '\0') { 
    			p += 1; 
    		}
    		p = fgets(p, 100, dict_file);
    	}
    	
    	/* read article */
    	p = article;
    	bytes_read = fread(p, 1, 1000, article_file);
    	p += bytes_read;
    	while (bytes_read != 0) {
    		bytes_read = fread(p, 1, 1000, article_file);
    		p += bytes_read;
    	}
    	*p = 0;
    
    	spellCheck(article, dictionary);
    }	
    
    
    
    int articlePosition =0;
    int dictionaryPosition = 0;
    
    int isLetter(char c);
    void removePunc(char article[]);
    void toLower( char article[]);
    void lowerDictionary( char dictionary[]);
    int artLength( char article[]);
    void nextArticleWord(char article[], char articleWord[],  int artLength, char dictionary[]);
    
    
    void spellCheck(char article[], char dictionary[]) {
    	char articleWord[50]; 
    	char dictionaryWord[50];
    	int articleLength = artLength(article);
    	removePunc(article);
    	toLower(article);
    	lowerDictionary(dictionary);
    	nextArticleWord(article, articleWord, articleLength, dictionary);
    	
    }
    
    void nextDictionaryWord(char dictionary[], char dictionaryWord[]){
    	int i;
    	for(i =0; dictionary[dictionaryPosition] != '\n'; i++){
    		dictionaryWord[i] = dictionary[dictionaryPosition];
    		dictionaryPosition++;
    	}
    }
    int isLetter(char c){
    	if ( (c>='a'&&c<='z') || (c>='A'&&c<='Z'))
    		return 1;
    	return 0;
    }
    
    void removePunc(char article[]){
    	int i, j=0;
    	for ( i =0; article[i] != 0; i++){
    		if (isLetter(article[i])){
    			article[j] = article[i];
    			j++;
    		}
    		else if (!isLetter(article[i])){
    			article[j] = ' ';
    			j++;
    		}		
    	}
    }
    
    void toLower( char article[]){
    	int i=0;
    	for( i; article[i] != 0; i++){
    		if ( article[i] >= 'A' && article[i] <='Z')
    			article[i] = article[i] + 32;
    	}
    }
    
    void lowerDictionary( char dictionary[]){
    	int i=0;
    	for(i; dictionary[i] != 0; i++){
    		if (dictionary[i] >= 'A' && dictionary[i] <= 'Z'){
    			dictionary[i] = dictionary[i] + 32;
    		}
    	}
    }
    
    
    int articleLength( char article[] ){
    	int count=0;
    	while (article[count] != 0)
    		count++;
    	return count;
    }
    
    void nextArticleWord(char article[], char articleWord[],  int articleLength, char dictionaryWord[], char dictionary[]){
    	int j, i;
    check:
    	while(!isLetter(article[articlePosition])){
    		if (article[articlePosition] == 0){
    			return;
    		}
    		articlePosition++;
    	}
    	for(j=0; article[articlePosition] != ' ' || articlePosition == articleLength; j++){
    		articleWord[j] = article[articlePosition];
    		articlePosition++;
    	}	
    
    	if (strlen(articleWord)<2){
    		goto check;
    	}
    	articleWord[j+1] = 0;
    	//dictionary search
    		while (!strncmp(articleWord, dictionaryWord,strlen(articleWord))){
    			nextDictionaryWord(dictionary, dictionaryWord);
    		}
    		if(strncmp(articleWord, dictionaryWord,strlen(articleWord)))
    			return;
    		printf(articleWord);
    }


",c,homework,,,,,open,0,1015,7,"Dictionary Matching / Spell Check Program  Please help me with a spellcheck program in C. The majority of the coding are complete (I think...). I'm really stuck because I'm not sure why the program wouldn't compile. Admittedly, I'm still an amateur coder, would you also provide a few suggestions on some of the bad coding habits that I have in the code? Thank you!

What's required...
There is only one stage on this project, writing the spellCheck routine. The spellCheck function has two parameters. The first parameter (article[]) is a pointer to an array of characters. The contents of this array are an article that you need to spell check. The end of the article is marked with the normal 0 (marking the end of a string). The article includes punctuation, upper and lower case words, numbers, and abbreviations. Your function must print every word in the article that cannot be found in the dictionary. The dictionary is the second parameter to the function (more on this later).

    #include <stdio.h>
    #include<string.h>
    
    char dictionary[1000000];
    char article[100000];
    
    void spellCheck(char[], char[]);
    
    int main(void) {
    	FILE* dict_file;
    	FILE* article_file;
    	int bytes_read;
    	char* p;
    
    	dict_file = fopen(""american-english.txt"", ""r"");
    	if (dict_file == 0) {
    		printf(""unable to open dictionary file \""american-english.txt\""\n"");
    		return -1;
    	}
    	
    	article_file = fopen(""article.txt"", ""r"");
    	if (article_file == 0) {
    		printf(""unable to open file \""article.txt\""\n"");
    		return -1;
    	}
    
    	/* read dictionary */
    	p = dictionary;
    	p = fgets(p, 100, dict_file);
    	while (p != 0) {
    		while (*p != '\0') { 
    			p += 1; 
    		}
    		p = fgets(p, 100, dict_file);
    	}
    	
    	/* read article */
    	p = article;
    	bytes_read = fread(p, 1, 1000, article_file);
    	p += bytes_read;
    	while (bytes_read != 0) {
    		bytes_read = fread(p, 1, 1000, article_file);
    		p += bytes_read;
    	}
    	*p = 0;
    
    	spellCheck(article, dictionary);
    }	
    
    
    
    int articlePosition =0;
    int dictionaryPosition = 0;
    
    int isLetter(char c);
    void removePunc(char article[]);
    void toLower( char article[]);
    void lowerDictionary( char dictionary[]);
    int artLength( char article[]);
    void nextArticleWord(char article[], char articleWord[],  int artLength, char dictionary[]);
    
    
    void spellCheck(char article[], char dictionary[]) {
    	char articleWord[50]; 
    	char dictionaryWord[50];
    	int articleLength = artLength(article);
    	removePunc(article);
    	toLower(article);
    	lowerDictionary(dictionary);
    	nextArticleWord(article, articleWord, articleLength, dictionary);
    	
    }
    
    void nextDictionaryWord(char dictionary[], char dictionaryWord[]){
    	int i;
    	for(i =0; dictionary[dictionaryPosition] != '\n'; i++){
    		dictionaryWord[i] = dictionary[dictionaryPosition];
    		dictionaryPosition++;
    	}
    }
    int isLetter(char c){
    	if ( (c>='a'&&c<='z') || (c>='A'&&c<='Z'))
    		return 1;
    	return 0;
    }
    
    void removePunc(char article[]){
    	int i, j=0;
    	for ( i =0; article[i] != 0; i++){
    		if (isLetter(article[i])){
    			article[j] = article[i];
    			j++;
    		}
    		else if (!isLetter(article[i])){
    			article[j] = ' ';
    			j++;
    		}		
    	}
    }
    
    void toLower( char article[]){
    	int i=0;
    	for( i; article[i] != 0; i++){
    		if ( article[i] >= 'A' && article[i] <='Z')
    			article[i] = article[i] + 32;
    	}
    }
    
    void lowerDictionary( char dictionary[]){
    	int i=0;
    	for(i; dictionary[i] != 0; i++){
    		if (dictionary[i] >= 'A' && dictionary[i] <= 'Z'){
    			dictionary[i] = dictionary[i] + 32;
    		}
    	}
    }
    
    
    int articleLength( char article[] ){
    	int count=0;
    	while (article[count] != 0)
    		count++;
    	return count;
    }
    
    void nextArticleWord(char article[], char articleWord[],  int articleLength, char dictionaryWord[], char dictionary[]){
    	int j, i;
    check:
    	while(!isLetter(article[articlePosition])){
    		if (article[articlePosition] == 0){
    			return;
    		}
    		articlePosition++;
    	}
    	for(j=0; article[articlePosition] != ' ' || articlePosition == articleLength; j++){
    		articleWord[j] = article[articlePosition];
    		articlePosition++;
    	}	
    
    	if (strlen(articleWord)<2){
    		goto check;
    	}
    	articleWord[j+1] = 0;
    	//dictionary search
    		while (!strncmp(articleWord, dictionaryWord,strlen(articleWord))){
    			nextDictionaryWord(dictionary, dictionaryWord);
    		}
    		if(strncmp(articleWord, dictionaryWord,strlen(articleWord)))
    			return;
    		printf(articleWord);
    }


",2
8961340,01/22/2012 13:16:23,962891,09/24/2011 18:10:11,723,2,BLAS and LAPACK libraries required for compiling,"I recently downloaded the latest stable release of Gnu Octave, and was attempting to build and install it on my machine (Ubuntu 10.0.4 LTS 64bit).

When I run ./configure, I got this error message:

    configure: error: You are required to have BLAS and LAPACK libraries

Does anyone know Where do I obtain these libraries from?",c,ubuntu,octave,autotools,configure,,open,0,56,7,"BLAS and LAPACK libraries required for compiling I recently downloaded the latest stable release of Gnu Octave, and was attempting to build and install it on my machine (Ubuntu 10.0.4 LTS 64bit).

When I run ./configure, I got this error message:

    configure: error: You are required to have BLAS and LAPACK libraries

Does anyone know Where do I obtain these libraries from?",5
9659662,03/11/2012 22:46:02,752920,05/13/2011 19:21:59,424,14,How to use autotools for deep projects?,"I have a **C** project that has the following structure

    Main/
      Makefile.am
      bin/
      src/
         Makefile.am
         main.c
         SomeLibrarySource/
             SomeFuncs.c
             SomeFuncs.h


The **main.c** contains the main function that uses functions defined in the **SomeFuncs.{h/c}** files.

I want to use autotools for this project. I read a couple of resources on autotools. But, I was only able to manage using `autotools` for a single level project where all source, object and other files reside in the same directory.

Then I got some links that talked about using autotools for deep projects like this one and then I got confused.

Right now I have two Makefile.am as follows

**Makefile.am**

    SUBDIRS=src

**src/Makefile.am**

    mainprgdir=../
    mainprg_PROGRAMS=main
    main_SOURCES=main.c

I am pretty sure that these files should not be as I have them now **:P**

How do I use **autotools** for the above project structure? (At least what should be there in those **`Makefile.am`**(s) and where should I place them.

Thanks",c,autotools,,,,,open,0,221,7,"How to use autotools for deep projects? I have a **C** project that has the following structure

    Main/
      Makefile.am
      bin/
      src/
         Makefile.am
         main.c
         SomeLibrarySource/
             SomeFuncs.c
             SomeFuncs.h


The **main.c** contains the main function that uses functions defined in the **SomeFuncs.{h/c}** files.

I want to use autotools for this project. I read a couple of resources on autotools. But, I was only able to manage using `autotools` for a single level project where all source, object and other files reside in the same directory.

Then I got some links that talked about using autotools for deep projects like this one and then I got confused.

Right now I have two Makefile.am as follows

**Makefile.am**

    SUBDIRS=src

**src/Makefile.am**

    mainprgdir=../
    mainprg_PROGRAMS=main
    main_SOURCES=main.c

I am pretty sure that these files should not be as I have them now **:P**

How do I use **autotools** for the above project structure? (At least what should be there in those **`Makefile.am`**(s) and where should I place them.

Thanks",2
5509029,04/01/2011 04:05:30,683104,03/30/2011 01:14:24,38,0,Major defects of C,What are the major defects of the C Language.?,c,language-agnostic,,,,04/01/2011 04:11:17,not constructive,1,9,4,Major defects of C What are the major defects of the C Language.?,2
9155875,02/06/2012 05:20:21,635612,02/26/2011 15:05:08,7,0,Error in Search a Pattern in a Text in C (String Matching),"I want to search a pattern (max length 100 characters) in a text (max size 300MB). I have used fread to read the pattern and the text files and store them in two arrays (pattern[100],text[1000000000]). Sometimes, the process of searching returns wrong results. After debugging, I found the elements of the pattern are not correct (includes garbage). This problem happens in some cases and I cannot fine what the reasons are? During the program, I don't change the elements of the pattern. It will be graet if anyone can help me to solve this problem.",c,string,,,,02/07/2012 16:31:21,not a real question,1,95,12,"Error in Search a Pattern in a Text in C (String Matching) I want to search a pattern (max length 100 characters) in a text (max size 300MB). I have used fread to read the pattern and the text files and store them in two arrays (pattern[100],text[1000000000]). Sometimes, the process of searching returns wrong results. After debugging, I found the elements of the pattern are not correct (includes garbage). This problem happens in some cases and I cannot fine what the reasons are? During the program, I don't change the elements of the pattern. It will be graet if anyone can help me to solve this problem.",2
9893412,03/27/2012 16:09:03,1089679,12/09/2011 12:08:53,371,2,How can i do UDP Socket Programming in C,"Here i want to do UDP Socket programming in C.

I have one device i want to send some message on my device from host machine. so i want to make this thing via UDP socket Programming.

So Can Any body suggest me the way how can i achieve this goal.

I want to do UDP socket programming.(Client and Server and send Message to device using this).

thanks

",c,sockets,udp,,,03/27/2012 20:05:53,not a real question,1,64,9,"How can i do UDP Socket Programming in C Here i want to do UDP Socket programming in C.

I have one device i want to send some message on my device from host machine. so i want to make this thing via UDP socket Programming.

So Can Any body suggest me the way how can i achieve this goal.

I want to do UDP socket programming.(Client and Server and send Message to device using this).

thanks

",3
6812242,07/25/2011 05:55:45,391986,06/08/2010 20:52:42,567,3,defining and iterating through array of strings in c,"How can I define an array of string in c then iterate with a loop through the items in the array?

So far I have

    char myStrings[][10] = { ""one"", ""two"", ""three"", ""four"", ""five"" };
    // do I need to specify the ""10"" maximum length?
    // also does it automatically create a null ending character after the string?

    int i = 0;
    for( i = 0; i < ; i++)
    {
    // I need to pass each string to  a function which accepts
    // const char *
    }

",c,,,,,,open,0,115,9,"defining and iterating through array of strings in c How can I define an array of string in c then iterate with a loop through the items in the array?

So far I have

    char myStrings[][10] = { ""one"", ""two"", ""three"", ""four"", ""five"" };
    // do I need to specify the ""10"" maximum length?
    // also does it automatically create a null ending character after the string?

    int i = 0;
    for( i = 0; i < ; i++)
    {
    // I need to pass each string to  a function which accepts
    // const char *
    }

",1
7229786,08/29/2011 12:02:39,917767,08/29/2011 12:02:39,1,0,Reverse the place of the string in C,"I want reverse the string in particular format- My name is Nishant
output- Nishant is name My",c,,,,,08/29/2011 12:11:13,not a real question,1,16,8,"Reverse the place of the string in C I want reverse the string in particular format- My name is Nishant
output- Nishant is name My",1
2986750,06/07/2010 02:19:16,359998,06/07/2010 02:19:16,1,0,space complexity,how can i get the space taken by a pointer at run time,c,,,,,10/07/2011 07:40:31,not a real question,1,13,2,space complexity how can i get the space taken by a pointer at run time,1
3547262,08/23/2010 11:58:36,411563,08/05/2010 05:26:31,16,1,How to generate 8 byte hex value??,"> Blockquote

Hi

   I want to generate this sequential data in C

 data_packet[1]=0706050403020100(seed_value)
next
 data_packet[2]=0f0e0d0c0b0a0908

next will be the next 8 hexadecimal characters and so on for say 100 bytes.How can i do it.Can we do it using character array ??",c,,,,,08/24/2010 01:22:23,not a real question,1,40,7,"How to generate 8 byte hex value?? > Blockquote

Hi

   I want to generate this sequential data in C

 data_packet[1]=0706050403020100(seed_value)
next
 data_packet[2]=0f0e0d0c0b0a0908

next will be the next 8 hexadecimal characters and so on for say 100 bytes.How can i do it.Can we do it using character array ??",1
6160392,05/28/2011 07:49:55,774136,05/28/2011 07:49:55,1,0,how to present the best/worst case of binary search in formula?,how to state the number of comparisons in form of formula of the best/worst case of binary search? Assume that the value k always exists in the given data structures,c,homework,binary-search,,,05/28/2011 09:58:06,off topic,1,30,11,how to present the best/worst case of binary search in formula? how to state the number of comparisons in form of formula of the best/worst case of binary search? Assume that the value k always exists in the given data structures,3
6672681,07/13/2011 00:03:47,784044,06/04/2011 15:19:03,1,0,"I am new to C and I am trying to learn to use structs, my unix app won't run and says EXC_BAD_ACCES. HElP!!!","Here's the code:

    #include <stdio.h>

int main (int argc, const char * argv[]) {
	int num;
    struct contact;
	
	struct contact {
		double foneNumber;
		char firstName;
		char lastName;
		};
	typedef struct contact cntct;
	
	cntct bob;
	
	bob.foneNumber = 15555555555;
	bob.firstName = ""bob"";
	bob.lastName = ""builder"";
	
	
	cntct fudge;
	
	fudge.foneNumber = 15444444444;
	fudge.firstName = ""fudge"";
	fudge.lastName = ""cornelius"";
	
	cntct Siddhartha;
	
	
	Siddhartha.foneNumber = 15333333333;
	Siddhartha.firstName = ""Siddhartha"";
	Siddhartha.lastName = ""Gautama"";
	
	while (1) {
	printf(""Would you like to see contact 1, 2, or 3 (0 to quit)?"");
		scanf(""%d"", &num);
		switch (num)
		{
			case 1:
				printf(""Phone Number:  %lg"", bob.foneNumber);
				printf(""\nFirst Name:  %s"", bob.firstName);
				printf(""\nLast Name:  %s"", bob.lastName);
				break;
			case 2:
				printf(""Phone Number:  %lg"", fudge.foneNumber);
				printf(""\nFirst Name:  %s"", fudge.firstName);
				printf(""\nLast Name:  %s"", fudge.lastName);
				break;
			case 3:
				printf(""Phone Number:  %lg"", Siddhartha.foneNumber);
				printf(""\nFirst Name:  %s"", Siddhartha.firstName);
				printf(""\nLast Name:  %s"", Siddhartha.lastName);
				break;
			case 0:
				return 0;
				break;
			default:
				printf(""huh?"");
				return 0;
		}
				


	}
}


",c,xcode,struct,typedef,exc-bad-access,07/13/2011 00:07:06,not a real question,1,109,23,"I am new to C and I am trying to learn to use structs, my unix app won't run and says EXC_BAD_ACCES. HElP!!! Here's the code:

    #include <stdio.h>

int main (int argc, const char * argv[]) {
	int num;
    struct contact;
	
	struct contact {
		double foneNumber;
		char firstName;
		char lastName;
		};
	typedef struct contact cntct;
	
	cntct bob;
	
	bob.foneNumber = 15555555555;
	bob.firstName = ""bob"";
	bob.lastName = ""builder"";
	
	
	cntct fudge;
	
	fudge.foneNumber = 15444444444;
	fudge.firstName = ""fudge"";
	fudge.lastName = ""cornelius"";
	
	cntct Siddhartha;
	
	
	Siddhartha.foneNumber = 15333333333;
	Siddhartha.firstName = ""Siddhartha"";
	Siddhartha.lastName = ""Gautama"";
	
	while (1) {
	printf(""Would you like to see contact 1, 2, or 3 (0 to quit)?"");
		scanf(""%d"", &num);
		switch (num)
		{
			case 1:
				printf(""Phone Number:  %lg"", bob.foneNumber);
				printf(""\nFirst Name:  %s"", bob.firstName);
				printf(""\nLast Name:  %s"", bob.lastName);
				break;
			case 2:
				printf(""Phone Number:  %lg"", fudge.foneNumber);
				printf(""\nFirst Name:  %s"", fudge.firstName);
				printf(""\nLast Name:  %s"", fudge.lastName);
				break;
			case 3:
				printf(""Phone Number:  %lg"", Siddhartha.foneNumber);
				printf(""\nFirst Name:  %s"", Siddhartha.firstName);
				printf(""\nLast Name:  %s"", Siddhartha.lastName);
				break;
			case 0:
				return 0;
				break;
			default:
				printf(""huh?"");
				return 0;
		}
				


	}
}


",5
9619634,03/08/2012 14:58:02,1209188,02/14/2012 13:38:05,5,0,How to make a C program interact with web browser?,"Objective is to create a windows program in C which can send strings of data to browser and vice versa. I know it can be done with Websocket but I am not able to find any example code for a simple websocket server written in C. 

Can anyone tell me how to write a simple web socket server program in C ? When I say simple, I mean, there is no need for concurrency or anything. And the Client will be browser which will connect to the server using javascript.

Is there is any way other than Websockets to achieve this objective ? There are lots of other things for duplex communication with browser but none are in C or for windows.

If you can point me to any tutorial related to my objective, that would be great. (I have gone thru almost every tutorial google offered. All were in C++ (with complex concurrency) or in other languages like PHP, Js, etc.) .. 

If there is a way to use js or php or ruby websocket or Socket.Io code inside C program, please let me know.

Thankyou",c,windows,browser,websocket,,03/09/2012 01:42:16,not a real question,1,184,10,"How to make a C program interact with web browser? Objective is to create a windows program in C which can send strings of data to browser and vice versa. I know it can be done with Websocket but I am not able to find any example code for a simple websocket server written in C. 

Can anyone tell me how to write a simple web socket server program in C ? When I say simple, I mean, there is no need for concurrency or anything. And the Client will be browser which will connect to the server using javascript.

Is there is any way other than Websockets to achieve this objective ? There are lots of other things for duplex communication with browser but none are in C or for windows.

If you can point me to any tutorial related to my objective, that would be great. (I have gone thru almost every tutorial google offered. All were in C++ (with complex concurrency) or in other languages like PHP, Js, etc.) .. 

If there is a way to use js or php or ruby websocket or Socket.Io code inside C program, please let me know.

Thankyou",4
4979455,02/12/2011 17:26:35,420878,08/15/2010 09:22:18,5,1,find number of leaf nodes in a binary tree having depth D using array implementation,"c code to find the number of leaf nodes in a tree with depth d.
hit is to use array iplementation of binry tree",c,data-structures,data,,,04/08/2011 02:10:27,not a real question,1,23,15,"find number of leaf nodes in a binary tree having depth D using array implementation c code to find the number of leaf nodes in a tree with depth d.
hit is to use array iplementation of binry tree",3
6627153,07/08/2011 16:00:44,793384,06/10/2011 20:56:36,1,0,how to make this program reading the values properly,"        //======================================================
    //this is the grading sorting program for part one
    //======================================================
     
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
     
    #define SIZE 10
     
    int main()
    {
    FILE *ifp; // file pointer, points to the file
    char filename[32]; // store file name
     
    int ID [SIZE],grade[SIZE];
     
    int i;
     
    int sum_grades = 0;
     
    //opening file by asking the user for the file name
     
    /*
      *printf(""Enter the name of the file containing the grades\n"");
    *scanf(""%s"",filename);
    *printf(""%s"", filename);
      */
     
    ifp = fopen(""grades.txt"", ""r"");
     
    //========================================
    // checkes to see if the file is valid
    //========================================
    if (ifp == NULL)
    {
    printf(""unable to locate file... FILE NOT FOUND\n"");
    }
     
    //=============================================================
    //read in data into the arrays
    //this prints out the grades the way they appear in the program
    //=============================================================
     
    printf(""=====================\n"");
    printf(""ID Grade\n"");
    printf(""=====================\n"");
    for(i = 0; i < SIZE; i++)
    {
    fscanf(ifp,""%d"", &ID[i]);
    fscanf(ifp,""%d"", &grade[i]);
     
    printf(""%d %d\n"", ID[i], grade[i]);
     
    if(ID[i]==0 && grade[i]==0)
    {
    break;
    }
    }
     
    //===============================================================
    //finding the highest grade and the corresponding ID in the class
    //===============================================================
    int highest = grade[0];
     
    for(i = 1; i< SIZE; i++)
    {
    if(grade[i]>highest)
    {
    highest = grade[i];
    }
    }
     
    printf(""Top grade: %d by student with ID 3050\n"", highest);
     
     
    //================================================================
    // calculating the mean grade
    //================================================================
    int mean = grade[0];
    for( i = 0; i < SIZE; i++)
    {
    if(ID[i]==0 && grade[i]==0)
    sum_grades += grade[i];
    }
    printf(""sum is %d\n"", sum_grades);
     
    fclose(ifp);
    return 0;
    }


its a program designed to print out the student's ID's and grades as they appear in the file, print the highest grade, the mean value and print the student's ID's in increasing order

INPUT FILE
------------
3050 76
2030 60
1600 70
2222 50
2430 60
2800 50
0 0
Ball Adam 70
Arnold Joshua 67
Scot Michael 80
Cook Bret 55
Davis Ronald 62
Fox Brian 87
Singh Jaadu 91
Hudson Jeff 45
xxx xxx 0
Fox Brian
Jessi Mala
-------------------
1st part of the program its supposed to stop at the value (""0 0""). so it should print
3050 76
2030 60
1600 70
2222 50
2430 60
2800 50
but (""0 0"") is being included, which affects my mean value as well. also how how do u implement the sorting algorithm for printing the ID's in increasing order which correspond to the grades

help would be appreciated ",c,,,,,11/15/2011 11:06:26,too localized,1,660,9,"how to make this program reading the values properly         //======================================================
    //this is the grading sorting program for part one
    //======================================================
     
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
     
    #define SIZE 10
     
    int main()
    {
    FILE *ifp; // file pointer, points to the file
    char filename[32]; // store file name
     
    int ID [SIZE],grade[SIZE];
     
    int i;
     
    int sum_grades = 0;
     
    //opening file by asking the user for the file name
     
    /*
      *printf(""Enter the name of the file containing the grades\n"");
    *scanf(""%s"",filename);
    *printf(""%s"", filename);
      */
     
    ifp = fopen(""grades.txt"", ""r"");
     
    //========================================
    // checkes to see if the file is valid
    //========================================
    if (ifp == NULL)
    {
    printf(""unable to locate file... FILE NOT FOUND\n"");
    }
     
    //=============================================================
    //read in data into the arrays
    //this prints out the grades the way they appear in the program
    //=============================================================
     
    printf(""=====================\n"");
    printf(""ID Grade\n"");
    printf(""=====================\n"");
    for(i = 0; i < SIZE; i++)
    {
    fscanf(ifp,""%d"", &ID[i]);
    fscanf(ifp,""%d"", &grade[i]);
     
    printf(""%d %d\n"", ID[i], grade[i]);
     
    if(ID[i]==0 && grade[i]==0)
    {
    break;
    }
    }
     
    //===============================================================
    //finding the highest grade and the corresponding ID in the class
    //===============================================================
    int highest = grade[0];
     
    for(i = 1; i< SIZE; i++)
    {
    if(grade[i]>highest)
    {
    highest = grade[i];
    }
    }
     
    printf(""Top grade: %d by student with ID 3050\n"", highest);
     
     
    //================================================================
    // calculating the mean grade
    //================================================================
    int mean = grade[0];
    for( i = 0; i < SIZE; i++)
    {
    if(ID[i]==0 && grade[i]==0)
    sum_grades += grade[i];
    }
    printf(""sum is %d\n"", sum_grades);
     
    fclose(ifp);
    return 0;
    }


its a program designed to print out the student's ID's and grades as they appear in the file, print the highest grade, the mean value and print the student's ID's in increasing order

INPUT FILE
------------
3050 76
2030 60
1600 70
2222 50
2430 60
2800 50
0 0
Ball Adam 70
Arnold Joshua 67
Scot Michael 80
Cook Bret 55
Davis Ronald 62
Fox Brian 87
Singh Jaadu 91
Hudson Jeff 45
xxx xxx 0
Fox Brian
Jessi Mala
-------------------
1st part of the program its supposed to stop at the value (""0 0""). so it should print
3050 76
2030 60
1600 70
2222 50
2430 60
2800 50
but (""0 0"") is being included, which affects my mean value as well. also how how do u implement the sorting algorithm for printing the ID's in increasing order which correspond to the grades

help would be appreciated ",1
10694762,05/22/2012 01:38:09,469300,10/07/2010 15:42:41,6548,307,Adopting the newest C features,"I haven't coded in C for a while, and I never got to sit down and learn what was new about the newest standard. Hell, I'm not even sure if I still have primitive C89 idioms _built-in_ in my head.

Where can I find a good guide, tutorial, book or reference that covers the ground of going from classic C89 to C11? I thought this would be a 1-second-googling matter, but that's not the case at all.",c,c11,,,,05/22/2012 04:10:20,not a real question,1,76,5,"Adopting the newest C features I haven't coded in C for a while, and I never got to sit down and learn what was new about the newest standard. Hell, I'm not even sure if I still have primitive C89 idioms _built-in_ in my head.

Where can I find a good guide, tutorial, book or reference that covers the ground of going from classic C89 to C11? I thought this would be a 1-second-googling matter, but that's not the case at all.",2
7506815,09/21/2011 21:20:48,192077,10/18/2009 17:46:14,1417,114,Get up-down control from buddy?,"Is it possible to get a handle to an up-down control from a handle to its buddy? So [`UDM_GETBUDDY`](http://msdn.microsoft.com/en-us/library/bb759913(v=VS.85).aspx) is not an option.

Thanks!",c,winapi,,,,,open,0,23,5,"Get up-down control from buddy? Is it possible to get a handle to an up-down control from a handle to its buddy? So [`UDM_GETBUDDY`](http://msdn.microsoft.com/en-us/library/bb759913(v=VS.85).aspx) is not an option.

Thanks!",2
7810812,10/18/2011 16:47:48,683104,03/30/2011 01:14:24,283,0,Eye not getting detected,"What i am trying is that, at first i detect the face, copy that region to an `IplImage * imgcpy` and then set ROI to the proximity of eyes, however the eyes do not get detected at all.

Here is the code:

    cvSetImageROI(
            imgcpy,                    /* the copied image */
            cvRect(
                1,            
                1, 
                imgcpy->width,        /* width = same width with the face */
                imgcpy->height/2    /* height = 1/2 of face height */
            )
        );
    		CvSeq* eyes = cvHaarDetectObjects(
    		imgcpy,                       /* the input image */
    		cascade,                   /* the classifier */
    		storage,                   /* memory storage */
    		1.1,                       /* scale factor */
    		3,                         /* minimum number of neighbor rectangles */
    		CV_HAAR_DO_CANNY_PRUNING,  /* mode of operation */
    		cvSize(40, 20)             /* min window size */
    		);
        /* draw a rectangle for each detected eye */
       int i;
       for( i = 0; i < (eyes ? eyes->total : 0); i++ ) 
    	{
            /* get one eye */
            CvRect *eye = (CvRect*)cvGetSeqElem(eyes, i);
            /* draw a red rectangle */
            cvRectangle(
                imgcpy,
                cvPoint(eye->x, eye->y),
                cvPoint(eye->width, eye->height),
                CV_RGB(255, 0, 0),
                1, 8, 0
            );
        }

This is the Image the above `for` loop works:

![enter image description here][1]


  [1]: http://s1.postimage.org/wpoufav8/test.jpg?noCache=1318956447",c,opencv,,,,,open,0,637,4,"Eye not getting detected What i am trying is that, at first i detect the face, copy that region to an `IplImage * imgcpy` and then set ROI to the proximity of eyes, however the eyes do not get detected at all.

Here is the code:

    cvSetImageROI(
            imgcpy,                    /* the copied image */
            cvRect(
                1,            
                1, 
                imgcpy->width,        /* width = same width with the face */
                imgcpy->height/2    /* height = 1/2 of face height */
            )
        );
    		CvSeq* eyes = cvHaarDetectObjects(
    		imgcpy,                       /* the input image */
    		cascade,                   /* the classifier */
    		storage,                   /* memory storage */
    		1.1,                       /* scale factor */
    		3,                         /* minimum number of neighbor rectangles */
    		CV_HAAR_DO_CANNY_PRUNING,  /* mode of operation */
    		cvSize(40, 20)             /* min window size */
    		);
        /* draw a rectangle for each detected eye */
       int i;
       for( i = 0; i < (eyes ? eyes->total : 0); i++ ) 
    	{
            /* get one eye */
            CvRect *eye = (CvRect*)cvGetSeqElem(eyes, i);
            /* draw a red rectangle */
            cvRectangle(
                imgcpy,
                cvPoint(eye->x, eye->y),
                cvPoint(eye->width, eye->height),
                CV_RGB(255, 0, 0),
                1, 8, 0
            );
        }

This is the Image the above `for` loop works:

![enter image description here][1]


  [1]: http://s1.postimage.org/wpoufav8/test.jpg?noCache=1318956447",2
3044261,06/15/2010 10:18:03,367126,06/15/2010 10:18:03,1,0,Books and shellcode examples,"i read ""art of exploitation"" and ""gray hat hackers"".Both these books examples written for x86 systems.i have a centrino laptop and an amd64 pc.I can't make work examples for stack based overflow.",c,,,,,09/24/2011 14:56:42,not constructive,1,32,4,"Books and shellcode examples i read ""art of exploitation"" and ""gray hat hackers"".Both these books examples written for x86 systems.i have a centrino laptop and an amd64 pc.I can't make work examples for stack based overflow.",1
7789639,10/17/2011 05:14:31,908148,08/23/2011 16:47:18,166,0,"In C, are you allowed to cast directly from a certain type of pointer to another?","Let's say you start with a void pointer, or a char pointer, or an int pointer, or whatever you would like to name.

        void *p = // initialized to something here

And we do a conversion like 

        *((int *)((char *)p + 6)) = 5;

Does this mean we are basically casting a void pointer to a char pointer, doing some arithmetic, casting that to an int pointer, and then de-referencing it to store 5?

Or do we need to cast the char pointer back to a void pointer before it is safe to cast it to the int pointer?

*** Also, before casting from char* to int*, does there need to be a de-reference somewhere before the conversion?",c,pointers,,,,10/17/2011 07:18:17,too localized,1,129,16,"In C, are you allowed to cast directly from a certain type of pointer to another? Let's say you start with a void pointer, or a char pointer, or an int pointer, or whatever you would like to name.

        void *p = // initialized to something here

And we do a conversion like 

        *((int *)((char *)p + 6)) = 5;

Does this mean we are basically casting a void pointer to a char pointer, doing some arithmetic, casting that to an int pointer, and then de-referencing it to store 5?

Or do we need to cast the char pointer back to a void pointer before it is safe to cast it to the int pointer?

*** Also, before casting from char* to int*, does there need to be a de-reference somewhere before the conversion?",2
10809138,05/30/2012 02:09:11,251162,01/14/2010 23:40:09,3314,42,"why did K&R make &&, || logical and &, | bitwise, not the other way around?","I know that `==` was chosen for equality and `=` for assignment because they thought that people did more assignment than checking for equality---but surely they didn't think that there would be more bit fiddling than boolean logic?

Why not go the other way around, with `&` and `|` being logical operators?",c,language-design,,,,05/30/2012 04:02:05,not constructive,1,51,16,"why did K&R make &&, || logical and &, | bitwise, not the other way around? I know that `==` was chosen for equality and `=` for assignment because they thought that people did more assignment than checking for equality---but surely they didn't think that there would be more bit fiddling than boolean logic?

Why not go the other way around, with `&` and `|` being logical operators?",2
7981473,11/02/2011 13:51:39,1025763,11/02/2011 13:50:45,1,0,Can someone help me in writing this C program?,"Write a C interactive program that will encode a word or sentence entered by a user. The
encryption will be done as follows:
For any word or sentence (note: blank spaces, special characters are ignored here, i.e
they are not changed) entered, each character is encrypted by changing it to the next
adjacent letter of the alphabet.
Thus if the letter a is entered it is changed to b,
if the word zorro is entered it will be changed to apssp,
if the sentence I am a good programmer is entered it will be encrypted to J bn b hppe
qsphsbnnfs.",c,,,,,11/02/2011 14:24:36,not a real question,1,93,9,"Can someone help me in writing this C program? Write a C interactive program that will encode a word or sentence entered by a user. The
encryption will be done as follows:
For any word or sentence (note: blank spaces, special characters are ignored here, i.e
they are not changed) entered, each character is encrypted by changing it to the next
adjacent letter of the alphabet.
Thus if the letter a is entered it is changed to b,
if the word zorro is entered it will be changed to apssp,
if the sentence I am a good programmer is entered it will be encrypted to J bn b hppe
qsphsbnnfs.",1
6846467,07/27/2011 14:54:49,32836,10/30/2008 17:14:02,747,25,Where can I find source code to do a simple linear regression?,"As is my bent, I'm coding for an embedded system and I need to estimate some line equation parameters (the 'ol `y=mx+b` thing).

***I'm looking for C source code to do a simple regression on a dozen or so coordinate pairs and generate slope, and intercept constants.***  Co-variance etc. aren't of any concern.

I've not found a project that I can compile into a simple little binary, and I'm not interested in cross compiling a library (overkill).  Yes, it's a simple project, but if I can save myself 90 minutes of coding by using someone else's code that'd be great.",c,algorithm,math,source,,07/27/2011 16:15:56,not constructive,1,100,12,"Where can I find source code to do a simple linear regression? As is my bent, I'm coding for an embedded system and I need to estimate some line equation parameters (the 'ol `y=mx+b` thing).

***I'm looking for C source code to do a simple regression on a dozen or so coordinate pairs and generate slope, and intercept constants.***  Co-variance etc. aren't of any concern.

I've not found a project that I can compile into a simple little binary, and I'm not interested in cross compiling a library (overkill).  Yes, it's a simple project, but if I can save myself 90 minutes of coding by using someone else's code that'd be great.",4
4522025,12/23/2010 19:56:16,506114,11/12/2010 18:18:11,3,1,expect - c program,"I am trying to compile a program written in c using the expect.h header.  I am trying this:

cc -I/usr/include main.c -lexpect -ltcl
cc -I/usr/include main.c

I tried the same with gcc, but to no avail.

I get this:

undefined reference to `exp_spawnl'
undefined reference to `exp_expectl'


Any ideas?


Thanks,

Walter",c,expect,,,,,open,0,43,4,"expect - c program I am trying to compile a program written in c using the expect.h header.  I am trying this:

cc -I/usr/include main.c -lexpect -ltcl
cc -I/usr/include main.c

I tried the same with gcc, but to no avail.

I get this:

undefined reference to `exp_spawnl'
undefined reference to `exp_expectl'


Any ideas?


Thanks,

Walter",2
9514718,03/01/2012 10:41:38,1018562,03/08/2010 14:56:00,18,0,Checksum with low probability of false negative,"At this moment I'm using a simple checksum scheme, that just adds the words in a buffer. Firstly, my question is what is the probability of a false negative, that is, the receiving system calculating the same checksum as the sending system even when the data is different (corrupted). 

Secondly, how can I reduce the probability of false negatives? What is the best checksuming scheme for that. Note that each word in the buffer is of size 64 bits or 8 bytes, that is a long variable in a 64 bit system.",c,probability,checksum,reliability,,,open,0,92,7,"Checksum with low probability of false negative At this moment I'm using a simple checksum scheme, that just adds the words in a buffer. Firstly, my question is what is the probability of a false negative, that is, the receiving system calculating the same checksum as the sending system even when the data is different (corrupted). 

Secondly, how can I reduce the probability of false negatives? What is the best checksuming scheme for that. Note that each word in the buffer is of size 64 bits or 8 bytes, that is a long variable in a 64 bit system.",4
5981510,05/12/2011 16:47:04,737825,05/04/2011 10:57:10,1,0,[C]--binary function,"I'm working in a small program using Language C.
I want to create a function which transform a decimal number to binary.
So i Have that:

 #include<stdio.h>
int *binaire(int nb,int base)
{  
     int d,i=0,j;
      int *tab= (int*) malloc(sizeof(int));
while(nb>0){
            tab[i]=(nb%base);//inverser  les bits    
            nb=nb/base;
            i++;
           }
           
return tab;
  
}


please Help

Thxs",c,binary,,,,05/12/2011 21:07:28,not a real question,1,114,2,"[C]--binary function I'm working in a small program using Language C.
I want to create a function which transform a decimal number to binary.
So i Have that:

 #include<stdio.h>
int *binaire(int nb,int base)
{  
     int d,i=0,j;
      int *tab= (int*) malloc(sizeof(int));
while(nb>0){
            tab[i]=(nb%base);//inverser  les bits    
            nb=nb/base;
            i++;
           }
           
return tab;
  
}


please Help

Thxs",2
489496,01/28/2009 21:37:17,26659,10/09/2008 22:28:51,195,13,Pointer issues when using sqlite in an objective-c program.,"When i try to compile this as part of an objective-c program it gives the warning:  
 `warning: passing argument 1 of 'sqlite3_close' from incompatible pointer type`

    sqlite3 *db;
    sqlite3_open(""~/Documents/testdb.sqlite"", &db);
    /*stuff*/
    sqlite3_close(&db);

An almost identical error is given with nearly any other function call that uses `&db`.",c,pointers,warnings,objective-c,sqlite,,open,0,60,9,"Pointer issues when using sqlite in an objective-c program. When i try to compile this as part of an objective-c program it gives the warning:  
 `warning: passing argument 1 of 'sqlite3_close' from incompatible pointer type`

    sqlite3 *db;
    sqlite3_open(""~/Documents/testdb.sqlite"", &db);
    /*stuff*/
    sqlite3_close(&db);

An almost identical error is given with nearly any other function call that uses `&db`.",5
4864605,02/01/2011 15:42:03,596976,01/31/2011 14:31:32,7,0,I have to use a C program which uses a file. How do I create that file which must contain some entries for a graph information?,I have to use a C program which uses a file. How do I create that file which must contain some entries for a graph information?,c,,,,,02/01/2011 17:24:37,not a real question,1,26,26,I have to use a C program which uses a file. How do I create that file which must contain some entries for a graph information? I have to use a C program which uses a file. How do I create that file which must contain some entries for a graph information?,1
6169613,05/29/2011 18:34:21,775015,05/29/2011 09:46:10,1,0,Communication between processes in C.,"I have a problem with an porject I'm doing and I can't solve it ...

So, I have to create in C under Linux an complete tree of proccesses with 
K nodes of wich and L depth. This I manage to do until now.

Now, havind declared a array with elements, I have to split the array in parts
from a process to their childs, the child split what he get to his childs and so on.

The leafs take the numbers they get, do a bubble-sort and return it to their parents.
Their parents, getting the vectors sorted, do a merge-sort between them 
(they will have to do a merge-sort between K arrays) and return it to the node above, and so on.

All this connections have to be made with FIFOs.
So I start by creating 3 FIFOs in my main : myFifo,myFifo1 & myFifo2
 
Than I create a first process(the root)

-> the child writes in myFifo my numbers

-> than he calls my function where I create the tree (sort_rec)

-> the father reads from myFifo2 and write data to screen
 
I got blocked at creating connections between my procceses ... any Idea/ suggestion will be good
my idea and what I did untill now is here: (the sort_rec function):
 

       int L = 3;// - depth
        int K = 3;// - number of procceses for each
    int buffer[1000][1000];
    int nou[1000]; // another buffer
    int Nnou;  // number of nou elements
    void sort_rec(int depth)
    {
       int i;
       int nr=0;
       if(depth < L)
       {
           while(nr!=K)
            {
            nr++;
            pid_t pid;
            pid = fork();
                switch(pid)
                {
                    case -1:
                        {
                            printf(""Error at fork()..."");
                            return;
                        }
                      break;
                    case 0:
                        {
                            if(depth==L-1)
                            {
                                printf(""son : %d (leaf)   -> his father : %d\n\n"",getpid(),getppid());
                                fd = open(""myFifo1"",O_RDONLY);
                                fd2 = open(""myFifo2"",O_WRONLY);
                                    int size = read(fd,&v1,sizeof(v1));
                                    bubble_sort(v1,size/4);
                                    write(fd2,&v1, size);
                                close(fd);
                                close(fd2);
                            }
                            else
                                printf(""son : %d   -> his father : %d\n\n"",getpid(),getppid());
                            sort_rec(depth+1);
                            return;
                        }
                      break;
                    default:
                        {
                            fd = open(""myFifo1"",O_RDONLY);
                            fd2 = open(""myFifo2"",O_WRONLY);
                            int xx;
                            if(depth==1)
                            {
                                int fd1 = open(""myFifo"",O_RDONLY|O_NONBLOCK);
                                 xx = read(fd1,&V,sizeof(V));
                                close(fd1);
                                //printf(""%d"",V[1]);
                            }
                            else
                                { xx = read(fd,&V,sizeof(V)); }
                            int i;
                            for( i = 0; i < multiplu / powe(K,depth-1);i++ )
                                v1[i] = V[i];
                            truncate(v1,i,xx); //truncate v1 with i size of first xx elements
                            int x = read(fd2,&buffer[t],sizeof(buffer[t]));
                            t++;
                            if(nr == K)
                            {
                                for(i = 0; i< K; i++)
                                {
                                    interclasare(nou,nou,buffer[i],Nnou,x); // sort between 2 arrays (2nd one and 3th one) put the result in first one
                                }
                                write(fd2,&nou,Nnou);
                                t=0;
                                truncc(nou); // eliminate all elements from nou
                                Nnou=0; // Number of nou elements = 0
                            }
                            close(fd);
                            close(fd2);
                            wait(0);
                            continue;
                        }
                }
            }
       }
     else // last level
       {
          return;
       }
    return;
    }",c,linux,unix,,,06/02/2011 03:49:40,too localized,1,2330,5,"Communication between processes in C. I have a problem with an porject I'm doing and I can't solve it ...

So, I have to create in C under Linux an complete tree of proccesses with 
K nodes of wich and L depth. This I manage to do until now.

Now, havind declared a array with elements, I have to split the array in parts
from a process to their childs, the child split what he get to his childs and so on.

The leafs take the numbers they get, do a bubble-sort and return it to their parents.
Their parents, getting the vectors sorted, do a merge-sort between them 
(they will have to do a merge-sort between K arrays) and return it to the node above, and so on.

All this connections have to be made with FIFOs.
So I start by creating 3 FIFOs in my main : myFifo,myFifo1 & myFifo2
 
Than I create a first process(the root)

-> the child writes in myFifo my numbers

-> than he calls my function where I create the tree (sort_rec)

-> the father reads from myFifo2 and write data to screen
 
I got blocked at creating connections between my procceses ... any Idea/ suggestion will be good
my idea and what I did untill now is here: (the sort_rec function):
 

       int L = 3;// - depth
        int K = 3;// - number of procceses for each
    int buffer[1000][1000];
    int nou[1000]; // another buffer
    int Nnou;  // number of nou elements
    void sort_rec(int depth)
    {
       int i;
       int nr=0;
       if(depth < L)
       {
           while(nr!=K)
            {
            nr++;
            pid_t pid;
            pid = fork();
                switch(pid)
                {
                    case -1:
                        {
                            printf(""Error at fork()..."");
                            return;
                        }
                      break;
                    case 0:
                        {
                            if(depth==L-1)
                            {
                                printf(""son : %d (leaf)   -> his father : %d\n\n"",getpid(),getppid());
                                fd = open(""myFifo1"",O_RDONLY);
                                fd2 = open(""myFifo2"",O_WRONLY);
                                    int size = read(fd,&v1,sizeof(v1));
                                    bubble_sort(v1,size/4);
                                    write(fd2,&v1, size);
                                close(fd);
                                close(fd2);
                            }
                            else
                                printf(""son : %d   -> his father : %d\n\n"",getpid(),getppid());
                            sort_rec(depth+1);
                            return;
                        }
                      break;
                    default:
                        {
                            fd = open(""myFifo1"",O_RDONLY);
                            fd2 = open(""myFifo2"",O_WRONLY);
                            int xx;
                            if(depth==1)
                            {
                                int fd1 = open(""myFifo"",O_RDONLY|O_NONBLOCK);
                                 xx = read(fd1,&V,sizeof(V));
                                close(fd1);
                                //printf(""%d"",V[1]);
                            }
                            else
                                { xx = read(fd,&V,sizeof(V)); }
                            int i;
                            for( i = 0; i < multiplu / powe(K,depth-1);i++ )
                                v1[i] = V[i];
                            truncate(v1,i,xx); //truncate v1 with i size of first xx elements
                            int x = read(fd2,&buffer[t],sizeof(buffer[t]));
                            t++;
                            if(nr == K)
                            {
                                for(i = 0; i< K; i++)
                                {
                                    interclasare(nou,nou,buffer[i],Nnou,x); // sort between 2 arrays (2nd one and 3th one) put the result in first one
                                }
                                write(fd2,&nou,Nnou);
                                t=0;
                                truncc(nou); // eliminate all elements from nou
                                Nnou=0; // Number of nou elements = 0
                            }
                            close(fd);
                            close(fd2);
                            wait(0);
                            continue;
                        }
                }
            }
       }
     else // last level
       {
          return;
       }
    return;
    }",3
9703859,03/14/2012 14:27:22,707381,04/14/2011 06:23:33,2521,13,List callable functions from GDB,"Using GDB on the command line, I sometimes break at a certain line of code. At that breakpoint, I can then call functions *as if* my executable contained the call.

How can I get GDB to print the list of all the possible functions that are callable at a given breakpoint?",c,gdb,,,,,open,0,50,5,"List callable functions from GDB Using GDB on the command line, I sometimes break at a certain line of code. At that breakpoint, I can then call functions *as if* my executable contained the call.

How can I get GDB to print the list of all the possible functions that are callable at a given breakpoint?",2
161873,10/02/2008 11:49:42,14048,09/16/2008 21:49:33,831,55,"K & R Exercise: My Code Works, But Feels Stinky; Advice for Cleanup?","I'm working on the K&R book. I've read farther ahead than I've done exercises, mostly for lack of time. I'm catching up, and have done almost all the exercises from chapter 1, which is the tutorial.

My issue was exercise 1-18. The exercise is to:

> Write a program to remove trailing blanks and 
> tabs from line of input, and to delete entirely blank lines

My code (below) does that, and works. My problem with it is the trim method I implemented. It feels ... wrong ... somehow. Like if I saw similar code in C# in a code review, I'd probably go nuts. (C# being one of my specialties.)

Can anyone offer some advice on cleaning this up -- with the catch that said advice has to only use knowledge from Chapter 1 of K & R. (I know there are a zillion ways to clean this up using the full C library; we're just talking Chapter 1 and basic stdio.h here.) Also, when giving the advice, can you explain why it will help? (I am, after all, trying to learn! And who better to learn from than the experts here?)

    #include <stdio.h>
    
    #define MAXLINE 1000
    
    int getline(char line[], int max);
    void trim(char line[], char ret[]);
    
    int main()
    {
        char line[MAXLINE];
        char out[MAXLINE];
        int length;
    
        while ((length = getline(line, MAXLINE)) > 0)
        {
            trim(line, out);
            printf(""%s"", out);
        }
    
        return 0;
    }
    
    int getline(char line[], int max)
    {
        int c, i;
    
        for (i = 0; i < max - 1 && (c = getchar()) != EOF && c != '\n'; ++i)
            line[i] = c;
    
        if (c == '\n')
        {
            line[i] = c;
            ++i;
        }
    
        line[i] = '\0'; 
        return i;
    }
    
    void trim(char line[], char ret[])
    {
        int i = 0;
    
        while ((ret[i] = line[i]) != '\0')
            ++i;
    
        if (i == 1)
        {
            // Special case to remove entirely blank line
            ret[0] = '\0';
            return;
        }
    
        for (  ; i >= 0; --i)
        {
            if (ret[i] == ' ' || ret[i] == '\t')
                ret[i] = '\0';
            else if (ret[i] != '\0' && ret[i] != '\r' && ret[i] != '\n')
                break;
        }
    
        for (i = 0; i < MAXLINE; ++i)
        {
            if (ret[i] == '\n')
            {
                break;
            }
            else if (ret[i] == '\0')
            {
                ret[i] = '\n';
                ret[i + 1] = '\0';
                break;
            }
        }
    }",c,kernighan-and-ritchie,training,,,,open,0,930,13,"K & R Exercise: My Code Works, But Feels Stinky; Advice for Cleanup? I'm working on the K&R book. I've read farther ahead than I've done exercises, mostly for lack of time. I'm catching up, and have done almost all the exercises from chapter 1, which is the tutorial.

My issue was exercise 1-18. The exercise is to:

> Write a program to remove trailing blanks and 
> tabs from line of input, and to delete entirely blank lines

My code (below) does that, and works. My problem with it is the trim method I implemented. It feels ... wrong ... somehow. Like if I saw similar code in C# in a code review, I'd probably go nuts. (C# being one of my specialties.)

Can anyone offer some advice on cleaning this up -- with the catch that said advice has to only use knowledge from Chapter 1 of K & R. (I know there are a zillion ways to clean this up using the full C library; we're just talking Chapter 1 and basic stdio.h here.) Also, when giving the advice, can you explain why it will help? (I am, after all, trying to learn! And who better to learn from than the experts here?)

    #include <stdio.h>
    
    #define MAXLINE 1000
    
    int getline(char line[], int max);
    void trim(char line[], char ret[]);
    
    int main()
    {
        char line[MAXLINE];
        char out[MAXLINE];
        int length;
    
        while ((length = getline(line, MAXLINE)) > 0)
        {
            trim(line, out);
            printf(""%s"", out);
        }
    
        return 0;
    }
    
    int getline(char line[], int max)
    {
        int c, i;
    
        for (i = 0; i < max - 1 && (c = getchar()) != EOF && c != '\n'; ++i)
            line[i] = c;
    
        if (c == '\n')
        {
            line[i] = c;
            ++i;
        }
    
        line[i] = '\0'; 
        return i;
    }
    
    void trim(char line[], char ret[])
    {
        int i = 0;
    
        while ((ret[i] = line[i]) != '\0')
            ++i;
    
        if (i == 1)
        {
            // Special case to remove entirely blank line
            ret[0] = '\0';
            return;
        }
    
        for (  ; i >= 0; --i)
        {
            if (ret[i] == ' ' || ret[i] == '\t')
                ret[i] = '\0';
            else if (ret[i] != '\0' && ret[i] != '\r' && ret[i] != '\n')
                break;
        }
    
        for (i = 0; i < MAXLINE; ++i)
        {
            if (ret[i] == '\n')
            {
                break;
            }
            else if (ret[i] == '\0')
            {
                ret[i] = '\n';
                ret[i + 1] = '\0';
                break;
            }
        }
    }",3
4593493,01/04/2011 12:21:28,562495,01/04/2011 11:49:54,1,0,Windows API's which will show the running processes,"I want to create a tool like mini task manager. I want to show all the running processes, cpu and memory usage. Can anybody tell me related api's which I can use for this. Any link to related web page will be appreciated. (I want dump of all the statistics of running processes, cpu and memory.) Thanks in advance.",c,windows,winapi,visual-c++,process,,open,0,59,8,"Windows API's which will show the running processes I want to create a tool like mini task manager. I want to show all the running processes, cpu and memory usage. Can anybody tell me related api's which I can use for this. Any link to related web page will be appreciated. (I want dump of all the statistics of running processes, cpu and memory.) Thanks in advance.",5
8031070,11/06/2011 22:58:47,996120,10/14/2011 20:25:50,6,0,Insertion sort linked list C,"Having troubles understanding insertion sort, anyone have any good code examples or websites showing algorithms? Can't find any good examples from google.",c,sorting,linked-list,insertion-sort,,11/07/2011 03:06:46,not a real question,1,22,5,"Insertion sort linked list C Having troubles understanding insertion sort, anyone have any good code examples or websites showing algorithms? Can't find any good examples from google.",4
5529682,04/03/2011 12:52:34,631766,02/24/2011 06:15:11,83,0,memory error in c program,"hello every one i have made a program in which i am handling files but i am getting this error
(i have run it through gdb)

Program received signal SIGSEGV, Segmentation fault.
0x0016e50b in vfprintf () from /lib/tls/i686/cmov/libc.so.6

i am not getting the exact line that contain error . can any body tell me what this error means and when does it occur any special reason for its occurrence or is it general error occur because of many reason thanks
",c,linux,gcc,,,04/04/2011 19:37:24,not a real question,1,76,5,"memory error in c program hello every one i have made a program in which i am handling files but i am getting this error
(i have run it through gdb)

Program received signal SIGSEGV, Segmentation fault.
0x0016e50b in vfprintf () from /lib/tls/i686/cmov/libc.so.6

i am not getting the exact line that contain error . can any body tell me what this error means and when does it occur any special reason for its occurrence or is it general error occur because of many reason thanks
",3
2766233,05/04/2010 14:37:52,307797,04/02/2010 16:37:08,94,0,What is C runtime library?,"OK, I know this is maybe the most stupid question ever asked here, but what actually is C runtime library and what is used for? I was searching, googling like devil, but I could find better than Microsofts: ""The Microsoft run-time library provides routines for programming for the Microsoft Windows operating system. These routines automate many common programming tasks that are not provided by the C and C++ languages.""

OK, I get that, but for example, what is in libcmt.lib ? What functions? I thought that C standart library is part of C compiler, so is libcmt.lib windows implementation of C standart library functions to work under win32?

",c,runtime,,,,,open,0,107,5,"What is C runtime library? OK, I know this is maybe the most stupid question ever asked here, but what actually is C runtime library and what is used for? I was searching, googling like devil, but I could find better than Microsofts: ""The Microsoft run-time library provides routines for programming for the Microsoft Windows operating system. These routines automate many common programming tasks that are not provided by the C and C++ languages.""

OK, I get that, but for example, what is in libcmt.lib ? What functions? I thought that C standart library is part of C compiler, so is libcmt.lib windows implementation of C standart library functions to work under win32?

",2
7586990,09/28/2011 17:13:34,468130,10/06/2010 15:15:56,293,1,strstr faster then algorithms?,"Alright i have a file thats `21056` bytes.

I've writen a program in C that reads the entire file into a buffer, and then uses multiple search algorithms to search the file for a token thats `82` chars.

I've used all the implementations of the algorithms from [here][1]<br>
I've used: KMP, BM, TBM, and Horspool. And then i used `strstr` and benchmarked each one.
<br>What i'm wondering is, each time the `strstr` outperforms all the other algorthms. The only one that is faster sometimes is BM.

Shouldn't `strstr` be the slowest?

Here's my benchmark code with an example of benchmarking BM:
<pre><code>double get_time()
{
	LARGE_INTEGER t, f;
	QueryPerformanceCounter(&t);
	QueryPerformanceFrequency(&f);
	return (double)t.QuadPart/(double)f.QuadPart;
}</pre></code>

    before = get_time();
    BM(token, strlen(token), buffer, len);
    after = get_time();
    printf(""Time: %f\n\n"", after - before);

Could someone explain to me why `strstr` is outperforming the other search algorithms?<br>
I'll post more code on request if needed.

  [1]: http://igm.univ-mlv.fr/~lecroq/string/node1.html",c,performance,algorithm,strstr,,,open,0,148,4,"strstr faster then algorithms? Alright i have a file thats `21056` bytes.

I've writen a program in C that reads the entire file into a buffer, and then uses multiple search algorithms to search the file for a token thats `82` chars.

I've used all the implementations of the algorithms from [here][1]<br>
I've used: KMP, BM, TBM, and Horspool. And then i used `strstr` and benchmarked each one.
<br>What i'm wondering is, each time the `strstr` outperforms all the other algorthms. The only one that is faster sometimes is BM.

Shouldn't `strstr` be the slowest?

Here's my benchmark code with an example of benchmarking BM:
<pre><code>double get_time()
{
	LARGE_INTEGER t, f;
	QueryPerformanceCounter(&t);
	QueryPerformanceFrequency(&f);
	return (double)t.QuadPart/(double)f.QuadPart;
}</pre></code>

    before = get_time();
    BM(token, strlen(token), buffer, len);
    after = get_time();
    printf(""Time: %f\n\n"", after - before);

Could someone explain to me why `strstr` is outperforming the other search algorithms?<br>
I'll post more code on request if needed.

  [1]: http://igm.univ-mlv.fr/~lecroq/string/node1.html",4
1919183,12/17/2009 02:53:17,11688,09/16/2008 10:13:56,154,4,How to allocate and free aligned memory in C,"How do you allocate memory that's aligned to a specific boundary in C (e.g., cache line boundary)?  I'm looking for malloc/free like implementation that ideally would be as portable as possible --- at least between 32 and 64 bit architectures.

",c,alignment,memory-alignment,memory-mapped-files,,,open,0,41,9,"How to allocate and free aligned memory in C How do you allocate memory that's aligned to a specific boundary in C (e.g., cache line boundary)?  I'm looking for malloc/free like implementation that ideally would be as portable as possible --- at least between 32 and 64 bit architectures.

",4
4064276,10/31/2010 17:48:46,217223,11/23/2009 18:13:52,42,4,What happens if a program runs also its comments??!!,"It seams very weird to me.I cant really understand whats happening.
I had a false on my code,decided to put a part of it on /*...*/.
The same I did for its calling of the function.
BUT when i run the program... this part of code is also executed!!!

",c,comments,,,,10/31/2010 18:12:03,not a real question,1,46,9,"What happens if a program runs also its comments??!! It seams very weird to me.I cant really understand whats happening.
I had a false on my code,decided to put a part of it on /*...*/.
The same I did for its calling of the function.
BUT when i run the program... this part of code is also executed!!!

",2
8340044,12/01/2011 10:45:59,1075235,12/01/2011 10:40:52,1,0,Would someone tell me what to learn after C?,"I'm a college student majoring in software engineering and I'm very interested in programming.
So I want to become able to write desktop application on my own ASAP. I have already learnt C, what should I learn next? Or would you suggest me a list of books to read? Thanks in advance.",c,college,,,,12/01/2011 10:50:57,not constructive,1,51,9,"Would someone tell me what to learn after C? I'm a college student majoring in software engineering and I'm very interested in programming.
So I want to become able to write desktop application on my own ASAP. I have already learnt C, what should I learn next? Or would you suggest me a list of books to read? Thanks in advance.",2
5374968,03/21/2011 07:40:53,669026,03/21/2011 07:31:49,1,2,Is network event based programming really better...?,"With event based programming you essentially just loop and poll, loop and poll...why is this preferred to just blocking? If you're not receiving any events why would you prefer to use select() over just blocking on an accept()?",c,select,network-programming,,,03/21/2011 09:14:04,not constructive,1,38,7,"Is network event based programming really better...? With event based programming you essentially just loop and poll, loop and poll...why is this preferred to just blocking? If you're not receiving any events why would you prefer to use select() over just blocking on an accept()?",3
7805673,10/18/2011 10:16:53,209486,11/12/2009 10:34:41,383,25,Architectural advice for Apache Camel and C,"I'm experimenting a bit with Apache Camel to propose it to my boss as an ""ESB solution"" which he is pushing for. Camel looks like a nice project, and a good way to keep away from more heavyweight stuff.

We've got a low-level layer implemented in C which listens to network events and is supposed to trigger some demo Camel route. Which is the best way to do such integration? I was thinking of JMS and [STOMP][1] protocol, unfortunately its [C client library][2] looks funny (you have to compile it on XCode, for one).

Have you got any alternatives to suggest?

  [1]: http://stomp.github.com/
  [2]: http://docs.codehaus.org/display/STOMP/C",c,jms,apache-camel,,,,open,0,105,7,"Architectural advice for Apache Camel and C I'm experimenting a bit with Apache Camel to propose it to my boss as an ""ESB solution"" which he is pushing for. Camel looks like a nice project, and a good way to keep away from more heavyweight stuff.

We've got a low-level layer implemented in C which listens to network events and is supposed to trigger some demo Camel route. Which is the best way to do such integration? I was thinking of JMS and [STOMP][1] protocol, unfortunately its [C client library][2] looks funny (you have to compile it on XCode, for one).

Have you got any alternatives to suggest?

  [1]: http://stomp.github.com/
  [2]: http://docs.codehaus.org/display/STOMP/C",3
10382526,04/30/2012 10:56:25,1162346,01/21/2012 14:00:23,35,1,Would an ARM Processor be the way to go?,"I was making a little device that would have three buttons (like the ones at radioshack) and each preform its own action. These buttons and their actions would be controlled by a **very** small real time operating system that I would put on this device. 

1. Would I need an ARM Processor in any way?
2. How would I put the real time operating system on the device?
3. What OS would I have to compile this on (ex. Ubuntu? Mac OS X? Windows 7?)?
4. Are there any examples of anyone doing this?


P.S. No prebuilt boards (ex. arduino). I would build the board myself.

Any feedback would be greatly appreciated!",c,operating-system,arm,hardware,,04/30/2012 11:57:25,off topic,1,107,9,"Would an ARM Processor be the way to go? I was making a little device that would have three buttons (like the ones at radioshack) and each preform its own action. These buttons and their actions would be controlled by a **very** small real time operating system that I would put on this device. 

1. Would I need an ARM Processor in any way?
2. How would I put the real time operating system on the device?
3. What OS would I have to compile this on (ex. Ubuntu? Mac OS X? Windows 7?)?
4. Are there any examples of anyone doing this?


P.S. No prebuilt boards (ex. arduino). I would build the board myself.

Any feedback would be greatly appreciated!",4
4774583,01/23/2011 15:28:00,584610,01/21/2011 15:05:55,8,0,How to write c code for finding the greatest of three numbers entered? ,"How to write c code for finding the greatest of three numbers entered ?

Thanks in advance,",c,,,,,01/23/2011 16:13:12,not a real question,1,16,14,"How to write c code for finding the greatest of three numbers entered?  How to write c code for finding the greatest of three numbers entered ?

Thanks in advance,",1
5878364,05/04/2011 04:00:01,339297,05/12/2010 12:39:13,34,0,Is there any problem with this code?,"

     #include<iostream>
     #include<fstream>
     #include<cstring>
     using namespace std;

    int main(){
	cout<<""Hello."";
	ifstream attack,output;
	attack.open(""CattackList"");
	output.open(""finaltestOutput.txt"");
	if(!attack)
	cout<<""file1 not opened.\n"";
	if(!output)
	cout<<""file2 not opened.\n"";
	char buf1[100],buf2[100];
	attack.getline(buf1,100);
	int count = 0,C=0;cout<<""hello"";
	while(! attack.eof()){
		C++;cout<<""ok"";
		output.open(""finaltestOutput"");
		while(!output.eof()){
			output.getline(buf2,80);
			if(strncmp(buf1,buf2,51) == 0){
				cout<<buf2<<endl;				
				count++;
			}
		}
		attack.getline(buf1,80);
	
	}
	cout<<""\nTotal Attacks : ""<<C<<endl;
	cout<<""Attacks detected: ""<<count<<endl;
	return 0;
    }

I am not able to get even the first ""Hello"" to get printed...",c,,,,,05/04/2011 05:20:23,not a real question,1,62,7,"Is there any problem with this code? 

     #include<iostream>
     #include<fstream>
     #include<cstring>
     using namespace std;

    int main(){
	cout<<""Hello."";
	ifstream attack,output;
	attack.open(""CattackList"");
	output.open(""finaltestOutput.txt"");
	if(!attack)
	cout<<""file1 not opened.\n"";
	if(!output)
	cout<<""file2 not opened.\n"";
	char buf1[100],buf2[100];
	attack.getline(buf1,100);
	int count = 0,C=0;cout<<""hello"";
	while(! attack.eof()){
		C++;cout<<""ok"";
		output.open(""finaltestOutput"");
		while(!output.eof()){
			output.getline(buf2,80);
			if(strncmp(buf1,buf2,51) == 0){
				cout<<buf2<<endl;				
				count++;
			}
		}
		attack.getline(buf1,80);
	
	}
	cout<<""\nTotal Attacks : ""<<C<<endl;
	cout<<""Attacks detected: ""<<count<<endl;
	return 0;
    }

I am not able to get even the first ""Hello"" to get printed...",1
9952222,03/31/2012 01:27:57,1232962,02/25/2012 19:39:20,1,0,Run c program from QT,"I have an application written in C language. Some how I need to create Qt frontend for it. I have linked c library to Qt project but I do not know how to call and execute c program in QT. Is there any command for that ? 

Because I need to pass the output of c program to Qt application.

Thanks in advance",c,qt,gui,,,,open,0,62,5,"Run c program from QT I have an application written in C language. Some how I need to create Qt frontend for it. I have linked c library to Qt project but I do not know how to call and execute c program in QT. Is there any command for that ? 

Because I need to pass the output of c program to Qt application.

Thanks in advance",3
6804105,07/24/2011 00:08:08,312725,04/09/2010 11:37:00,117,1,How do I make sure that I understand C pointers?,"Without any mentor, self-teaching myself with books and references on the web, how do I make sure that I properly understand pointers in C? What tests should I go through, what questions to answer to be sure?",c,pointers,,,,07/24/2011 04:39:17,not constructive,1,37,10,"How do I make sure that I understand C pointers? Without any mentor, self-teaching myself with books and references on the web, how do I make sure that I properly understand pointers in C? What tests should I go through, what questions to answer to be sure?",2
686483,03/26/2009 16:22:40,59754,01/28/2009 13:36:52,703,43,C# vs C  - Big performance difference,"I'm finding massive performance differences between similar code in C anc C#.

The C code is:

    #include <stdio.h>
    #include <time.h>
    #include <math.h>
    
    main()
    {
    	int i;
    	double root;
    	
    	clock_t start = clock();
    	for (i = 0 ; i <= 100000000; i++){
    		root = sqrt(i);
    	}
    	printf(""Time elapsed: %f\n"", ((double)clock() - start) / CLOCKS_PER_SEC);	
    
    }

And the C# (console app) is:

    using System;
    using System.Collections.Generic;
    using System.Text;
    
    namespace ConsoleApplication2
    {
        class Program
        {
            static void Main(string[] args)
            {
                DateTime startTime = DateTime.Now;
                double root;
                for (int i = 0; i <= 100000000; i++)
                {
                    root = Math.Sqrt(i);
                }
                TimeSpan runTime = DateTime.Now - startTime;
                Console.WriteLine(""Time elapsed: "" + Convert.ToString(runTime.TotalMilliseconds/1000));
            }
        }
    }

With the above code, the C# completes in 0.328125 seconds (release version) and the C takes 11.14 seconds to run.

The c is being compiled to a windows executable using mingw.

I've always been under the assumption that C/C++ were faster or at least comparable to C#.net.  What exactly is causing the C to run over 30 times slower?


",c,c#,performance,,,01/17/2012 22:32:49,not constructive,1,417,8,"C# vs C  - Big performance difference I'm finding massive performance differences between similar code in C anc C#.

The C code is:

    #include <stdio.h>
    #include <time.h>
    #include <math.h>
    
    main()
    {
    	int i;
    	double root;
    	
    	clock_t start = clock();
    	for (i = 0 ; i <= 100000000; i++){
    		root = sqrt(i);
    	}
    	printf(""Time elapsed: %f\n"", ((double)clock() - start) / CLOCKS_PER_SEC);	
    
    }

And the C# (console app) is:

    using System;
    using System.Collections.Generic;
    using System.Text;
    
    namespace ConsoleApplication2
    {
        class Program
        {
            static void Main(string[] args)
            {
                DateTime startTime = DateTime.Now;
                double root;
                for (int i = 0; i <= 100000000; i++)
                {
                    root = Math.Sqrt(i);
                }
                TimeSpan runTime = DateTime.Now - startTime;
                Console.WriteLine(""Time elapsed: "" + Convert.ToString(runTime.TotalMilliseconds/1000));
            }
        }
    }

With the above code, the C# completes in 0.328125 seconds (release version) and the C takes 11.14 seconds to run.

The c is being compiled to a windows executable using mingw.

I've always been under the assumption that C/C++ were faster or at least comparable to C#.net.  What exactly is causing the C to run over 30 times slower?


",3
7976969,11/02/2011 07:25:22,966756,09/27/2011 10:07:30,56,2,Good practice and meamory leaks,"
    int* difference (int *a, int *b){
        if (*a > *b){
		*a = *a - *b;
    	}else{
    		*a = *b - *a;
    	}
	    return a;
    }

    int main (){
	    int *xp, *yp;
	    int x, y;

	    x = 9;
	    y = 7;

	    xp = &x;
	    yp = &y;

	    xp = sum (xp,yp);
        printf(""xp value: %d\n"", *xp);

	    return 0;
    }

For some reasons I need my program to do some mathematical operations on mono dimensional arrays. I posted a sample here because I'm concerned regarding the difference function and its returned value.

The both values are pointers but I need to do this because I can't know for sure which of the values is grater. Is my way of doing things a good practice or is there a better way for this issue?

",c,dynamic,,,,11/03/2011 06:44:33,not a real question,1,190,5,"Good practice and meamory leaks 
    int* difference (int *a, int *b){
        if (*a > *b){
		*a = *a - *b;
    	}else{
    		*a = *b - *a;
    	}
	    return a;
    }

    int main (){
	    int *xp, *yp;
	    int x, y;

	    x = 9;
	    y = 7;

	    xp = &x;
	    yp = &y;

	    xp = sum (xp,yp);
        printf(""xp value: %d\n"", *xp);

	    return 0;
    }

For some reasons I need my program to do some mathematical operations on mono dimensional arrays. I posted a sample here because I'm concerned regarding the difference function and its returned value.

The both values are pointers but I need to do this because I can't know for sure which of the values is grater. Is my way of doing things a good practice or is there a better way for this issue?

",2
6187816,05/31/2011 12:49:04,774254,05/28/2011 11:09:42,1,0,C SOCKET PROBLEM,h how can write a data to text file but data will come from over socket in c but when  define File * pointer in socket function the socket can not recive something what can  do please help,c,sockets,,,,05/31/2011 12:58:21,not a real question,1,40,3,C SOCKET PROBLEM h how can write a data to text file but data will come from over socket in c but when  define File * pointer in socket function the socket can not recive something what can  do please help,2
8716380,01/03/2012 17:42:51,1128325,01/03/2012 17:14:51,1,0,comparing unequaled int arrays,"I am new in C and i dont know the syntax well...i use google a lot but am stucked here
with this question: i need to compare between 2 integer unequaled size arryas?
it has to be most efficient - is it posiable O(n)??
print all the difrrent integers

      int compar2arr(int arrA[],int arrB[])
        {
            int i;
            int allMatch = 1;
         
    
            for (int i = 0; i < ARY_SIZE; i++)
            {
                if (arrA[i] != arrB[i])
                {
                    allMatch = 0;
                    break;
                }
            }
         
            if (allMatch == 0)
            {
              ...
            }
            else
            {
              ....
            }
         
            return 0;
        }",c,,,,,01/04/2012 17:51:24,not a real question,1,383,4,"comparing unequaled int arrays I am new in C and i dont know the syntax well...i use google a lot but am stucked here
with this question: i need to compare between 2 integer unequaled size arryas?
it has to be most efficient - is it posiable O(n)??
print all the difrrent integers

      int compar2arr(int arrA[],int arrB[])
        {
            int i;
            int allMatch = 1;
         
    
            for (int i = 0; i < ARY_SIZE; i++)
            {
                if (arrA[i] != arrB[i])
                {
                    allMatch = 0;
                    break;
                }
            }
         
            if (allMatch == 0)
            {
              ...
            }
            else
            {
              ....
            }
         
            return 0;
        }",1
3847910,10/02/2010 23:24:19,460274,09/19/2010 18:22:01,13,1,Passing 2D arrays in C,"I took a hiatus from C and am just getting back into it again.

If I want to create a 2D array of doubles, I can do it two ways:

    double** m_array = (double**) malloc(2*sizeof(double*));
    double*  m_array = (double*)  malloc(2*sizeof(double));

**OR**

    double array[2][2];

But, when I wish to pass the malloc'd array versus passing the other, there seems to be two conventions:

    //allowed for passing in malloc'd array, but not for other array
    func_m(m_array) //allowed
    func_m(array) //disallowed
    func_m(double** m_array)
    
    //allowed for passing in either array; required for passing in non-malloc'd array
    func(m_array) //allowed
    func(array) //allowed
    func(double array[][2])

In the first, I don't need any information beyond that it is a pointer to an array of pointers. But it can only be a malloc'd array.

In the second, I need to pass the length of each array that the array of double* points to. This seems silly.

Am I missing something? Thanks in advance.",c,pointers,multidimensional-array,argument-passing,,,open,0,186,5,"Passing 2D arrays in C I took a hiatus from C and am just getting back into it again.

If I want to create a 2D array of doubles, I can do it two ways:

    double** m_array = (double**) malloc(2*sizeof(double*));
    double*  m_array = (double*)  malloc(2*sizeof(double));

**OR**

    double array[2][2];

But, when I wish to pass the malloc'd array versus passing the other, there seems to be two conventions:

    //allowed for passing in malloc'd array, but not for other array
    func_m(m_array) //allowed
    func_m(array) //disallowed
    func_m(double** m_array)
    
    //allowed for passing in either array; required for passing in non-malloc'd array
    func(m_array) //allowed
    func(array) //allowed
    func(double array[][2])

In the first, I don't need any information beyond that it is a pointer to an array of pointers. But it can only be a malloc'd array.

In the second, I need to pass the length of each array that the array of double* points to. This seems silly.

Am I missing something? Thanks in advance.",4
11428056,07/11/2012 07:55:00,596881,01/31/2011 13:03:01,66,0,how do I convert SInt16 to double?,"how can I convert SInt16 to double or Float32 to double? I know I can convert SInt16 to Float32 like this:

    double *buffer;
    SInt16* frames;

    for (i=0; i<number_of_frames; i++ ) {

    Float32 currentFrame = frames[i] / 32768.0f;
    }

but I'm using many C functions and I want to pass data to them in double. 
    
Now I use this code:
   
    for (i=0; i<number_of_frames; i++ ) {

    Float32 currentFrame = frames[i] / 32768.0f;

    buffer[i] = currentFrame;
    }
 
but I'm not sure the result is correct..
    
   

    ",c,type-conversion,,,,,open,0,127,7,"how do I convert SInt16 to double? how can I convert SInt16 to double or Float32 to double? I know I can convert SInt16 to Float32 like this:

    double *buffer;
    SInt16* frames;

    for (i=0; i<number_of_frames; i++ ) {

    Float32 currentFrame = frames[i] / 32768.0f;
    }

but I'm using many C functions and I want to pass data to them in double. 
    
Now I use this code:
   
    for (i=0; i<number_of_frames; i++ ) {

    Float32 currentFrame = frames[i] / 32768.0f;

    buffer[i] = currentFrame;
    }
 
but I'm not sure the result is correct..
    
   

    ",2
10738937,05/24/2012 13:57:55,1357506,04/26/2012 00:42:00,109,0,why is a pthread_create return int?,"i have seen code for summation of array using thread .In this created thread return int data type.i knew that thread is the child of process and it uses for executing program.And for Executing program memory is needed .And Memory is return by void*.what is logical reason about int data type. 

    int iret1, iret2;
    
    
    iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1); 
    iret2 = pthread_create( &thread2, NULL, print_message_function, (void*) message2);

can any one explain actual reason?",c,pthreads,,,,,open,0,94,6,"why is a pthread_create return int? i have seen code for summation of array using thread .In this created thread return int data type.i knew that thread is the child of process and it uses for executing program.And for Executing program memory is needed .And Memory is return by void*.what is logical reason about int data type. 

    int iret1, iret2;
    
    
    iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1); 
    iret2 = pthread_create( &thread2, NULL, print_message_function, (void*) message2);

can any one explain actual reason?",2
11654549,07/25/2012 16:39:15,1412921,05/23/2012 14:46:24,53,1,record shop c program,"What's error in my program

This is the program

    /*
     * courseProject.c
     *
     * It is a simple database for record shop
     * to track its iventory of CDs
     *
     * by Mahmoud Emam, 2012.
     */
    #include<stdio.h>
    
    main()
    {
          /*
           * CDs infrormations
           */
          char title[31], artist[31];
          short int numberOfTracks;  /* short to save memory */
          int albumOrSingle;         /* Boolean to check 1 for Album and 0 for Single */
          float price;
          
          printf(""Hello, Welcome to Record Shop!\n\n"");
          /*
           * Asking for CD details
           */
          printf(""Enter CD details\n\n"");
          printf(""CD's Title: "");
          scanf(""%[^\n]"", title);
          fflush(stdin);
          
          printf(""CD's Artist: "");
          scanf(""%[^\n]"", artist);
    
          
          printf(""Number of tracks: "");
          scanf(""%d"", &numberOfTracks);
    
          
          printf(""Please press \""1\"" for album, \""0\"" for single: "");
          scanf(""%d"", &albumOrSingle);
    
          
          printf(""CD's Price: "");
          scanf(""%f"", &price);
    
          /*
           * Output CD details
           */
          printf(""\nCD details:\n"");
          printf(""=============\n\n"");
          
          printf(""CD's Title: <%s>\n"", title);
          printf(""CD's Artist: <%s>\n"", artist);
          printf(""Number of tracks: <%d>\n"", numberOfTracks);
    
          if (albumOrSingle)
             printf(""This is <Album>\n"");
          else
             printf(""This is <Single CD>\n"");
             
          printf(""Its price = <%.2f>\n"", price);
          printf(""=============\n\n"");
          
          /* Exit from program */
          printf(""Press any key to exit\n"");
          
          fflush(stdin);
          getchar();
    }

This is simple program that read CD info from the user and output the details again on the screen.

but **artist** variable always empty why ???
I made `printf(""%s"", artist);` after I read it from user and it work correctly.
But doesn't work at the end of the program. The variable always empty.",c,,,,,07/25/2012 21:18:26,not constructive,1,769,4,"record shop c program What's error in my program

This is the program

    /*
     * courseProject.c
     *
     * It is a simple database for record shop
     * to track its iventory of CDs
     *
     * by Mahmoud Emam, 2012.
     */
    #include<stdio.h>
    
    main()
    {
          /*
           * CDs infrormations
           */
          char title[31], artist[31];
          short int numberOfTracks;  /* short to save memory */
          int albumOrSingle;         /* Boolean to check 1 for Album and 0 for Single */
          float price;
          
          printf(""Hello, Welcome to Record Shop!\n\n"");
          /*
           * Asking for CD details
           */
          printf(""Enter CD details\n\n"");
          printf(""CD's Title: "");
          scanf(""%[^\n]"", title);
          fflush(stdin);
          
          printf(""CD's Artist: "");
          scanf(""%[^\n]"", artist);
    
          
          printf(""Number of tracks: "");
          scanf(""%d"", &numberOfTracks);
    
          
          printf(""Please press \""1\"" for album, \""0\"" for single: "");
          scanf(""%d"", &albumOrSingle);
    
          
          printf(""CD's Price: "");
          scanf(""%f"", &price);
    
          /*
           * Output CD details
           */
          printf(""\nCD details:\n"");
          printf(""=============\n\n"");
          
          printf(""CD's Title: <%s>\n"", title);
          printf(""CD's Artist: <%s>\n"", artist);
          printf(""Number of tracks: <%d>\n"", numberOfTracks);
    
          if (albumOrSingle)
             printf(""This is <Album>\n"");
          else
             printf(""This is <Single CD>\n"");
             
          printf(""Its price = <%.2f>\n"", price);
          printf(""=============\n\n"");
          
          /* Exit from program */
          printf(""Press any key to exit\n"");
          
          fflush(stdin);
          getchar();
    }

This is simple program that read CD info from the user and output the details again on the screen.

but **artist** variable always empty why ???
I made `printf(""%s"", artist);` after I read it from user and it work correctly.
But doesn't work at the end of the program. The variable always empty.",1
2308323,02/22/2010 01:39:51,217476,11/24/2009 01:30:09,285,9,Why no switch on pointers?,"For instance:

    #include <stdio.h>
    
    void why_cant_we_switch_him(void *ptr)
    {
        switch (ptr) {
            case NULL:
                printf(""NULL!\n"");
                break;
            default:
                printf(""%p!\n"", ptr);
                break;
        }
    }
    
    int main(void)
    {
        void *foo = ""toast"";
        why_cant_we_switch_him(foo);
        return 0;
    }

    gcc test.c -o test
    test.c: In function 'why_cant_we_switch_him':
    test.c:5: error: switch quantity not an integer
    test.c:6: error: pointers are not permitted as case values

Just curious. Is this a technical limitation?",c,pointers,switch-statement,limitations,curious,,open,0,220,5,"Why no switch on pointers? For instance:

    #include <stdio.h>
    
    void why_cant_we_switch_him(void *ptr)
    {
        switch (ptr) {
            case NULL:
                printf(""NULL!\n"");
                break;
            default:
                printf(""%p!\n"", ptr);
                break;
        }
    }
    
    int main(void)
    {
        void *foo = ""toast"";
        why_cant_we_switch_him(foo);
        return 0;
    }

    gcc test.c -o test
    test.c: In function 'why_cant_we_switch_him':
    test.c:5: error: switch quantity not an integer
    test.c:6: error: pointers are not permitted as case values

Just curious. Is this a technical limitation?",5
9371819,02/21/2012 03:36:26,720094,11/24/2010 16:55:13,236,6,Typecasting Unsigned Long Long to c Character Pointer in C,"I have a legacy code which contains the following code logic:

    unsigned long long address; /* Its content = Some Address, not a normal value */
    
    strcmp (address, (const char*)some_char_buffer);

This gives warning with gcc.

Can somebody suggest some way of typecasting the variable 'address' into a char pointer so that it can be decoded properly and gcc gives no warning.

Thanks.

Best Regards,

Sandeep Singh

",c,pointers,,,,,open,0,71,10,"Typecasting Unsigned Long Long to c Character Pointer in C I have a legacy code which contains the following code logic:

    unsigned long long address; /* Its content = Some Address, not a normal value */
    
    strcmp (address, (const char*)some_char_buffer);

This gives warning with gcc.

Can somebody suggest some way of typecasting the variable 'address' into a char pointer so that it can be decoded properly and gcc gives no warning.

Thanks.

Best Regards,

Sandeep Singh

",2
1059372,06/29/2009 17:05:10,84336,03/29/2009 19:17:00,152,11,C++ code and objects from C?,"Is there a simple way to work with C++ objects directly from C?
I want to expose some classes from C++ to C or to FFI(foreign function interface).
Sure, I can write a stuff like that:

    class Foo{
    ....
    };

    void *make_foo(...){
    Foo *ptr = new Foo(..)
    
    return static_cast<void *>(ptr);
    }

    ..

    int *foo_method1(void *fooptr, ...){
    Foo *ptr = static_cast<Foo*>(fooptr);
    }


But there is a simpler method?",c,c++,lisp,,,,open,0,101,6,"C++ code and objects from C? Is there a simple way to work with C++ objects directly from C?
I want to expose some classes from C++ to C or to FFI(foreign function interface).
Sure, I can write a stuff like that:

    class Foo{
    ....
    };

    void *make_foo(...){
    Foo *ptr = new Foo(..)
    
    return static_cast<void *>(ptr);
    }

    ..

    int *foo_method1(void *fooptr, ...){
    Foo *ptr = static_cast<Foo*>(fooptr);
    }


But there is a simpler method?",3
9700608,03/14/2012 10:58:58,1071138,11/29/2011 11:05:15,11,0,MULTIPROCESS SERVER OR MULTITHREAD SERVER?,Hi' i'm writing a simple client server in C. What are advantages of making a multiprocess server instead of a multithread one?,c,multithreading,multiprocessing,,,03/14/2012 12:03:37,not a real question,1,22,5,MULTIPROCESS SERVER OR MULTITHREAD SERVER? Hi' i'm writing a simple client server in C. What are advantages of making a multiprocess server instead of a multithread one?,3
6107975,05/24/2011 08:55:34,628445,02/22/2011 14:08:17,41,0,Can you explain what extern means and some other things?,"I know that extern C means the function should be compiled in C style however what does just extern function_datatype functionname mean?

    extern void sharelog(const char *rem_host, const char *username,
		     const char *, const char *,
		     const char *, const char *);

What does extern without ""C"" mean? 

Also, in almost every program's header files i see something along the lines of

    void sharelog(const char *rem_host, const char *username,
		     const char *, const char *,
		     const char *, const char *);

Why declare the function again if it's been done in the .c/.cpp file?
It's also sometimes declared without it's argument just

    int Function;

Also, some functions can be written like this:

    int CSomething::Somefunction() const

Why add const after the function?

I've also stumbled across functions which have these mysterious dots

    void function(int prio, const char *fmt, ...)

There were a lot of other things i also wanted to ask, however it seems i already asked enough.
I know some of you will probably say to go learn C/C++, however believe me, these stuff are not discussed for beginners.",c,,,,,05/24/2011 11:05:57,not a real question,1,202,10,"Can you explain what extern means and some other things? I know that extern C means the function should be compiled in C style however what does just extern function_datatype functionname mean?

    extern void sharelog(const char *rem_host, const char *username,
		     const char *, const char *,
		     const char *, const char *);

What does extern without ""C"" mean? 

Also, in almost every program's header files i see something along the lines of

    void sharelog(const char *rem_host, const char *username,
		     const char *, const char *,
		     const char *, const char *);

Why declare the function again if it's been done in the .c/.cpp file?
It's also sometimes declared without it's argument just

    int Function;

Also, some functions can be written like this:

    int CSomething::Somefunction() const

Why add const after the function?

I've also stumbled across functions which have these mysterious dots

    void function(int prio, const char *fmt, ...)

There were a lot of other things i also wanted to ask, however it seems i already asked enough.
I know some of you will probably say to go learn C/C++, however believe me, these stuff are not discussed for beginners.",1
8707102,01/03/2012 01:49:24,236924,12/22/2009 14:50:13,906,9,C: server and client,"Hi I am looking at this code and trying to figure out what this does. I believe there are some bugs with it so that's why it is not running. What is it trying to do exactly and how can I get it to run properly?


    /* client.c */
    #include <stdio.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <netinet/in.h>
    
    #define BUFSIZE 512
    
    int main(int argc, char *argv[]) {
    
      int sockfd;
      struct sockaddr_in servaddr;
    
      if (argc != 3) {
        perror(""Usage: client <host> <port>"");
        return 1;
      }
    
      if ((sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) < 0) {
        perror(""Cannot create socket"");
        return 2;
      }
    
      memset(&servaddr,0,sizeof(servaddr));
      servaddr.sin_family = AF_INET;
      servaddr.sin_addr.s_addr = inet_addr(argv[1]);
      servaddr.sin_port = htons(atoi(argv[2]));
    
      if (connect(sockfd,(struct sockaddr *) &servaddr,sizeof(servaddr)) < 0) {
        perror(""Cannot connect to server"");
        return 3;
      }
    
      {
        int n;
        char bytes[BUFSIZE-1];
        while((n = read(sockfd,bytes,BUFSIZE)) > 0) {
          fwrite(bytes,n,sizeof(char),stdout);
        }
      }
    
      return 1;
    }


Below is server.c.

    /* server.c */
    #include <stdio.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <netinet/in.h>
    
    #define MAXOPEN 5
    #define BUFSIZE 1024
    
    int main(int argc, char *argv[]) {
    
      int listenfd, connfd;
      FILE *fp;
      struct sockaddr_in server;
    
      if (argc != 2) {
        puts(""Usage: server <port> <file>"");
        return 1;
      }
    
      if ((fp=fopen(argv[2],""rb"")) == 0) {
        perror(""Cannot find file to serve"");
        return 2;
      }
    
      memset(&server,0,sizeof(server));
      server.sin_family = AF_INET;
      server.sin_addr.s_addr = htonl(INADDR_ANY);
      server.sin_port = htons(atoi(argv[1]));
    
      if ((listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        perror(""Cannot create server socket"");
        return 3;
      }
    
      if (bind(listenfd, (struct sockaddr *) &server, sizeof(server)) < 0) {
        perror(""Cannot open the interface"");
        return 4;
      }      
            
      if (listen(listenfd,MAXOPEN) < 0) {
        perror(""Cannot listen on the interface"");
        return 5;
      } 
        
      for(;;) {
        
        if ( (connfd = accept(listenfd, (struct sockaddr *) NULL, NULL)) < 0 ) {
          perror(""Error accepting a client connection"");
          return 6;
        }
        
        while(!feof(fp)) {
          char bytes[BUFSIZE];
          int r,w;
    
          r = fread(bytes,sizeof(char),BUFSIZE,fp);
    
          while(w<r) {
            int total = write(connfd,bytes,r);
            if (total < 0) {
              perror(""Error writing data to client"");
              return 7;
            }
            w+=total;
          }
        }
        fseek(fp,0,SEEK_SET);
    
        close(connfd);
    
        return 0;
    }

",c,,,,,01/03/2012 01:55:25,not a real question,1,1016,4,"C: server and client Hi I am looking at this code and trying to figure out what this does. I believe there are some bugs with it so that's why it is not running. What is it trying to do exactly and how can I get it to run properly?


    /* client.c */
    #include <stdio.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <netinet/in.h>
    
    #define BUFSIZE 512
    
    int main(int argc, char *argv[]) {
    
      int sockfd;
      struct sockaddr_in servaddr;
    
      if (argc != 3) {
        perror(""Usage: client <host> <port>"");
        return 1;
      }
    
      if ((sockfd = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) < 0) {
        perror(""Cannot create socket"");
        return 2;
      }
    
      memset(&servaddr,0,sizeof(servaddr));
      servaddr.sin_family = AF_INET;
      servaddr.sin_addr.s_addr = inet_addr(argv[1]);
      servaddr.sin_port = htons(atoi(argv[2]));
    
      if (connect(sockfd,(struct sockaddr *) &servaddr,sizeof(servaddr)) < 0) {
        perror(""Cannot connect to server"");
        return 3;
      }
    
      {
        int n;
        char bytes[BUFSIZE-1];
        while((n = read(sockfd,bytes,BUFSIZE)) > 0) {
          fwrite(bytes,n,sizeof(char),stdout);
        }
      }
    
      return 1;
    }


Below is server.c.

    /* server.c */
    #include <stdio.h>
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <stdlib.h>
    #include <string.h>
    #include <unistd.h>
    #include <netinet/in.h>
    
    #define MAXOPEN 5
    #define BUFSIZE 1024
    
    int main(int argc, char *argv[]) {
    
      int listenfd, connfd;
      FILE *fp;
      struct sockaddr_in server;
    
      if (argc != 2) {
        puts(""Usage: server <port> <file>"");
        return 1;
      }
    
      if ((fp=fopen(argv[2],""rb"")) == 0) {
        perror(""Cannot find file to serve"");
        return 2;
      }
    
      memset(&server,0,sizeof(server));
      server.sin_family = AF_INET;
      server.sin_addr.s_addr = htonl(INADDR_ANY);
      server.sin_port = htons(atoi(argv[1]));
    
      if ((listenfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {
        perror(""Cannot create server socket"");
        return 3;
      }
    
      if (bind(listenfd, (struct sockaddr *) &server, sizeof(server)) < 0) {
        perror(""Cannot open the interface"");
        return 4;
      }      
            
      if (listen(listenfd,MAXOPEN) < 0) {
        perror(""Cannot listen on the interface"");
        return 5;
      } 
        
      for(;;) {
        
        if ( (connfd = accept(listenfd, (struct sockaddr *) NULL, NULL)) < 0 ) {
          perror(""Error accepting a client connection"");
          return 6;
        }
        
        while(!feof(fp)) {
          char bytes[BUFSIZE];
          int r,w;
    
          r = fread(bytes,sizeof(char),BUFSIZE,fp);
    
          while(w<r) {
            int total = write(connfd,bytes,r);
            if (total < 0) {
              perror(""Error writing data to client"");
              return 7;
            }
            w+=total;
          }
        }
        fseek(fp,0,SEEK_SET);
    
        close(connfd);
    
        return 0;
    }

",1
7227615,08/29/2011 08:07:17,917404,08/29/2011 08:07:17,1,0,Pros/cons of different ways accessing of C struct members,"http://stackoverflow.com/questions/1784652/structs-interface and http://stackoverflow.com/questions/2672015/hiding-members-in-a-c-struct discusses various ways in accessing /modifying members.

What would be pros/cons of using:

 1. Opaque handle to struct and setters/getters
 2. Accessing members directly
 3. foo.value(&foo, value) functions (like C++ class methods)
 4. Separate header files for same struct exposing public members for client and all members internally

In my case, I'm doing OOP in C and all my structs hold a list of properties (id, name, desc, ...). I need to track changes so that changed status could be transmitted over network. The best way, as I see it, would be to transmit the delta (changes between individual members) and not retransmitting the whole struct.

Thank you",c,interface,struct,members,,08/29/2011 15:23:09,not constructive,1,108,9,"Pros/cons of different ways accessing of C struct members http://stackoverflow.com/questions/1784652/structs-interface and http://stackoverflow.com/questions/2672015/hiding-members-in-a-c-struct discusses various ways in accessing /modifying members.

What would be pros/cons of using:

 1. Opaque handle to struct and setters/getters
 2. Accessing members directly
 3. foo.value(&foo, value) functions (like C++ class methods)
 4. Separate header files for same struct exposing public members for client and all members internally

In my case, I'm doing OOP in C and all my structs hold a list of properties (id, name, desc, ...). I need to track changes so that changed status could be transmitted over network. The best way, as I see it, would be to transmit the delta (changes between individual members) and not retransmitting the whole struct.

Thank you",4
7071807,08/15/2011 23:04:01,895740,08/15/2011 22:54:22,1,0,How can I write this Objective C program correctly?,"In need some help with this little programming .. I just got 3 errors ..

:'(

**[

    #include <stdio.h>
    int main (void)
    {
    char A , B , C , D , E , F;
    float id1[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float grade[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float marks[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float average;
    float num1, kk=0;
    /********* Jami, Abdulrahman *********/
    printf(""Enter The Student ID: "");
    scanf(""%d"", &num1);
    for (kk=0; kk<num1; kk++);
    {
    scanf(""%d"", &id1[kk]);
    scanf(""%d"", &grade[kk]);
    }
    for (kk=0; kk<num1; kk++);
    {
    if (grade [kk]>85 &grade [kk]<=100);
    A=A+1;
    
    if (grade [kk]>70 &grade [kk]<85);
    B=B+1;

    if (grade [kk]>55 &grade [kk]<70);
    C=C+1;

    if (grade [kk]>40 &grade [kk]<55);
    D=D+1;

    if (grade [kk]>25 &grade [kk]<40);
    E=E+1;

    if (grade [kk]>=0 &grade [kk]<25);
    F=F+1;
    }
    /********* Jami, Abdulrahman *********/
    float aveerage;
    float avrg, sum, lk;

    sum = sum + marks[lk];
    average = sum / num1;

    for (lk=0; lk<num1; lk++);

    return average;
    }

]**",c,arrays,,,,08/16/2011 23:56:55,not a real question,1,300,9,"How can I write this Objective C program correctly? In need some help with this little programming .. I just got 3 errors ..

:'(

**[

    #include <stdio.h>
    int main (void)
    {
    char A , B , C , D , E , F;
    float id1[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float grade[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float marks[]; <<< *Definition of variable with array type needs an explicit size or an initializer*
    float average;
    float num1, kk=0;
    /********* Jami, Abdulrahman *********/
    printf(""Enter The Student ID: "");
    scanf(""%d"", &num1);
    for (kk=0; kk<num1; kk++);
    {
    scanf(""%d"", &id1[kk]);
    scanf(""%d"", &grade[kk]);
    }
    for (kk=0; kk<num1; kk++);
    {
    if (grade [kk]>85 &grade [kk]<=100);
    A=A+1;
    
    if (grade [kk]>70 &grade [kk]<85);
    B=B+1;

    if (grade [kk]>55 &grade [kk]<70);
    C=C+1;

    if (grade [kk]>40 &grade [kk]<55);
    D=D+1;

    if (grade [kk]>25 &grade [kk]<40);
    E=E+1;

    if (grade [kk]>=0 &grade [kk]<25);
    F=F+1;
    }
    /********* Jami, Abdulrahman *********/
    float aveerage;
    float avrg, sum, lk;

    sum = sum + marks[lk];
    average = sum / num1;

    for (lk=0; lk<num1; lk++);

    return average;
    }

]**",2
2623731,04/12/2010 16:45:12,313328,04/10/2010 05:22:21,1,2,"difference between pass by value result and pass by reference with c,c++ examples....","difference between pass by value result and pass by reference with c,c++ examples....",c,c++,,,,04/12/2010 16:47:47,not a real question,1,13,13,"difference between pass by value result and pass by reference with c,c++ examples.... difference between pass by value result and pass by reference with c,c++ examples....",2
9779376,03/19/2012 23:21:18,979012,10/04/2011 17:44:35,21,1,C Multithreading Deadlock's Thread Events,"I am trying to perform multithreading on a socket in C in order to develop a connector between two different software applications. I would like it to work in the following manner. One piece of software will start running as the server, it will be performing a variety of functions including listening for a socket connection on a designated port. This software will function by it self and only use data from the connected network socket when it is established and receiving reliable data. So for this piece I would like to be able to listen to a connection, and when one is made fork a process and when data is received from this socket set some variable that will be used by some other update thread to notify it that it has these extra precision information that can be considered. On the other side of this equation I want to create a program that when it boots up will attempt to connect to the port of the other application, once this connects it will then simply call a function that will send out the information in non blocking fashion. My whole goal is to create a connector that will allow the programmers of the other two pieces of code to feel as tho they aren't dealing with a socket what so ever.
      I have been able to get multi threaded socket communication going but I am now trying to modify this so it will be usable as I have described and I am confused as to how to avoid multiple access to that variable that will notify the system on the server side that the data has arrived as well as create the non-blocking interaction on the client side. Any help ill be appreciated.
-TJ
",c,multithreading,sockets,nonblocking,,,open,0,300,5,"C Multithreading Deadlock's Thread Events I am trying to perform multithreading on a socket in C in order to develop a connector between two different software applications. I would like it to work in the following manner. One piece of software will start running as the server, it will be performing a variety of functions including listening for a socket connection on a designated port. This software will function by it self and only use data from the connected network socket when it is established and receiving reliable data. So for this piece I would like to be able to listen to a connection, and when one is made fork a process and when data is received from this socket set some variable that will be used by some other update thread to notify it that it has these extra precision information that can be considered. On the other side of this equation I want to create a program that when it boots up will attempt to connect to the port of the other application, once this connects it will then simply call a function that will send out the information in non blocking fashion. My whole goal is to create a connector that will allow the programmers of the other two pieces of code to feel as tho they aren't dealing with a socket what so ever.
      I have been able to get multi threaded socket communication going but I am now trying to modify this so it will be usable as I have described and I am confused as to how to avoid multiple access to that variable that will notify the system on the server side that the data has arrived as well as create the non-blocking interaction on the client side. Any help ill be appreciated.
-TJ
",4
8089423,11/11/2011 03:44:32,1033335,11/07/2011 07:31:23,11,0,static variable in c annoying,"    #include<stdio.h>
    main()
    {
	int x=5;
	int f=staticdemo(&x);
	printf(""%d\n"",f);
	x=8;
	int u=staticdemo(&x);
	printf(""%d\n"",u);

    } 
    int staticdemo(int *a)
	{
		//static int j=0;
		static int j;
		j=0;
		j+=*a;
		return j;
	}

output would be 
5
8

if i used the following function i get output as 5 and 13
    
    int staticdemo(int *a)
    {
		static int j=0;
		j+=*a;
		return j;
	}

I know static variables are  used for permanent storage but its annoying to see with my scenario.",c,pointers,,,,11/11/2011 03:50:46,not a real question,1,81,5,"static variable in c annoying     #include<stdio.h>
    main()
    {
	int x=5;
	int f=staticdemo(&x);
	printf(""%d\n"",f);
	x=8;
	int u=staticdemo(&x);
	printf(""%d\n"",u);

    } 
    int staticdemo(int *a)
	{
		//static int j=0;
		static int j;
		j=0;
		j+=*a;
		return j;
	}

output would be 
5
8

if i used the following function i get output as 5 and 13
    
    int staticdemo(int *a)
    {
		static int j=0;
		j+=*a;
		return j;
	}

I know static variables are  used for permanent storage but its annoying to see with my scenario.",2
4985861,02/13/2011 18:03:29,615286,02/13/2011 18:03:29,1,0,bmp file processing,"can some help write a code in c to get 24 bit bmp pixel values into 2d array for processing of it 
thnx in advance ",c,,,,,02/13/2011 18:19:05,not a real question,1,26,3,"bmp file processing can some help write a code in c to get 24 bit bmp pixel values into 2d array for processing of it 
thnx in advance ",1
1666481,11/03/2009 10:27:02,201423,11/03/2009 06:01:16,1,0,How can i run c program in dos prompt,I want to run c program in dos prompt .Is it Possible,c,in,dos,prompt,,02/22/2012 14:58:36,not a real question,1,12,9,How can i run c program in dos prompt I want to run c program in dos prompt .Is it Possible,4
4735398,01/19/2011 12:47:01,578557,01/17/2011 13:07:59,1,1,history of programming language names?,"do anyone know the history of programming language names? where they come from?
a,b,c, java, python, scheme, prolog, ada, fortran, algol, cobol, assembly, pascal, lisp, perl, haskell, php, javascript, c#, ruby, c++ and so on.
",c,programming-languages,lisp,history,,01/19/2011 12:52:51,off topic,1,34,5,"history of programming language names? do anyone know the history of programming language names? where they come from?
a,b,c, java, python, scheme, prolog, ada, fortran, algol, cobol, assembly, pascal, lisp, perl, haskell, php, javascript, c#, ruby, c++ and so on.
",4
7510621,09/22/2011 06:42:43,615116,02/13/2011 14:32:37,92,2,I there a good ruby book for learning sockets programming?,"Is there a good book for ruby sockets programming or we have to rely on Unix C books for theory and source ?.

",c,ruby,sockets,unix,socket.io,12/05/2011 07:48:07,off topic,1,23,10,"I there a good ruby book for learning sockets programming? Is there a good book for ruby sockets programming or we have to rely on Unix C books for theory and source ?.

",5
8920046,01/19/2012 01:41:20,1073652,11/30/2011 15:19:47,93,2,Large number store in float type in C,"The problem I got is if I assign a large number to a float type, for example, `float f = 1.0e20` then I print it to the screen with `printf(""f = %f\n"",f)`, then on the screen it will be `f = 100000002004087730000.000000`. Could anyone tell me why the number display is not `100000000000000000000.000000`. Thanks in advance.
",c,,,,,01/19/2012 01:59:50,not a real question,1,56,8,"Large number store in float type in C The problem I got is if I assign a large number to a float type, for example, `float f = 1.0e20` then I print it to the screen with `printf(""f = %f\n"",f)`, then on the screen it will be `f = 100000002004087730000.000000`. Could anyone tell me why the number display is not `100000000000000000000.000000`. Thanks in advance.
",1
8212221,11/21/2011 13:01:09,1057815,11/21/2011 12:53:51,1,0,Merge Sort with compare function,"I need to write a merge sort algorithm in C which does not use an in built function from the C library. I have found hundreds of merge sort algorithms but not which take a comparison function as an argument as the built in mergesort and qsort algorithms do in C.
The algorithm must sort a Struct of books and sort them by price, star-rating, or relevance depending on which compare function is passed into the algorithm. Can anyone help with an algorithm which will work in this situation?

",c,sorting,struct,mergesort,,11/21/2011 13:20:50,not a real question,1,88,5,"Merge Sort with compare function I need to write a merge sort algorithm in C which does not use an in built function from the C library. I have found hundreds of merge sort algorithms but not which take a comparison function as an argument as the built in mergesort and qsort algorithms do in C.
The algorithm must sort a Struct of books and sort them by price, star-rating, or relevance depending on which compare function is passed into the algorithm. Can anyone help with an algorithm which will work in this situation?

",4
3941793,10/15/2010 11:30:05,104021,05/09/2009 10:18:32,2651,104,What is guaranteed about the size of a function pointer?,"In C, I need to know the size of a struct, which has function pointers in it. Can I be guaranteed that on all platforms and architectures:

- the size of a void* is the same size as a function pointer?
- the size of the function pointer does not differ due to its return type?
- the size of the function pointer does not differ due to its parameter types?

I assume the answer is yes to all of these, but I want to be sure. For context, I'm calling `sizeof(struct mystruct)` and nothing more.",c,pointers,type-conversion,function-pointers,sizeof,,open,0,92,10,"What is guaranteed about the size of a function pointer? In C, I need to know the size of a struct, which has function pointers in it. Can I be guaranteed that on all platforms and architectures:

- the size of a void* is the same size as a function pointer?
- the size of the function pointer does not differ due to its return type?
- the size of the function pointer does not differ due to its parameter types?

I assume the answer is yes to all of these, but I want to be sure. For context, I'm calling `sizeof(struct mystruct)` and nothing more.",5
11255064,06/29/2012 01:40:16,420540,08/14/2010 18:13:20,139,3,wait for gdb to attach,"I've been using gdb normally for 1 or 2 projects. I.e. I invoke `gdb --args prog args` . gdb runs in the same tty as the program I'm debugging.

However my latest project is modifying the dtach utility. This is a program like screen, so the tty's are redirected elsewhere, thus I have to use gdb's attach functionality.

The problem with gdb attach is that obviously you can't attach from the very beginning as you need to run the program first in order to get a pid to attach to.

Is there any way I can get a program to wait at a point until gdb is attached?

I can't use gdbserver as I'm on cygwin. Also I tried using `pause()`, but that just hung when I tried to continue.",c,debugging,gdb,cygwin,,,open,0,126,5,"wait for gdb to attach I've been using gdb normally for 1 or 2 projects. I.e. I invoke `gdb --args prog args` . gdb runs in the same tty as the program I'm debugging.

However my latest project is modifying the dtach utility. This is a program like screen, so the tty's are redirected elsewhere, thus I have to use gdb's attach functionality.

The problem with gdb attach is that obviously you can't attach from the very beginning as you need to run the program first in order to get a pid to attach to.

Is there any way I can get a program to wait at a point until gdb is attached?

I can't use gdbserver as I'm on cygwin. Also I tried using `pause()`, but that just hung when I tried to continue.",4
7162454,08/23/2011 14:15:50,903683,08/20/2011 11:24:03,1,0,circular shifting in c,"----

I'm looking for algorithm that implements a circular shifting to the left of bit binary number
(in c language).
The algorithm will act like >> The right slot will be filled not with zeros but with the numbers moved from left.

and for shifting to the right.

",c,,,,,08/23/2011 14:21:57,not constructive,1,44,4,"circular shifting in c ----

I'm looking for algorithm that implements a circular shifting to the left of bit binary number
(in c language).
The algorithm will act like >> The right slot will be filled not with zeros but with the numbers moved from left.

and for shifting to the right.

",1
4634691,01/08/2011 15:54:13,411768,08/05/2010 09:20:27,351,7,Fastest method (in C) for integer multiplication by school method,"we know various algorithms for the multiplication of big integers. Usually, the algorithms with asymptotically best run-time unveil their power only at very large instances. For smaller instances, you likely switch to some asymptotically slower algorithm, which does not utilize so much overhead.

Now, at the very end, you will use multiplication by school method for small instances. What is the best implementation for this (preferably in C).

We assume our digits are given in long integers

    typedef long digit

My implementation so far for input numbers (A,B) is like:

    void Multbyschoolmethod( int k, const digit* a, const digit* b, digit* p )
      {
        
        // each big integer has power of two length
        // a,b assumed to have length 'length'
        // p assumed to have length '2*length'
        int length = 1 << k;
        
        // zero the output digits
        makedigitszero( length*2, p );
        
        // place to save overflows that appear during additions
        digit overflows[2*length];
        makedigitszero( length*2, overflows );
    
        // main part -- cycle all pairs of digits
        for( int i = 0; i < length; i++ )
        for( int j = 0; j < length; j++ ){
            
            long long w1 = a[i];
            long long w2 = b[j];
            long long w3 = w1*w2;
            bool carry  = false;
            
            // add w3, big integer of size 2, to the digits of p at i+j
            // and save whether overflow occured
            addition( 2, p+(i+j), (digit*)&w3, &carry );
            // in case of overflow, update overflow array
            if(carry) overflows[i+j+2]++;
            
        }
        
        // add all the carrys */
        bool carry = false;
        addition( 2*length, p, overflows, &carry );
        assert(!carry);
        
      }",c,biginteger,multiplication,,,01/08/2011 16:15:36,not a real question,1,573,10,"Fastest method (in C) for integer multiplication by school method we know various algorithms for the multiplication of big integers. Usually, the algorithms with asymptotically best run-time unveil their power only at very large instances. For smaller instances, you likely switch to some asymptotically slower algorithm, which does not utilize so much overhead.

Now, at the very end, you will use multiplication by school method for small instances. What is the best implementation for this (preferably in C).

We assume our digits are given in long integers

    typedef long digit

My implementation so far for input numbers (A,B) is like:

    void Multbyschoolmethod( int k, const digit* a, const digit* b, digit* p )
      {
        
        // each big integer has power of two length
        // a,b assumed to have length 'length'
        // p assumed to have length '2*length'
        int length = 1 << k;
        
        // zero the output digits
        makedigitszero( length*2, p );
        
        // place to save overflows that appear during additions
        digit overflows[2*length];
        makedigitszero( length*2, overflows );
    
        // main part -- cycle all pairs of digits
        for( int i = 0; i < length; i++ )
        for( int j = 0; j < length; j++ ){
            
            long long w1 = a[i];
            long long w2 = b[j];
            long long w3 = w1*w2;
            bool carry  = false;
            
            // add w3, big integer of size 2, to the digits of p at i+j
            // and save whether overflow occured
            addition( 2, p+(i+j), (digit*)&w3, &carry );
            // in case of overflow, update overflow array
            if(carry) overflows[i+j+2]++;
            
        }
        
        // add all the carrys */
        bool carry = false;
        addition( 2*length, p, overflows, &carry );
        assert(!carry);
        
      }",3
9011725,01/25/2012 23:03:04,1031904,11/06/2011 06:31:14,39,0,C Program returns same result always,"I'm making a program to calculate flowrate but everytime you enter in the variables when the program is excecuted, it returns the same result every time. I don't remember what the result was and I can't check because I'm not on my linux but I have the whole source code for the program here:

    #include <stdio.h>
    #include <math.h>
    #include ""PI.h""

    int flowRateFormula(int,int);	//Finally, finds out the flow rate
    int square(int);		

    int square(int x)
    {
	x=pow(x,2);

	return x;
    }

    int flowRateFormula(int pipeDiameter,int velocity)
    {
	int integer3=0.25*(PI*square(pipeDiameter)*velocity);

	return integer3;

    }

    int main()
    {
	int flowRate;
	int velocity;
	int pipeDiameter;
	

	printf(""Enter velocity of liquid(in./s):"");
	scanf(""%d"",&velocity);
	printf(""Velocity=%d in/s.\n"",velocity);
	
	printf(""Enter pipe diameter(inches):"");
	scanf(""%d"",&pipeDiameter);
	printf(""Pipe Diameter=%d inches.\n"",pipeDiameter);

	printf(""Applying formula for Flow Rate.........\n"");
	flowRate=flowRateFormula(pipeDiameter,velocity);

	printf(""Pipe Diameter=%d inches.\n"",pipeDiameter);

	printf(""Velocity of liquid=%d in/s.\n"",velocity);

	printf(""Thus, the flow rate=%d ft/s.\n"",flowRate);

	return 0;
    }
",c,function,output,,,01/26/2012 00:20:28,too localized,1,154,6,"C Program returns same result always I'm making a program to calculate flowrate but everytime you enter in the variables when the program is excecuted, it returns the same result every time. I don't remember what the result was and I can't check because I'm not on my linux but I have the whole source code for the program here:

    #include <stdio.h>
    #include <math.h>
    #include ""PI.h""

    int flowRateFormula(int,int);	//Finally, finds out the flow rate
    int square(int);		

    int square(int x)
    {
	x=pow(x,2);

	return x;
    }

    int flowRateFormula(int pipeDiameter,int velocity)
    {
	int integer3=0.25*(PI*square(pipeDiameter)*velocity);

	return integer3;

    }

    int main()
    {
	int flowRate;
	int velocity;
	int pipeDiameter;
	

	printf(""Enter velocity of liquid(in./s):"");
	scanf(""%d"",&velocity);
	printf(""Velocity=%d in/s.\n"",velocity);
	
	printf(""Enter pipe diameter(inches):"");
	scanf(""%d"",&pipeDiameter);
	printf(""Pipe Diameter=%d inches.\n"",pipeDiameter);

	printf(""Applying formula for Flow Rate.........\n"");
	flowRate=flowRateFormula(pipeDiameter,velocity);

	printf(""Pipe Diameter=%d inches.\n"",pipeDiameter);

	printf(""Velocity of liquid=%d in/s.\n"",velocity);

	printf(""Thus, the flow rate=%d ft/s.\n"",flowRate);

	return 0;
    }
",3
10518130,05/09/2012 14:26:03,1384595,05/09/2012 12:35:21,1,0,Coding tic tac toe in C,"I'm coding a game of tic tac toe in C. Here's the logic. The User goes first, selects a slot. The positions of the slot are calculated using simple formulae. Then the selected slot is filled. Next, the computer selects a slot, randomly. For this, i've used the rand() function, in stdlib.h. Initially, all elements of the 3x3 matrix are set at 0. My problem is, even if all the other elements are 0, and the user selects slot 5 or slot 9, the user wins. Same thing for the comp also. Here's my code-

    #include<stdio.h>
    #include<stdlib.h>
    int check(int[][3]);
    void print(int[][3]);
    main()
    {
     int i,j,match[3][3]={0},posx,posy,comp_posx,comp_posy,fill=0,slot,user_score=0,comp_score=0;
     char ch;
     srand(time(NULL));
     do
     {
      while(fill<9)
      {
       printf(""\nEnter the slot you want to fill.\n"");
       scanf(""%d"",&slot);
       if (slot > 9)
       {
        printf(""Error!\nSlot value cannot exceed 9.\n"");
        continue;
       }
       else if( slot >= 1&&slot <=3)
       {
        posx=0;
        posy=slot-1;
       }
       else if (slot >= 4 && slot <= 6)
       {
        posx=1;
        posy=slot-4;
       }
       else
       {
        posx=2;
        posy=slot-7;
       }
       if (match[posx][posy] == 0)
       {
        match[posx][posy]=1;
        fill++;
        check(match);
        if(check(match)==1)
        {
         printf(""The user wins!\n"");
         user_score++;
         print(match);
         break;
        }
        else if(check(match)==-1)
        {
         printf(""The computer wins!\n"");
         comp_score++;
         print(match);
        }
        else
        {
         if(fill==9)
         {
          printf(""It's a draw!\n"");
          print(match);
          break;
         }
         else
         {
          printf("" "");
         }
        }
       }
       else
       {
        printf(""Sorry! This slot is already filled.\nPlease pick another slot.\n"");
        continue;
       }
       label:
       comp_posx=rand()%3;
       comp_posy=rand()%3;
       if(match[comp_posx][comp_posy]==0)
       {
        match[comp_posx][comp_posy]=-1;
        fill++;
        check(match);
        if (check(match)==1)
        {
         printf(""The user wins!\n"");
         user_score++;
         print(match);
         break;
        }
        else if(check(match)==-1)
        {
         printf(""The computer wins!\n"");
         comp_score++;
         print(match);
         break;
        }
        else
        {
         if (fill==9)
         {
          printf(""It's a draw!\n"");
          print(match);
          break;
         }
         else
         {
          printf("" "");
         }
        }
       }
       else
       goto label;
       for(i=0;i<3;i++)
       {
        printf(""\n"");
        for(j=0;j<3;j++)
        {
        printf(""%d\t"",match[i][j]);
        }
       }
      }
      for(i=0;i<3;i++)
      {
       for(j=0;j<3;j++)
       {
        match[i][j]=0;
       }
      }
      printf(""Continue? Y/N\n"");
      scanf(""%c %c"",&ch,&ch);
     }
     while(ch=='y'||ch=='Y');
     printf(""FINAL SCORES>>\nUser=%d\nComputer=%d\n"",user_score,comp_score);
    }
    int check(int match[][3])
    {
     int i,j;
     if( match[2][0]==match[1][1] && match[1][1]==match[0][2] )
     {
      if (match[0][2]==1)
      return 1;
      else if (match[0][2]==-1)
      return -1;
      else
      printf("" "");
     }
     for(i=0;i<3;i++)
     {
      if (match[i][0]==match[i][1]&&match[i][1]==match[i][2])
      {
       if(match[i][1]==1)
       return 1;
       else if(match[i][1]==-1)
       return -1;
       else
       continue;
      }
     }
     for(j=0;j<3;j++)
     {
      if(match[0][j]==match[1][j]&&match[0][j]==match[2][j])
      {
       if (match[0][j]==1)
       return 1;
       else if(match[0][j]==-1)
       return -1;
       else
       continue;
      }
     }
     for (i=0;i<1;i++)
     {
      if(match[i][i]==match[i+1][i+1]&&match[i][i]==match[i+2][i+2])
      {
       if (match[i][i]==1)
       return 1;
       else if (match[i][i]==-1)       return -1;
      else continue;
      }
     }
    }
     void print(int match[][3])
     {
      int i,j;
      for(i=0;i<3;i++)
      {
       printf(""\n"");
       for(j=0;j<3;j++)
       {
        printf(""%d\t"",match[i][j]);
       }
      }
     }
Can You suggest changes in the code, so that i won't have those problems?
",c,tictactoe,,,,05/10/2012 04:00:27,too localized,1,1559,6,"Coding tic tac toe in C I'm coding a game of tic tac toe in C. Here's the logic. The User goes first, selects a slot. The positions of the slot are calculated using simple formulae. Then the selected slot is filled. Next, the computer selects a slot, randomly. For this, i've used the rand() function, in stdlib.h. Initially, all elements of the 3x3 matrix are set at 0. My problem is, even if all the other elements are 0, and the user selects slot 5 or slot 9, the user wins. Same thing for the comp also. Here's my code-

    #include<stdio.h>
    #include<stdlib.h>
    int check(int[][3]);
    void print(int[][3]);
    main()
    {
     int i,j,match[3][3]={0},posx,posy,comp_posx,comp_posy,fill=0,slot,user_score=0,comp_score=0;
     char ch;
     srand(time(NULL));
     do
     {
      while(fill<9)
      {
       printf(""\nEnter the slot you want to fill.\n"");
       scanf(""%d"",&slot);
       if (slot > 9)
       {
        printf(""Error!\nSlot value cannot exceed 9.\n"");
        continue;
       }
       else if( slot >= 1&&slot <=3)
       {
        posx=0;
        posy=slot-1;
       }
       else if (slot >= 4 && slot <= 6)
       {
        posx=1;
        posy=slot-4;
       }
       else
       {
        posx=2;
        posy=slot-7;
       }
       if (match[posx][posy] == 0)
       {
        match[posx][posy]=1;
        fill++;
        check(match);
        if(check(match)==1)
        {
         printf(""The user wins!\n"");
         user_score++;
         print(match);
         break;
        }
        else if(check(match)==-1)
        {
         printf(""The computer wins!\n"");
         comp_score++;
         print(match);
        }
        else
        {
         if(fill==9)
         {
          printf(""It's a draw!\n"");
          print(match);
          break;
         }
         else
         {
          printf("" "");
         }
        }
       }
       else
       {
        printf(""Sorry! This slot is already filled.\nPlease pick another slot.\n"");
        continue;
       }
       label:
       comp_posx=rand()%3;
       comp_posy=rand()%3;
       if(match[comp_posx][comp_posy]==0)
       {
        match[comp_posx][comp_posy]=-1;
        fill++;
        check(match);
        if (check(match)==1)
        {
         printf(""The user wins!\n"");
         user_score++;
         print(match);
         break;
        }
        else if(check(match)==-1)
        {
         printf(""The computer wins!\n"");
         comp_score++;
         print(match);
         break;
        }
        else
        {
         if (fill==9)
         {
          printf(""It's a draw!\n"");
          print(match);
          break;
         }
         else
         {
          printf("" "");
         }
        }
       }
       else
       goto label;
       for(i=0;i<3;i++)
       {
        printf(""\n"");
        for(j=0;j<3;j++)
        {
        printf(""%d\t"",match[i][j]);
        }
       }
      }
      for(i=0;i<3;i++)
      {
       for(j=0;j<3;j++)
       {
        match[i][j]=0;
       }
      }
      printf(""Continue? Y/N\n"");
      scanf(""%c %c"",&ch,&ch);
     }
     while(ch=='y'||ch=='Y');
     printf(""FINAL SCORES>>\nUser=%d\nComputer=%d\n"",user_score,comp_score);
    }
    int check(int match[][3])
    {
     int i,j;
     if( match[2][0]==match[1][1] && match[1][1]==match[0][2] )
     {
      if (match[0][2]==1)
      return 1;
      else if (match[0][2]==-1)
      return -1;
      else
      printf("" "");
     }
     for(i=0;i<3;i++)
     {
      if (match[i][0]==match[i][1]&&match[i][1]==match[i][2])
      {
       if(match[i][1]==1)
       return 1;
       else if(match[i][1]==-1)
       return -1;
       else
       continue;
      }
     }
     for(j=0;j<3;j++)
     {
      if(match[0][j]==match[1][j]&&match[0][j]==match[2][j])
      {
       if (match[0][j]==1)
       return 1;
       else if(match[0][j]==-1)
       return -1;
       else
       continue;
      }
     }
     for (i=0;i<1;i++)
     {
      if(match[i][i]==match[i+1][i+1]&&match[i][i]==match[i+2][i+2])
      {
       if (match[i][i]==1)
       return 1;
       else if (match[i][i]==-1)       return -1;
      else continue;
      }
     }
    }
     void print(int match[][3])
     {
      int i,j;
      for(i=0;i<3;i++)
      {
       printf(""\n"");
       for(j=0;j<3;j++)
       {
        printf(""%d\t"",match[i][j]);
       }
      }
     }
Can You suggest changes in the code, so that i won't have those problems?
",2
11435860,07/11/2012 15:16:23,960585,09/23/2011 07:11:56,87,8,Best open source OS choice and configuration for embedded application,"This is not a question where an answer is right or wrong, it's more of a discussion topic where I would like to hear your ideas.
I'm developping an embedded C application, which is controlled by a web interface (using HTML5, JavaScript, jQuery and AJAX) viewed in a browser (preferably Firefox, Chrome or Opera).
The idea is that this application will run on a device which will obviously have a screen, but will also require an OS that can run a browser as well as the actual C application (so for example ChromeOS is already out of the running).
The user may not access the actual OS, it's actions are restricted to using the browser only.
I've already tried some methods to set up this system in a virtual machine, by installing ubuntu and gnome and launching firefox at startup.
However, I think it's a bit overkill of installing the entire ubuntu and gnome framework just to run a C app and a browser.
Therefore, I would like to hear some suggestions from you guys.",c,browser,embedded,,,07/11/2012 21:15:11,not constructive,1,169,10,"Best open source OS choice and configuration for embedded application This is not a question where an answer is right or wrong, it's more of a discussion topic where I would like to hear your ideas.
I'm developping an embedded C application, which is controlled by a web interface (using HTML5, JavaScript, jQuery and AJAX) viewed in a browser (preferably Firefox, Chrome or Opera).
The idea is that this application will run on a device which will obviously have a screen, but will also require an OS that can run a browser as well as the actual C application (so for example ChromeOS is already out of the running).
The user may not access the actual OS, it's actions are restricted to using the browser only.
I've already tried some methods to set up this system in a virtual machine, by installing ubuntu and gnome and launching firefox at startup.
However, I think it's a bit overkill of installing the entire ubuntu and gnome framework just to run a C app and a browser.
Therefore, I would like to hear some suggestions from you guys.",3
2973856,06/04/2010 12:00:39,380038,04/26/2010 11:40:00,54,1,Can I access type int (*)[] with [][]?,"coming from this question ""[What does (int (*)[])var1 stand for?][1]"" I tried to access the result of the cast like a multidimensional array. But I get following error: ""`assignment from incompatible pointer type`"" followed by a segmentation fault. I tried also some other variations, but none of them worked. How can I access the elements in `var1` in the function `example` directly?

Thank you!


    #include <stdlib.h>
    
    int i(int n,int m,int var1[n][m]) {
        var1[0][0]=5;
        return var1[0][0];
    }
    
    int example() {
        int *var1 = malloc(100);
        
        // works
        int var2;
        var2 = i(10,10,(int (*)[])var1);
        printf(""var2=%i"",var2);
        
        //doesn't work
        int *var3;
        var3=(int (*)[])var1; //""assignment from incompatible pointer type""
        printf(""var3[0][0]=%i"",var3[0][0])
        
        return(1); 
        
    } 
    
    int main(){
        int a;
        a=example();
        return(1);
    }


  [1]: http://stackoverflow.com/questions/2972978/what-does-int-var1-stand-for",c,pointers,casting,multidimensional-array,,,open,0,287,8,"Can I access type int (*)[] with [][]? coming from this question ""[What does (int (*)[])var1 stand for?][1]"" I tried to access the result of the cast like a multidimensional array. But I get following error: ""`assignment from incompatible pointer type`"" followed by a segmentation fault. I tried also some other variations, but none of them worked. How can I access the elements in `var1` in the function `example` directly?

Thank you!


    #include <stdlib.h>
    
    int i(int n,int m,int var1[n][m]) {
        var1[0][0]=5;
        return var1[0][0];
    }
    
    int example() {
        int *var1 = malloc(100);
        
        // works
        int var2;
        var2 = i(10,10,(int (*)[])var1);
        printf(""var2=%i"",var2);
        
        //doesn't work
        int *var3;
        var3=(int (*)[])var1; //""assignment from incompatible pointer type""
        printf(""var3[0][0]=%i"",var3[0][0])
        
        return(1); 
        
    } 
    
    int main(){
        int a;
        a=example();
        return(1);
    }


  [1]: http://stackoverflow.com/questions/2972978/what-does-int-var1-stand-for",4
4473426,12/17/2010 17:59:54,346560,05/20/2010 21:24:10,208,4,Executable path,"I need to find the path of where my program is running.
Using argv[0] doesn't seem to work because the program has to be run on the windows console, for example, **C:\ >player parameter1 parameter2** and I only get player on argv[0].

How can I accomplish this?",c,windows,,,,,open,0,45,2,"Executable path I need to find the path of where my program is running.
Using argv[0] doesn't seem to work because the program has to be run on the windows console, for example, **C:\ >player parameter1 parameter2** and I only get player on argv[0].

How can I accomplish this?",2
7953552,10/31/2011 12:15:04,1004437,02/19/2011 07:06:59,314,5,Why we are avoid Magic Numbers or Constants from Program and use macro?,"here C programming Guidelines and coding standards says we have to avoid magic numbers from program and use macro  for magic numbers

In Macro it will take more time to evaluate as compare to Constants so performance is more better in magic numbers or constants.

for Example

    for(i=0;i<255;i++)
    {

    } 

We use this 

#define MAX 255

    for(i=0;i<MAX;i++)
    {

    }

Second one is take more time compare to first one so why we prefer second one as per coding standards.",c,,,,,11/08/2011 08:06:50,not a real question,1,95,13,"Why we are avoid Magic Numbers or Constants from Program and use macro? here C programming Guidelines and coding standards says we have to avoid magic numbers from program and use macro  for magic numbers

In Macro it will take more time to evaluate as compare to Constants so performance is more better in magic numbers or constants.

for Example

    for(i=0;i<255;i++)
    {

    } 

We use this 

#define MAX 255

    for(i=0;i<MAX;i++)
    {

    }

Second one is take more time compare to first one so why we prefer second one as per coding standards.",1
10989122,06/12/2012 00:23:07,1214982,02/16/2012 22:30:50,1,0,Parallel processing in linux,"I'm not sure how to go about handling asynchronous tasks in a program I am writing and I'm hoping someone more experienced can at least point me in the right direction. I'm running Angstrom Linux on an embedded ARM processor. My program controls several servos through exposed hardware PWM and a camera over PTP. Additionally it is socket daemon which takes commands from an arbitrary client...Android in this instance. The camera PTP is slow, and I don't want to wait around for it to finish its task because the rest of the program needs to be responsive. I've tried threads, but any problems in the camera thread seems to kill the whole process. Ideally I want to send the camera off on its own to do its thing and when it is finished let the main function know. Is this an appropriate forking technique or have I implemented threading improperly? Additionally, I would like to stay away from large secondary libraries to avoid any more cross compiling issues then I already have. Thanks in advance for any suggestions.",c,linux,multithreading,,,,open,0,178,4,"Parallel processing in linux I'm not sure how to go about handling asynchronous tasks in a program I am writing and I'm hoping someone more experienced can at least point me in the right direction. I'm running Angstrom Linux on an embedded ARM processor. My program controls several servos through exposed hardware PWM and a camera over PTP. Additionally it is socket daemon which takes commands from an arbitrary client...Android in this instance. The camera PTP is slow, and I don't want to wait around for it to finish its task because the rest of the program needs to be responsive. I've tried threads, but any problems in the camera thread seems to kill the whole process. Ideally I want to send the camera off on its own to do its thing and when it is finished let the main function know. Is this an appropriate forking technique or have I implemented threading improperly? Additionally, I would like to stay away from large secondary libraries to avoid any more cross compiling issues then I already have. Thanks in advance for any suggestions.",3
3705436,09/14/2010 00:52:04,446895,09/14/2010 00:42:50,1,0,"C Error Checking Function (Not really homework, but don't say I said it wasn't)","For my systems programming class we're doing a lot of programming in C and are required to error check most functions as we are currently learning to program with pthreads.

The reason I say this is not really homework, is that it is far above and beyond what is expected for this class. Simply checking each function individually is more than satisfactory. I just feel this is a time-consuming and messy method and hope for a neater solution.

I was wondering if anyone could show me how to write a function that takes any C function as a parameter, followed by all the required parameters for that function, along with a desired return value (in this case the correct one), and performs the following.

    if(function_name(param1, param2, ...) != desired_return_value) {
        fprintf(stderr, ""program_name: function_name() failed\n"");
        perror(""function_name(): "");
    }

Is this possible? It's hardly required by our course, but it just irks me that virtually ever function I write has to have 4 lines of code to error check it. It makes it bloody hard to read.

Even some other suggestions would be good. I'm just trying to increase readability, so if this is totally the wrong direction, some correct direction would be much appreciated.

",c,function,error-handling,,,,open,0,219,14,"C Error Checking Function (Not really homework, but don't say I said it wasn't) For my systems programming class we're doing a lot of programming in C and are required to error check most functions as we are currently learning to program with pthreads.

The reason I say this is not really homework, is that it is far above and beyond what is expected for this class. Simply checking each function individually is more than satisfactory. I just feel this is a time-consuming and messy method and hope for a neater solution.

I was wondering if anyone could show me how to write a function that takes any C function as a parameter, followed by all the required parameters for that function, along with a desired return value (in this case the correct one), and performs the following.

    if(function_name(param1, param2, ...) != desired_return_value) {
        fprintf(stderr, ""program_name: function_name() failed\n"");
        perror(""function_name(): "");
    }

Is this possible? It's hardly required by our course, but it just irks me that virtually ever function I write has to have 4 lines of code to error check it. It makes it bloody hard to read.

Even some other suggestions would be good. I'm just trying to increase readability, so if this is totally the wrong direction, some correct direction would be much appreciated.

",3
2170752,01/31/2010 06:04:07,182742,10/01/2009 20:16:06,186,13,"Why Does Test Condition of ""for(;;)"" Succeed?","Insomuch as I understand ""for(;;)"" has no initial condition, no test condition and no increment condition, and therefore loops forever, I am curious why the test condition succeeds each loop.

Does the empty expression "";"" evaluate as true in C? Or is this a special case handled by compilers?

[A similar, but unrelated question][1].

  [1]: http://stackoverflow.com/questions/1991670/what-kind-of-loop-is-for",c,for-loop,infinite-loop,compiler,,,open,0,55,7,"Why Does Test Condition of ""for(;;)"" Succeed? Insomuch as I understand ""for(;;)"" has no initial condition, no test condition and no increment condition, and therefore loops forever, I am curious why the test condition succeeds each loop.

Does the empty expression "";"" evaluate as true in C? Or is this a special case handled by compilers?

[A similar, but unrelated question][1].

  [1]: http://stackoverflow.com/questions/1991670/what-kind-of-loop-is-for",4
7057403,08/14/2011 14:32:17,775605,05/30/2011 01:06:15,37,0,Improvement of a C function based in igraph,"Related with the  question ""Edge - weight association"" and the Tams's answer, I  wrote the below   code to get  the arc weigth of the mst tree extracted  from  the original vector weigth. I will use this code while I move to igraph 0.6. 

Some one see some mistake or  improvement in the code, both general like in the igraph use.

Thanks, Guillermo.
The code:


    int igraph_get_weight_subtree( igraph_t subtree, igraph_t grafo, igraph_vector_t vector_pesos_grafo, igraph_vector_t *vector_pesos_subtree){

	igraph_vector_t vector_arcos_grafo, vector_arcos_subtree;
	int i,j,k;
	igraph_real_t sub_tree_nodo1, sub_tree_nodo2;

	printf(""\nigraph_get_weight_subtree: Imprimiendo arcos de subtree...\n"");
	igraph_write_graph_edgelist(&subtree, stdout);
	printf(""[OK]\n"");

	printf(""\nigraph_get_weight_subtree: Imprimiendo arcos de grafo...\n"");
	igraph_write_graph_edgelist(&grafo, stdout);
	printf(""[OK]\n"");

	//Inicializa los vectores vector_arcos_subtree y vector_arcos_grafo
	igraph_vector_init(&vector_arcos_subtree,1);
	igraph_vector_init(&vector_arcos_grafo,1);

	//Extrae los arcos desde los grafos de entrada. Los convierte en Vector


	igraph_get_edgelist(&subtree, &vector_arcos_subtree, 0);
	igraph_get_edgelist(&grafo, &vector_arcos_grafo, 0);



	for (i=0; i< igraph_vector_size(&vector_arcos_subtree); i=i+2){
		sub_tree_nodo1= VECTOR(vector_arcos_subtree)[i];
		sub_tree_nodo2= VECTOR(vector_arcos_subtree)[i+1];
		//Busca arco de subtree en grafo
		j=0;
		k=0;
		while(j< igraph_vector_size(&vector_arcos_grafo)){
			if(	((sub_tree_nodo1==VECTOR(vector_arcos_grafo)[j])&& (sub_tree_nodo2==VECTOR(vector_arcos_grafo)[j+1]))||	((sub_tree_nodo2==VECTOR(vector_arcos_grafo)[j])&&(sub_tree_nodo1==VECTOR(vector_arcos_grafo)[j+1]))) {
				igraph_vector_push_back (vector_pesos_subtree, VECTOR(vector_pesos_grafo)[k]);
				break;
			}//End if
			j=j+2;
			k=k+1;
		}//End while
	}

	//Destruye los vectore en desuso
	igraph_vector_destroy(&vector_arcos_subtree);
	igraph_vector_destroy(&vector_arcos_grafo);

	return 0;
    }
",c,minimum-spanning-tree,igraph,,,08/15/2011 04:24:27,too localized,1,145,8,"Improvement of a C function based in igraph Related with the  question ""Edge - weight association"" and the Tams's answer, I  wrote the below   code to get  the arc weigth of the mst tree extracted  from  the original vector weigth. I will use this code while I move to igraph 0.6. 

Some one see some mistake or  improvement in the code, both general like in the igraph use.

Thanks, Guillermo.
The code:


    int igraph_get_weight_subtree( igraph_t subtree, igraph_t grafo, igraph_vector_t vector_pesos_grafo, igraph_vector_t *vector_pesos_subtree){

	igraph_vector_t vector_arcos_grafo, vector_arcos_subtree;
	int i,j,k;
	igraph_real_t sub_tree_nodo1, sub_tree_nodo2;

	printf(""\nigraph_get_weight_subtree: Imprimiendo arcos de subtree...\n"");
	igraph_write_graph_edgelist(&subtree, stdout);
	printf(""[OK]\n"");

	printf(""\nigraph_get_weight_subtree: Imprimiendo arcos de grafo...\n"");
	igraph_write_graph_edgelist(&grafo, stdout);
	printf(""[OK]\n"");

	//Inicializa los vectores vector_arcos_subtree y vector_arcos_grafo
	igraph_vector_init(&vector_arcos_subtree,1);
	igraph_vector_init(&vector_arcos_grafo,1);

	//Extrae los arcos desde los grafos de entrada. Los convierte en Vector


	igraph_get_edgelist(&subtree, &vector_arcos_subtree, 0);
	igraph_get_edgelist(&grafo, &vector_arcos_grafo, 0);



	for (i=0; i< igraph_vector_size(&vector_arcos_subtree); i=i+2){
		sub_tree_nodo1= VECTOR(vector_arcos_subtree)[i];
		sub_tree_nodo2= VECTOR(vector_arcos_subtree)[i+1];
		//Busca arco de subtree en grafo
		j=0;
		k=0;
		while(j< igraph_vector_size(&vector_arcos_grafo)){
			if(	((sub_tree_nodo1==VECTOR(vector_arcos_grafo)[j])&& (sub_tree_nodo2==VECTOR(vector_arcos_grafo)[j+1]))||	((sub_tree_nodo2==VECTOR(vector_arcos_grafo)[j])&&(sub_tree_nodo1==VECTOR(vector_arcos_grafo)[j+1]))) {
				igraph_vector_push_back (vector_pesos_subtree, VECTOR(vector_pesos_grafo)[k]);
				break;
			}//End if
			j=j+2;
			k=k+1;
		}//End while
	}

	//Destruye los vectore en desuso
	igraph_vector_destroy(&vector_arcos_subtree);
	igraph_vector_destroy(&vector_arcos_grafo);

	return 0;
    }
",3
4358975,12/05/2010 13:15:58,508462,11/15/2010 15:55:11,30,3,C / Arduino: variable int array,"I'm writing a class for the arduino. It's been going well so far but I'm sort of stuck now...
I have declared an int array in my class `class myClass
{
  public: MyClass(int size);
  private:
    int _intArray[];
};`

When I initialize the class `MyClass myClass1(5)` I need the array to look like this {0,0,0,0,0}.

My question: what do I need to do so that the array contains 'size' amount of zeros?

    MyClass::MyClass(int size)
{

    //what goes here to dynamically initialize the array

  for(int i=0; i < size; i++) _intArray[i] = 0;

}",c,arrays,class,integer,arduino,,open,0,97,6,"C / Arduino: variable int array I'm writing a class for the arduino. It's been going well so far but I'm sort of stuck now...
I have declared an int array in my class `class myClass
{
  public: MyClass(int size);
  private:
    int _intArray[];
};`

When I initialize the class `MyClass myClass1(5)` I need the array to look like this {0,0,0,0,0}.

My question: what do I need to do so that the array contains 'size' amount of zeros?

    MyClass::MyClass(int size)
{

    //what goes here to dynamically initialize the array

  for(int i=0; i < size; i++) _intArray[i] = 0;

}",5
8933581,01/19/2012 21:31:50,591786,01/27/2011 06:59:25,95,0,"Can we get rid of ""Do While"" post test loop?","I know that ""Do while"" posttest loop helps us in scenarios where we need the loop to get executed at least once. Apart from this use do we really need a post test loop. If yes then in what other situations?",c,algorithm,pseudocode,,,01/19/2012 22:52:30,not constructive,1,41,10,"Can we get rid of ""Do While"" post test loop? I know that ""Do while"" posttest loop helps us in scenarios where we need the loop to get executed at least once. Apart from this use do we really need a post test loop. If yes then in what other situations?",3
9484116,02/28/2012 14:50:08,1229414,02/23/2012 21:22:24,1,0,"How to be a ""big league"" C coder","Although not my major, I've got pretty much the equivalent of a Bacherlors degree in CompSci. I took a ""Unix Systems Programming"" based on the Stevens book and also an Operating Systems class where the toughest assignment was to write a ""buddy system"" simulator with all the funky pointer fun. Through all this I picked up some passable C skills and the rudiments of make and gdb, all housed under the Emacs roof. Good. But then I met a guy at a job who was a world-class Debian contributor. The first time I saw him he was hacking his own private version of Mutt because he wasn't satisfied with it for some archaic reason. Okay, I realize there's a deep, wide chasm between school project C and real-world big project C. How do you bridge that gap? For example, I download the source for some app, do the configure, make, install . . . and the screen is filled for hours with craziness! I look at some of the source code . . . and get lost fairly quickly, especially trying to figure out the overview of what's going on. It's C. I understand it (sort of), but the overview is not coming through. So my question is this: How do you get ""big league"" C hacking skills? I remember in the Stevens class, we hacked our own version of tar based on an algorithm in the book -- and some cheat-sheet help from BSD source. But really, how do you get to the point where you can truly contribute to a serious app endeavor? And what about these languages? I just downloaded the source for PolyML and poked around. Wow! How could I ever learn C at that level?",c,system,,,,02/28/2012 14:52:59,not a real question,1,290,8,"How to be a ""big league"" C coder Although not my major, I've got pretty much the equivalent of a Bacherlors degree in CompSci. I took a ""Unix Systems Programming"" based on the Stevens book and also an Operating Systems class where the toughest assignment was to write a ""buddy system"" simulator with all the funky pointer fun. Through all this I picked up some passable C skills and the rudiments of make and gdb, all housed under the Emacs roof. Good. But then I met a guy at a job who was a world-class Debian contributor. The first time I saw him he was hacking his own private version of Mutt because he wasn't satisfied with it for some archaic reason. Okay, I realize there's a deep, wide chasm between school project C and real-world big project C. How do you bridge that gap? For example, I download the source for some app, do the configure, make, install . . . and the screen is filled for hours with craziness! I look at some of the source code . . . and get lost fairly quickly, especially trying to figure out the overview of what's going on. It's C. I understand it (sort of), but the overview is not coming through. So my question is this: How do you get ""big league"" C hacking skills? I remember in the Stevens class, we hacked our own version of tar based on an algorithm in the book -- and some cheat-sheet help from BSD source. But really, how do you get to the point where you can truly contribute to a serious app endeavor? And what about these languages? I just downloaded the source for PolyML and poked around. Wow! How could I ever learn C at that level?",2
2398905,03/08/2010 02:05:30,288460,03/08/2010 02:05:30,1,0,Reserve RAM in C,"I need ideas on how to write a C program that reserve a specified amount of MB RAM until a key [ex. the any key] is pressed on a Linux 2.6 32 bit system.

=========
/.eat_ram.out 200

// If free -m is execute at this time, it should report 200 MB more in the used section, than before running the program.

[Any key is pressed]

// Now all the reserved RAM should be released and the program exits.
==========

It is the core functionality of the program [reserving the RAM] i do not know how to do, getting arguments from the commandline, printing [Any key is pressed] and so on is not a problem from me.

Any ideas on how to do this? 
",c,linux,ram,memory,,,open,0,116,4,"Reserve RAM in C I need ideas on how to write a C program that reserve a specified amount of MB RAM until a key [ex. the any key] is pressed on a Linux 2.6 32 bit system.

=========
/.eat_ram.out 200

// If free -m is execute at this time, it should report 200 MB more in the used section, than before running the program.

[Any key is pressed]

// Now all the reserved RAM should be released and the program exits.
==========

It is the core functionality of the program [reserving the RAM] i do not know how to do, getting arguments from the commandline, printing [Any key is pressed] and so on is not a problem from me.

Any ideas on how to do this? 
",4
11664753,07/26/2012 07:52:26,1363651,04/29/2012 02:17:43,11,0,C# Regular Expression : how to extract content from string?,"i have a tring as same as : 

    ...[down]&lt;a title=""Download: Click Here"" href=""http://www.domain.com/T60B8JK2WT/"" target=""_blank""&gt;&lt;strong&gt; KungFu Panda - Legends of Awesomeness (2011)(1 - 22)&lt;/strong&gt;&lt;/a&gt; &lt;a title=""Download: Click Here"" href=""http://www.domain.com/5FBLQYBQTV/"" target=""_blank""&gt;&lt;strong&gt; KungFu Panda - Legends of Awesomeness (2011) &lt;/strong&gt;&lt;/a&gt;[/down]...

How i can find [down][/down] tag in string & get all href attribute & text of each link in [down][/down] tag and put it in a data table, with each row of table is title & url field? Thanks & sorry for my english.",c,regex,,,,07/27/2012 00:40:50,not constructive,1,84,10,"C# Regular Expression : how to extract content from string? i have a tring as same as : 

    ...[down]&lt;a title=""Download: Click Here"" href=""http://www.domain.com/T60B8JK2WT/"" target=""_blank""&gt;&lt;strong&gt; KungFu Panda - Legends of Awesomeness (2011)(1 - 22)&lt;/strong&gt;&lt;/a&gt; &lt;a title=""Download: Click Here"" href=""http://www.domain.com/5FBLQYBQTV/"" target=""_blank""&gt;&lt;strong&gt; KungFu Panda - Legends of Awesomeness (2011) &lt;/strong&gt;&lt;/a&gt;[/down]...

How i can find [down][/down] tag in string & get all href attribute & text of each link in [down][/down] tag and put it in a data table, with each row of table is title & url field? Thanks & sorry for my english.",2
11456338,07/12/2012 16:26:02,1396775,05/15/2012 17:03:16,18,2,C Implicit declaration differs from internal function declaration,"I'm having some trouble with C standard functions. As an example, I'm getting that error in the memcpy function, even passing the right arguments to it.
I've included a header as #include ""header.h"", and I've included <stdlib.h>, <string.h> and so in the ""header.h"" file. 
(I'm also getting this error with strcpy, strtok, and some other standard functions, all respective headers included in ""header.h"")

Can anyone please help me with this? I'm running out of time to deploy this work...
Thanks in advance",c,function,declaration,implicit,implicit-declaration,,open,0,79,8,"C Implicit declaration differs from internal function declaration I'm having some trouble with C standard functions. As an example, I'm getting that error in the memcpy function, even passing the right arguments to it.
I've included a header as #include ""header.h"", and I've included <stdlib.h>, <string.h> and so in the ""header.h"" file. 
(I'm also getting this error with strcpy, strtok, and some other standard functions, all respective headers included in ""header.h"")

Can anyone please help me with this? I'm running out of time to deploy this work...
Thanks in advance",5
9684397,03/13/2012 12:58:46,191445,10/16/2009 20:47:23,144,2,Strlen in Malloc,"Why does this return no warnings? What is supposed to be wrong with the code?

    char *str = malloc(strlen(""hello"" + 1));
    strcpy(str, ""hello"");

Thanks!",c,pointers,,,,,open,0,29,3,"Strlen in Malloc Why does this return no warnings? What is supposed to be wrong with the code?

    char *str = malloc(strlen(""hello"" + 1));
    strcpy(str, ""hello"");

Thanks!",2
3157203,07/01/2010 11:13:07,372026,06/21/2010 09:35:25,44,9,Error while using libsoup,"I am writing a client using libsoup APIs.
I have done the following.

`session = soup_session_sync_new();

msg =  soup_message_new(""GET"",""http://www.google.com""); 

status = soup_session_send_message(session,msg);`

However now i am getting the following error code in status. I print the reason phrase and it says the ` status= 4 , msg->reason_phrase = Cannot connect to destination`

How do i resolve this issue?",c,linux,open-source,network-programming,client,,open,0,54,4,"Error while using libsoup I am writing a client using libsoup APIs.
I have done the following.

`session = soup_session_sync_new();

msg =  soup_message_new(""GET"",""http://www.google.com""); 

status = soup_session_send_message(session,msg);`

However now i am getting the following error code in status. I print the reason phrase and it says the ` status= 4 , msg->reason_phrase = Cannot connect to destination`

How do i resolve this issue?",5
10832993,05/31/2012 11:48:38,1179695,01/31/2012 06:52:57,1,1,struct pointer casting and its memery allocation,"The point here is the code ""int header = (((int)(txUserPtr) - 4))"" 
Illustration of UserTypes and struct pointer casting is great of help!
 how should i set incoming pointer ""txUserPtr"" so that 
 Fun() would skip following lines.
I don't want to execute error()


    typedef union UserTypes
    {
        SAUser           AUser;
        BUser            BUser;
        SCUser           CUser;
        SDUser           DUser;
    } UserTypes;
    
    typedef struct AUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } AUser;
    typedef struct AUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } AUser;
    
    typedef struct BUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } BUser;
    
    typedef struct CUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } CUser;
    
    typedef struct DUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } DUser;
    
    //this is the function I want to test
    
    void Fun(UserTypes * txUserPtr)
    {
    
       int header = (*((int*)(txUserPtr) - 4));
    
       //the problem is here
       //how should i set incoming pointer ""txUserPtr"" so that 
       //Fun() would skip following lines.
       // I don't want to execute error()
    
            if((header & 0xFF000000) != (int)0xAA000000)
            {
                error(""sth error\n"");
            }
       /*the following is the rest */ 
    }",c,,,,,05/31/2012 13:54:08,not a real question,1,699,7,"struct pointer casting and its memery allocation The point here is the code ""int header = (((int)(txUserPtr) - 4))"" 
Illustration of UserTypes and struct pointer casting is great of help!
 how should i set incoming pointer ""txUserPtr"" so that 
 Fun() would skip following lines.
I don't want to execute error()


    typedef union UserTypes
    {
        SAUser           AUser;
        BUser            BUser;
        SCUser           CUser;
        SDUser           DUser;
    } UserTypes;
    
    typedef struct AUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } AUser;
    typedef struct AUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } AUser;
    
    typedef struct BUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } BUser;
    
    typedef struct CUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } CUser;
    
    typedef struct DUser
    {
        int              userId;
        int              dbIndex;
        ChannelType      ChanType;
     } DUser;
    
    //this is the function I want to test
    
    void Fun(UserTypes * txUserPtr)
    {
    
       int header = (*((int*)(txUserPtr) - 4));
    
       //the problem is here
       //how should i set incoming pointer ""txUserPtr"" so that 
       //Fun() would skip following lines.
       // I don't want to execute error()
    
            if((header & 0xFF000000) != (int)0xAA000000)
            {
                error(""sth error\n"");
            }
       /*the following is the rest */ 
    }",1
6125404,05/25/2011 13:42:40,750186,05/12/2011 08:20:10,149,10,OpenCL code runs faster on MBP than on NVIDIA GTX 480,"I'm I have come across a strange problem. I'm implementing some linear algebra, only matrix multiplications so far, in OpenCL, and have been testing this on my laptop. The code is really simple:


    __kernel void matrix_mult(__global float* a, 
    			  __global float* b, 
    			  __global float* c,
    			  const int N) 
    {
      int row = get_global_id(1);
      int col = get_global_id(0);
      float sum = 0.0f;
      for (int i = 0; i < N; i++) {
        sum += a[row*N+i] * b[i*N+col];
      }
      c[row*N+col] = sum;
    }


I test the hardware by running the code 100 times like this:

      clock_t begin=clock(); 
      
      const unsigned int repeats = 100;
      for(int  i = 0; i != repeats; i++){
        runCL(a, b, results,N, N*N);
      }
    
      clock_t end=clock();


On my MBP matrix_multiplications take about 1.2 ms, on matrices of size 512*512 while the same code takes about 3 ms when running on a GTX 480 Linux box. This bothers me since, I would't expect the expensive GTX card to be a little faster than the laptop.

As far as I can see either my code is 'wrong' of I'm timing in some wrong way.   
",c,gcc,time,opencl,hpc,,open,0,289,11,"OpenCL code runs faster on MBP than on NVIDIA GTX 480 I'm I have come across a strange problem. I'm implementing some linear algebra, only matrix multiplications so far, in OpenCL, and have been testing this on my laptop. The code is really simple:


    __kernel void matrix_mult(__global float* a, 
    			  __global float* b, 
    			  __global float* c,
    			  const int N) 
    {
      int row = get_global_id(1);
      int col = get_global_id(0);
      float sum = 0.0f;
      for (int i = 0; i < N; i++) {
        sum += a[row*N+i] * b[i*N+col];
      }
      c[row*N+col] = sum;
    }


I test the hardware by running the code 100 times like this:

      clock_t begin=clock(); 
      
      const unsigned int repeats = 100;
      for(int  i = 0; i != repeats; i++){
        runCL(a, b, results,N, N*N);
      }
    
      clock_t end=clock();


On my MBP matrix_multiplications take about 1.2 ms, on matrices of size 512*512 while the same code takes about 3 ms when running on a GTX 480 Linux box. This bothers me since, I would't expect the expensive GTX card to be a little faster than the laptop.

As far as I can see either my code is 'wrong' of I'm timing in some wrong way.   
",5
7652812,10/04/2011 19:04:40,929210,09/05/2011 16:21:50,48,3,Matlab or C function,"Does it make the program perform better if instead of writing Matlab code, I write C functions and call the C function from the Matlab code ?",c,matlab,,,,10/04/2011 21:23:27,not a real question,1,27,4,"Matlab or C function Does it make the program perform better if instead of writing Matlab code, I write C functions and call the C function from the Matlab code ?",2
5176407,03/03/2011 03:42:08,461316,09/29/2010 04:03:18,32,0,Capture result from a function in C (cmd1 | cmd2),"Let us say that cmd1 print something on stdout. How can I capture it with cmd1 in C such that cmd1 | cmd2 works.

i.e

    cmd1{
        fprintf(stdout, ""Hello"");
        }
    
    cmd2 : should take ""hello"" and only print ""hel"".",c,,,,,,open,0,61,10,"Capture result from a function in C (cmd1 | cmd2) Let us say that cmd1 print something on stdout. How can I capture it with cmd1 in C such that cmd1 | cmd2 works.

i.e

    cmd1{
        fprintf(stdout, ""Hello"");
        }
    
    cmd2 : should take ""hello"" and only print ""hel"".",1
3174593,07/04/2010 12:11:06,200399,11/01/2009 07:01:06,396,2,password in c programming,"i want to write a c program to enter a user name and password, and then continue with my program",c,,,,,07/04/2010 12:20:57,not a real question,1,20,4,"password in c programming i want to write a c program to enter a user name and password, and then continue with my program",1
1943847,12/22/2009 02:20:14,95135,04/23/2009 19:04:52,1906,113,Declaring a function static and later non-static: is it standard?,"I noticed a very curious behavior that, if standard, I would be very happy to exploit (what I'd like to do with it is fairly complex to explain and irrelevant to the question).

The behavior is:

    static void name();
    void name() {
        /* This function is now static, even if in the declaration
         * there is no static keyword. Tested on GCC and VS. */
    }

What's curious is that the inverse produces a compile time error:

    void name();
    static void name() {
        /* Illegal */
    }

So, is this standard and can I expect other compilers to behave the same way? Thanks!",c,c++,standards,,,,open,0,140,10,"Declaring a function static and later non-static: is it standard? I noticed a very curious behavior that, if standard, I would be very happy to exploit (what I'd like to do with it is fairly complex to explain and irrelevant to the question).

The behavior is:

    static void name();
    void name() {
        /* This function is now static, even if in the declaration
         * there is no static keyword. Tested on GCC and VS. */
    }

What's curious is that the inverse produces a compile time error:

    void name();
    static void name() {
        /* Illegal */
    }

So, is this standard and can I expect other compilers to behave the same way? Thanks!",3
11284910,07/01/2012 19:13:55,1479376,06/25/2012 08:12:24,21,0,address in c-&(number),"I don't underdtand the output of this program.
 
         int arr[]={1,7,4,2,5,8};
	  int x=(&(arr[arr[1]-arr[4]])-arr);
	  printf(""%d"" ,x);


         arr[arr[1]-arr[4]] is equal to 4.
What is mean &(4)?  Why is it print 2?",c,,,,,,open,0,47,3,"address in c-&(number) I don't underdtand the output of this program.
 
         int arr[]={1,7,4,2,5,8};
	  int x=(&(arr[arr[1]-arr[4]])-arr);
	  printf(""%d"" ,x);


         arr[arr[1]-arr[4]] is equal to 4.
What is mean &(4)?  Why is it print 2?",1
8703383,01/02/2012 17:02:58,1098207,12/14/2011 16:07:14,15,2,unix fork system call,"Good daytime to all

I am confused with fork() 

please help on some examples

    #include<unistd.h>
    #include<stdio.h>
    
        int main()
        {
        
        if (fork())
        fork();
        
        printf("" X\n"");
        return 0;
        }

is this how i suppose to build the processes:

        parent
          |
       /    \
    Parent  Child



so the output would be 
  

      X X X



another example is 

    #include<unistd.h>
    #include<stdio.h>
    
    int main()
    {
    fork();
    fork();
    fork();
    
    printf("" X \n"");
    
    return 0;
    }



the graph would be like this?

                     Fork start
                        /     \
                    Parent    Child        1st fork done output 2 of X
                    /  \      /   \
                  P     C    P    C        2nd fork done output 4 of X
                / \    / \  /\    /\
               P  C   P  C P  C  P  C      3rd fork done output 8 of X


another question how can i draw


    if (fork() || fork() || fork())
        fork();

 or


    if (fork() && fork())
    fork();

I would be glad if someone correct me.

Thanks in advance",c,unix,fork,system-calls,,01/02/2012 17:13:31,not a real question,1,500,4,"unix fork system call Good daytime to all

I am confused with fork() 

please help on some examples

    #include<unistd.h>
    #include<stdio.h>
    
        int main()
        {
        
        if (fork())
        fork();
        
        printf("" X\n"");
        return 0;
        }

is this how i suppose to build the processes:

        parent
          |
       /    \
    Parent  Child



so the output would be 
  

      X X X



another example is 

    #include<unistd.h>
    #include<stdio.h>
    
    int main()
    {
    fork();
    fork();
    fork();
    
    printf("" X \n"");
    
    return 0;
    }



the graph would be like this?

                     Fork start
                        /     \
                    Parent    Child        1st fork done output 2 of X
                    /  \      /   \
                  P     C    P    C        2nd fork done output 4 of X
                / \    / \  /\    /\
               P  C   P  C P  C  P  C      3rd fork done output 8 of X


another question how can i draw


    if (fork() || fork() || fork())
        fork();

 or


    if (fork() && fork())
    fork();

I would be glad if someone correct me.

Thanks in advance",4
6262082,06/07/2011 07:45:37,709075,04/15/2011 02:52:45,44,0,Reading string from a text file to build a binary search tree?,Is there any source code for me as reference. I'm studying a binary search tree. thanks,c,binary-search-tree,,,,06/07/2011 08:38:19,not a real question,1,16,12,Reading string from a text file to build a binary search tree? Is there any source code for me as reference. I'm studying a binary search tree. thanks,2
1368012,09/02/2009 14:22:19,17815,09/18/2008 15:06:59,979,38,What are good books to study C/C++ programming in Windows?,"I'm an experienced Java/C# developer.  I studied C/C++ in university but have never used them to build any non-trivial software.  Now I'm interested in learning about C/C++ programming in Windows and looking for good books to get started.  

Specifically, I want to learn about Win32 API, MFC, COM, event hook, screen capturing, multithreading, and networking.  Good books that cover many of these topics, even at introductory level (sufficient to start coding in the respective topic & explore more later), are of more interest to me than books covering only one or two of those areas in depth.  

What are good books which meet these criteria?",c,c++,windows,books,,01/06/2012 20:45:38,not constructive,1,110,10,"What are good books to study C/C++ programming in Windows? I'm an experienced Java/C# developer.  I studied C/C++ in university but have never used them to build any non-trivial software.  Now I'm interested in learning about C/C++ programming in Windows and looking for good books to get started.  

Specifically, I want to learn about Win32 API, MFC, COM, event hook, screen capturing, multithreading, and networking.  Good books that cover many of these topics, even at introductory level (sufficient to start coding in the respective topic & explore more later), are of more interest to me than books covering only one or two of those areas in depth.  

What are good books which meet these criteria?",4
9061743,01/30/2012 09:29:15,1147188,01/13/2012 07:42:59,9,0,Block user in c#,I have a question...I have a survey and every user who access him I will get his IP and insert it in a table. I want that after a user complete the survey to not let him complete the second time. or the third or n time...How do ,c,,,,,01/30/2012 10:22:30,not a real question,1,49,4,Block user in c# I have a question...I have a survey and every user who access him I will get his IP and insert it in a table. I want that after a user complete the survey to not let him complete the second time. or the third or n time...How do ,1
2411798,03/09/2010 19:10:01,289920,03/09/2010 19:10:01,1,0,size of struct - size_t in c,"For some reason I keep getting segmentation fault when I try to get the size of my struct.

    struct my_struct {
      char *a;
      int  b;
    };
    
    int main(int argc, char *argv[])
    {
    	struct my_struct dastruct;
    	size_t len = sizeof(dastruct) / sizeof(struct my_struct); // error
    	qsort(dastruct, len, sizeof(struct my_struct), cmp);
    	...
    }

Any ideas what I'm doing wrong? Thanks",c,struct,sizeof,,,,open,0,99,7,"size of struct - size_t in c For some reason I keep getting segmentation fault when I try to get the size of my struct.

    struct my_struct {
      char *a;
      int  b;
    };
    
    int main(int argc, char *argv[])
    {
    	struct my_struct dastruct;
    	size_t len = sizeof(dastruct) / sizeof(struct my_struct); // error
    	qsort(dastruct, len, sizeof(struct my_struct), cmp);
    	...
    }

Any ideas what I'm doing wrong? Thanks",3
7722287,10/11/2011 06:43:41,545561,12/17/2010 02:14:07,86,7,How to write your own basic disk scanner,"I would like to write some basic disk scanner utility. Basically I would like to be able to read raw bytes of a certain file(s) as written to the disk in the way system's disk utilities (like error checking and defragmentation in windows) do it. I would like to do it in C.

What should be my first steps? Obviously fopen is not enough.
 
Any guidance would be much appreciated (I don't ask for a solution, just a bit of theory and push in a right direction as I don't even know where to start from...).",c,windows,file-io,,,,open,0,95,8,"How to write your own basic disk scanner I would like to write some basic disk scanner utility. Basically I would like to be able to read raw bytes of a certain file(s) as written to the disk in the way system's disk utilities (like error checking and defragmentation in windows) do it. I would like to do it in C.

What should be my first steps? Obviously fopen is not enough.
 
Any guidance would be much appreciated (I don't ask for a solution, just a bit of theory and push in a right direction as I don't even know where to start from...).",3
7422026,09/14/2011 19:39:31,892866,08/13/2011 08:07:49,21,0,What's the deal with glibc?,"I know it's a standar c library, but I don't understand why c doesn't have a free library, not one that is lgpl. Is there any such library and if not, than that means every company/particular developer has to buy even the most basic libraries to develop commercial apps ? ",c,glibc,,,,09/14/2011 19:43:54,not constructive,1,51,5,"What's the deal with glibc? I know it's a standar c library, but I don't understand why c doesn't have a free library, not one that is lgpl. Is there any such library and if not, than that means every company/particular developer has to buy even the most basic libraries to develop commercial apps ? ",2
6983979,08/08/2011 14:52:18,514773,11/20/2010 23:28:27,618,4,Vertex Buffer Objects in OpenGL 2.1,"(I specified 2.1 because my laptop won't go past that version. I would have probably done this anyway since 3.x and on introduces shaders as mandatory?).

Thanks to Wikipedia: http://en.wikipedia.org/wiki/Vertex_Buffer_Object I am starting to grasp how simple it can be to use VBO's (I am still not positive about IBO's?). What I have understood so far is the primary reason to use them is a performance boost gained due to the fact that data is now stored in video memory.

What I would like to know is how I am supposed to use them in a practical context. For instance, all of what I have seen has been setting up one Vertex Buffer Object and drawing one triangle or one cube, etc. What if I want to draw 2 or more? Do I set up a new VBO for each entity that I want to draw? Or do I magically append to some static VBO that I setup early on?
",c,opengl,vbo,,,,open,0,158,6,"Vertex Buffer Objects in OpenGL 2.1 (I specified 2.1 because my laptop won't go past that version. I would have probably done this anyway since 3.x and on introduces shaders as mandatory?).

Thanks to Wikipedia: http://en.wikipedia.org/wiki/Vertex_Buffer_Object I am starting to grasp how simple it can be to use VBO's (I am still not positive about IBO's?). What I have understood so far is the primary reason to use them is a performance boost gained due to the fact that data is now stored in video memory.

What I would like to know is how I am supposed to use them in a practical context. For instance, all of what I have seen has been setting up one Vertex Buffer Object and drawing one triangle or one cube, etc. What if I want to draw 2 or more? Do I set up a new VBO for each entity that I want to draw? Or do I magically append to some static VBO that I setup early on?
",3
6290670,06/09/2011 09:23:56,301730,03/25/2010 13:49:54,22,0,Need help improving a small C program,"I wanted to launch a bash script (read: bash not sh script) as a root not as the user calling it, however bash ignore setuid on scripts, so I chose to write a very small script that takes a script/arguments and call it with setuid set.

This worked well and I went even further to verify that the script has setuid set on, executable and setuid() called on the owner of the file and not as root, to avoid any misuse of the program and I ended up with the program below..

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/types.h>
    #include <sys/stat.h>

    int main(int argc, char **argv)
    {
      char *command;
      int i, file_owner;
      struct stat status_buf;
      ushort file_mode;

      // Check argc
      if (argc < 2) {
        printf(""Usage: %s <script> [arguments]\n"", argv[0]);
        return 1;
      }
  
      // Make sure the script does exist
      if(fopen(argv[1], ""r"") == NULL) {
        printf(""The file %s does not exist.\n"", argv[1]);
        return 1;
      }
  
      // Get the attributes of the file
      stat(argv[1], &status_buf);
  
      // Get the permissions of the file
      file_mode = status_buf.st_mode;
  
      // Make sure it's executable and it's setuid
      if(file_mode >> 6 != 567) {
        printf(""The file %s should be executable and should have setuid set, please chmod it 0106755.\n"", argv[1]);
        return 1;
      }
  
      // Get the owner of the script
      file_owner = status_buf.st_uid;

      // setuid
      setuid(file_owner);

      // call the script
      command = (char *) malloc( (strlen(argv[1]) + 10) * sizeof(char) );
      sprintf(command, ""/bin/bash %s"", argv[1]);
      if (argc > 2) {
        for (i = 2; i < argc; i++) {
          realloc(command, (strlen(argv[i]) + 1 + strlen(command)) * sizeof(char) );
          sprintf(command, ""%s %s"", command, argv[i]);
        }
      }

      // Execute the command
      system(command);

      // free memory
      free(command);

      return 0;
    }


The exercise was not only to solve my problem, but it was also a way to get more into C, so what do you guys suggest? Is there anything I should improve ?

Thank you..
",c,bash,shell,file-permissions,setuid,06/09/2011 11:29:25,off topic,1,577,7,"Need help improving a small C program I wanted to launch a bash script (read: bash not sh script) as a root not as the user calling it, however bash ignore setuid on scripts, so I chose to write a very small script that takes a script/arguments and call it with setuid set.

This worked well and I went even further to verify that the script has setuid set on, executable and setuid() called on the owner of the file and not as root, to avoid any misuse of the program and I ended up with the program below..

    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <sys/types.h>
    #include <sys/stat.h>

    int main(int argc, char **argv)
    {
      char *command;
      int i, file_owner;
      struct stat status_buf;
      ushort file_mode;

      // Check argc
      if (argc < 2) {
        printf(""Usage: %s <script> [arguments]\n"", argv[0]);
        return 1;
      }
  
      // Make sure the script does exist
      if(fopen(argv[1], ""r"") == NULL) {
        printf(""The file %s does not exist.\n"", argv[1]);
        return 1;
      }
  
      // Get the attributes of the file
      stat(argv[1], &status_buf);
  
      // Get the permissions of the file
      file_mode = status_buf.st_mode;
  
      // Make sure it's executable and it's setuid
      if(file_mode >> 6 != 567) {
        printf(""The file %s should be executable and should have setuid set, please chmod it 0106755.\n"", argv[1]);
        return 1;
      }
  
      // Get the owner of the script
      file_owner = status_buf.st_uid;

      // setuid
      setuid(file_owner);

      // call the script
      command = (char *) malloc( (strlen(argv[1]) + 10) * sizeof(char) );
      sprintf(command, ""/bin/bash %s"", argv[1]);
      if (argc > 2) {
        for (i = 2; i < argc; i++) {
          realloc(command, (strlen(argv[i]) + 1 + strlen(command)) * sizeof(char) );
          sprintf(command, ""%s %s"", command, argv[i]);
        }
      }

      // Execute the command
      system(command);

      // free memory
      free(command);

      return 0;
    }


The exercise was not only to solve my problem, but it was also a way to get more into C, so what do you guys suggest? Is there anything I should improve ?

Thank you..
",5
8177295,11/18/2011 03:13:48,626027,02/21/2011 05:15:19,177,10,What happens when a char array is initialized to '\0'?,"I have a char array of size 512 i.e

    char buffer [512];

This variable after some point is modified to this

    buffer [40] = '\0';

What does this assignment does to the variable? Does it initialize the first 40 char in the array to null?
",c,,,,,,open,0,49,10,"What happens when a char array is initialized to '\0'? I have a char array of size 512 i.e

    char buffer [512];

This variable after some point is modified to this

    buffer [40] = '\0';

What does this assignment does to the variable? Does it initialize the first 40 char in the array to null?
",1
9450907,02/26/2012 05:49:12,958712,09/22/2011 09:08:14,176,0,How can I differentiate between windows 7 and windows xp or other windows in a C program?,"and also a 32bit OS from a 64bit OS?
Are there some #ifdef I can use to detect the actual OS version and whether it is 32 or 64 bit?",c,windows,winapi,,,,open,0,29,17,"How can I differentiate between windows 7 and windows xp or other windows in a C program? and also a 32bit OS from a 64bit OS?
Are there some #ifdef I can use to detect the actual OS version and whether it is 32 or 64 bit?",3
8184686,11/18/2011 15:20:26,738448,05/04/2011 16:43:22,76,0,unsigned int arithmetic - beginner C,"At the risk of getting yelled at for posting a stupid question:

say I have the following code snippet:

    unsigned int limit = 4294967296;
    int math = 50000;

    while(limit > 50000)
    {
        limit = limit - math;
        printf(""new limit is - \t%u\n"", limit);
    }
Would doing arithmetic between an unsigned int type and an int type have rammifications o n memory usage?

I know that an unsigned int has an order of magnitude more memory (2^31 for an int vs 2^32 for an unsigned int), but, since I'm using my unsigned int as a placeholder, i think I'm negating the danger of an overflow.

I would run this myself, but I don't have an accessible linux box right now.

Any input on this would be greatly appreciated.",c,int,unsigned,,,11/18/2011 15:22:34,not a real question,1,151,6,"unsigned int arithmetic - beginner C At the risk of getting yelled at for posting a stupid question:

say I have the following code snippet:

    unsigned int limit = 4294967296;
    int math = 50000;

    while(limit > 50000)
    {
        limit = limit - math;
        printf(""new limit is - \t%u\n"", limit);
    }
Would doing arithmetic between an unsigned int type and an int type have rammifications o n memory usage?

I know that an unsigned int has an order of magnitude more memory (2^31 for an int vs 2^32 for an unsigned int), but, since I'm using my unsigned int as a placeholder, i think I'm negating the danger of an overflow.

I would run this myself, but I don't have an accessible linux box right now.

Any input on this would be greatly appreciated.",3
10372348,04/29/2012 13:03:30,1265665,03/13/2012 05:04:59,30,0,Sqlite passing database through functions,"Hello im trying to pass my sqlite datta base through to a function and then through to another one again. here is my code.

    //database Name
    // Create a handle for database connection, create a pointer to sqlite3
    sqlite3 *dataDB;
    
       
    
    //I send it through to the function here
    // Execute the query for creating table
    retval = sqlite3_exec(dataDB,create_students,0,0,0);
    
    
    //my prototypes
    int readInFiles(sqlite3 ** dataDB);
    void addCourse(sqlite3 ** dataDB, struct course,int k);

    //call within the readin files function
    addCourse(&dataDB,deg,k);

now sorry about the poor layout of the question but here is my error

    ""database.c"", line 50: warning: argument #1 is incompatible with prototype:
            prototype: pointer to pointer to struct sqlite3 {} : ""database.h"", line 51



",c,sqlite,function,passing,,,open,0,183,5,"Sqlite passing database through functions Hello im trying to pass my sqlite datta base through to a function and then through to another one again. here is my code.

    //database Name
    // Create a handle for database connection, create a pointer to sqlite3
    sqlite3 *dataDB;
    
       
    
    //I send it through to the function here
    // Execute the query for creating table
    retval = sqlite3_exec(dataDB,create_students,0,0,0);
    
    
    //my prototypes
    int readInFiles(sqlite3 ** dataDB);
    void addCourse(sqlite3 ** dataDB, struct course,int k);

    //call within the readin files function
    addCourse(&dataDB,deg,k);

now sorry about the poor layout of the question but here is my error

    ""database.c"", line 50: warning: argument #1 is incompatible with prototype:
            prototype: pointer to pointer to struct sqlite3 {} : ""database.h"", line 51



",4
7849684,10/21/2011 12:56:22,1007137,10/21/2011 12:47:01,1,0,What is semantic errors in C-language & give some examples?,"There are basically three types of errors.

1) Syntax errors. These are invalid code the compiler doesn't understand, e.g. your example of multiplying a string with an integer in C. The compiler will detect them, because it can't compile them.

2) Semantic errors. These are valid code the compiler understands, but they do not what you, the programmer, intended. These may be using the wrong variable, the wrong operation, or operations in the wrong order. There is no way for the compiler to detect them.

There is a third class, which can be the most expensive:

3) Design errors. The code is correct and bug-free and does exactly what you've intended. But your intentions are wrong, e.g. based on wrong assumptions, wrong models, or you've used the wrong formulars, misunderstood the customer, or such.",c,,,,,10/21/2011 13:04:27,not a real question,1,130,10,"What is semantic errors in C-language & give some examples? There are basically three types of errors.

1) Syntax errors. These are invalid code the compiler doesn't understand, e.g. your example of multiplying a string with an integer in C. The compiler will detect them, because it can't compile them.

2) Semantic errors. These are valid code the compiler understands, but they do not what you, the programmer, intended. These may be using the wrong variable, the wrong operation, or operations in the wrong order. There is no way for the compiler to detect them.

There is a third class, which can be the most expensive:

3) Design errors. The code is correct and bug-free and does exactly what you've intended. But your intentions are wrong, e.g. based on wrong assumptions, wrong models, or you've used the wrong formulars, misunderstood the customer, or such.",1
8754030,01/06/2012 06:02:46,1133683,01/06/2012 05:30:49,1,0,array of pointers segmantation fault c,"

 void quickSortMain(char items[][2000], int count);
    void quickSort(char items[][2000], int left, int right);
    int main(void)
    {
	int n,k=2001000,i=0,q,temp=0;
		printf(""enter num of strings\n"");
	scanf(""%d"",&n);
	char strings[n][2000];
	char *final_set[10];
	printf(""enter strings\n"");
	while(i<n)
	{
		scanf(""%s"",&strings[i]);
		int l=0,k=0;
				l=strlen(strings[i]);
		while(k<l)
		{
			int count=1;
							char *t=malloc(2000*sizeof(char));
			while(count<=(l-k))
			{
				strncpy(t,strings[i]+k,count);
				printf(""t is :%s\n"",t);
				int b=0,use=0;
				while(strlen(final_set[b]))//this loop runs for b=0 and gives seg fault for b=1..why?
				{
						printf(""t is :%s\n"",t);
					if(!strcmp(final_set[b],t))
					{
							printf(""t is here :%s\n"",t);
						use=1;
						break;
					}
					
					b++;
						printf(""t is not here:%s\n"",t);
				}
					printf(""t is :%s\n"",t);
				if(use==1)
				{
					count++;
					continue;
				}
				final_set[temp]=malloc(count*sizeof(char));
				strcpy(final_set[temp],t);
				//	printf(""element is: %s\n"",final_set[temp]);
					//ok(final_set[temp]);
				temp++;
				count++;
			}
			k++;
		}
		i++;
	}
	quickSortMain(final_set,temp);
	i=0;
	printf(""enter num of queries\n"");
	scanf(""%d"",&q);
	int queries_k[q];
	while(i<q)
	{
		scanf(""%d"",&queries_k[i]);
		if(!strlen(final_set[queries_k[i]-1]))
		printf(""INVALID"");
		else
		printf(""%s\n"",final_set[queries_k[i]-1]);
		i++;
	}
    }	
     void quickSortMain(char items[][2000], int count)
     {
       quickSort(items, 0, count-1);
     }
     void quickSort(char items[][2000], int left, int right)
     {
     int i, j;
     char *x;
     char temp[10];

     i = left;
     j = right;
     x = items[(left+right)/2];

     do {
     while((strcmp(items[i],x) < 0) && (i < right)) {
       i++;
     }
     while((strcmp(items[j],x) > 0) && (j > left)) {
        j--;
     }
     if(i <= j) {
      strcpy(temp, items[i]);
      strcpy(items[i], items[j]);
      strcpy(items[j], temp);
      i++;
      j--;
     }
     } while(i <= j);

     if(left < j) {
     quickSort(items, left, j);
     }
     if(i < right) {
     quickSort(items, i, right);
     }
     }
",c,arrays,pointers,fault,segmentation,01/06/2012 09:16:11,not a real question,1,306,6,"array of pointers segmantation fault c 

 void quickSortMain(char items[][2000], int count);
    void quickSort(char items[][2000], int left, int right);
    int main(void)
    {
	int n,k=2001000,i=0,q,temp=0;
		printf(""enter num of strings\n"");
	scanf(""%d"",&n);
	char strings[n][2000];
	char *final_set[10];
	printf(""enter strings\n"");
	while(i<n)
	{
		scanf(""%s"",&strings[i]);
		int l=0,k=0;
				l=strlen(strings[i]);
		while(k<l)
		{
			int count=1;
							char *t=malloc(2000*sizeof(char));
			while(count<=(l-k))
			{
				strncpy(t,strings[i]+k,count);
				printf(""t is :%s\n"",t);
				int b=0,use=0;
				while(strlen(final_set[b]))//this loop runs for b=0 and gives seg fault for b=1..why?
				{
						printf(""t is :%s\n"",t);
					if(!strcmp(final_set[b],t))
					{
							printf(""t is here :%s\n"",t);
						use=1;
						break;
					}
					
					b++;
						printf(""t is not here:%s\n"",t);
				}
					printf(""t is :%s\n"",t);
				if(use==1)
				{
					count++;
					continue;
				}
				final_set[temp]=malloc(count*sizeof(char));
				strcpy(final_set[temp],t);
				//	printf(""element is: %s\n"",final_set[temp]);
					//ok(final_set[temp]);
				temp++;
				count++;
			}
			k++;
		}
		i++;
	}
	quickSortMain(final_set,temp);
	i=0;
	printf(""enter num of queries\n"");
	scanf(""%d"",&q);
	int queries_k[q];
	while(i<q)
	{
		scanf(""%d"",&queries_k[i]);
		if(!strlen(final_set[queries_k[i]-1]))
		printf(""INVALID"");
		else
		printf(""%s\n"",final_set[queries_k[i]-1]);
		i++;
	}
    }	
     void quickSortMain(char items[][2000], int count)
     {
       quickSort(items, 0, count-1);
     }
     void quickSort(char items[][2000], int left, int right)
     {
     int i, j;
     char *x;
     char temp[10];

     i = left;
     j = right;
     x = items[(left+right)/2];

     do {
     while((strcmp(items[i],x) < 0) && (i < right)) {
       i++;
     }
     while((strcmp(items[j],x) > 0) && (j > left)) {
        j--;
     }
     if(i <= j) {
      strcpy(temp, items[i]);
      strcpy(items[i], items[j]);
      strcpy(items[j], temp);
      i++;
      j--;
     }
     } while(i <= j);

     if(left < j) {
     quickSort(items, left, j);
     }
     if(i < right) {
     quickSort(items, i, right);
     }
     }
",5
5740853,04/21/2011 07:19:53,717886,04/20/2011 20:45:32,1,0,loading encryped shared objects using the rtld / free loader/linkers,"I am doing some research in encryption/software protection. I want to link dynamically encrypted shared objects (Linux, x86 Architecture, ELF32/64 format)

- The code to be protected is contained (encrypted, no valid ELF) in the shared object. 
- The object itself is a valid ELF-file, containing an init method 
- The decryption should be started, dependend on a available license in the init function called by the loader. 
- After encryption the code is present as valid ELF-file in memory.

There were some further requirements:  

- The decrypted code must not be stored (even temporarily on disk) - prevent easy object dump and code reuse  
- The protection algorithm must not be published, so I may not use parts of the GNU code (even people do a great work there!)

I think the hard way is to reimplement a loader/linker providing the needed functionality... Perhaps there may be a way to use the Linux rtld, or parts of it, other linkers? 
Is there an easier way?  
Thanks for every idea/hint


Some related links/Infos
  
- a packer solving a similar kind of problem: http://www.upx.org/
(did not work for one of my test shared objects)
- Some details about loading shared objects http://smilax.org/135/dsohowto.pdf

Thanks in advance,
-- Uhli",c,linux,elf,,,,open,0,202,10,"loading encryped shared objects using the rtld / free loader/linkers I am doing some research in encryption/software protection. I want to link dynamically encrypted shared objects (Linux, x86 Architecture, ELF32/64 format)

- The code to be protected is contained (encrypted, no valid ELF) in the shared object. 
- The object itself is a valid ELF-file, containing an init method 
- The decryption should be started, dependend on a available license in the init function called by the loader. 
- After encryption the code is present as valid ELF-file in memory.

There were some further requirements:  

- The decrypted code must not be stored (even temporarily on disk) - prevent easy object dump and code reuse  
- The protection algorithm must not be published, so I may not use parts of the GNU code (even people do a great work there!)

I think the hard way is to reimplement a loader/linker providing the needed functionality... Perhaps there may be a way to use the Linux rtld, or parts of it, other linkers? 
Is there an easier way?  
Thanks for every idea/hint


Some related links/Infos
  
- a packer solving a similar kind of problem: http://www.upx.org/
(did not work for one of my test shared objects)
- Some details about loading shared objects http://smilax.org/135/dsohowto.pdf

Thanks in advance,
-- Uhli",3
10571172,05/13/2012 10:57:49,1341622,04/18/2012 14:23:29,70,7,C library tutorial,"I' m trying to learn how to program in `C`. As `C` is similar to `C++` I don't have any problems learning the basic commands(like `for, while, do`, variable declaring, preprocessor directives, ect.). But I find it hard to understand the `C`'s libraries. Does anyone know any tutorials about the C libraries with code examples?",c,,,,,05/13/2012 11:13:32,not constructive,1,55,3,"C library tutorial I' m trying to learn how to program in `C`. As `C` is similar to `C++` I don't have any problems learning the basic commands(like `for, while, do`, variable declaring, preprocessor directives, ect.). But I find it hard to understand the `C`'s libraries. Does anyone know any tutorials about the C libraries with code examples?",1
10742988,05/24/2012 18:08:24,357482,06/03/2010 12:47:44,39,0,free the space allocated in c with malloc,"I have a question about this code:

    typedef struct pop {
	unsigned long int *np; // matrix
	unsigned long int f;
	long double fp; 
	unsigned long int *R; // matrix
	unsigned long int *C; // matrix
	unsigned long int Dp;
	unsigned long int Ds;
	unsigned long int count;
	struct popolazione *ptrTempLst; // pointer
	struct popolazione *leftTree;  // left tree pointer
	struct popolazione *rightTree; // right tree pointer
    } Node; 



When I free space allocated for this struct, prior have I to free pointer to matrix inside struct?


For example,

     Node *ptr=(Node *) malloc(sizeOf(Node));
     ptr->np=(unsigned long int *)malloc(10*sizeOf(unsigned long int));
     
     /*code code code*/

     // is necessary: free(ptr->np); 

     free(ptr);


Thanks in advance


",c,struct,malloc,free,typedef,,open,0,131,8,"free the space allocated in c with malloc I have a question about this code:

    typedef struct pop {
	unsigned long int *np; // matrix
	unsigned long int f;
	long double fp; 
	unsigned long int *R; // matrix
	unsigned long int *C; // matrix
	unsigned long int Dp;
	unsigned long int Ds;
	unsigned long int count;
	struct popolazione *ptrTempLst; // pointer
	struct popolazione *leftTree;  // left tree pointer
	struct popolazione *rightTree; // right tree pointer
    } Node; 



When I free space allocated for this struct, prior have I to free pointer to matrix inside struct?


For example,

     Node *ptr=(Node *) malloc(sizeOf(Node));
     ptr->np=(unsigned long int *)malloc(10*sizeOf(unsigned long int));
     
     /*code code code*/

     // is necessary: free(ptr->np); 

     free(ptr);


Thanks in advance


",5
10554071,05/11/2012 15:11:34,1061770,11/23/2011 11:18:56,8,0,set last 3 bits of integer to zero in portable form,"Exam tomorrow on UNIX (c language) and this is a past paper question im stuck on.

Suggest an expression that sets the last 3 bits of integer
variable x to zero in a portable form.

anyone walk me through a solution please my notes are terrible?",c,homework,unix,bits,exam,05/12/2012 15:09:10,not a real question,1,43,11,"set last 3 bits of integer to zero in portable form Exam tomorrow on UNIX (c language) and this is a past paper question im stuck on.

Suggest an expression that sets the last 3 bits of integer
variable x to zero in a portable form.

anyone walk me through a solution please my notes are terrible?",5
9773920,03/19/2012 16:25:43,753341,05/14/2011 05:48:17,2643,82,Issues with the C Standard Library?,"I've read from various sources about there being a lot of bugs, issues and design flaws in the C Standard library. Some to do with string handling functions, some with I/O etc. 

Is this true? If so, can anyone list some of the most common known issues?",c,bugs,stdio,standard-library,stdlib,03/20/2012 05:29:51,not constructive,1,47,6,"Issues with the C Standard Library? I've read from various sources about there being a lot of bugs, issues and design flaws in the C Standard library. Some to do with string handling functions, some with I/O etc. 

Is this true? If so, can anyone list some of the most common known issues?",5
8253937,11/24/2011 08:17:26,642956,03/03/2011 12:23:03,3,0,Adding errors log C,"I am working on a project in C under Linux environment, and looking for an efficient way to add errors to a log file. 
I tried to use Syslog with the next initialization:

    setlogmask(LOG_UPTO(7));
    openlog(name, LOG_CONS | LOG_NDELAY | LOG_PID, LOG_USER);

But it seems it works too slow and i need it to work very fast..
Can someone help with that? Maybe the syslog is not the right approach?",c,linux,logging,syslog,,,open,0,73,4,"Adding errors log C I am working on a project in C under Linux environment, and looking for an efficient way to add errors to a log file. 
I tried to use Syslog with the next initialization:

    setlogmask(LOG_UPTO(7));
    openlog(name, LOG_CONS | LOG_NDELAY | LOG_PID, LOG_USER);

But it seems it works too slow and i need it to work very fast..
Can someone help with that? Maybe the syslog is not the right approach?",4
6661819,07/12/2011 09:08:29,840380,07/12/2011 09:08:29,1,0,error in following c code,"I have written this code to reverse an array using functions. But there is an error in line 24 saying ' ) expected'. I have read it again and again but i couldn't find the error. Can anybody please reveal it and tell me how to remove it?

    #include<stdio.h>
    #include<conio.h>
    #define max 5

    /*function prototype*/
    void reverse(int[],int);
       
    void main()
    {
	    int arr[max]={1,2,3,4,5};
	    int i,j;
	    clrscr();
	    printf(""the list before reversing:\n"");
	    for(i=0;i<max;i++)
		    printf(""%d"",arr[i]);
	    reverse(arr,max);
	    printf(""\n the list after reversing:\n"");
	    for(i=0;i<max;i++)
		    printf(""%d"",arr[i]);
	    getch();
    }

    /*function for reversing elements of array*/
    void reverse(int num[],int max)
   {
	     int i,j,temp;
	     (i=0,j=max-1;i<max/2;i++,j--)
	     {
	            temp=num[i];
		    num[i]=num[j];
		    num[j]=temp;
  	     }
   }
",c,,,,,11/11/2011 09:48:11,not a real question,1,210,5,"error in following c code I have written this code to reverse an array using functions. But there is an error in line 24 saying ' ) expected'. I have read it again and again but i couldn't find the error. Can anybody please reveal it and tell me how to remove it?

    #include<stdio.h>
    #include<conio.h>
    #define max 5

    /*function prototype*/
    void reverse(int[],int);
       
    void main()
    {
	    int arr[max]={1,2,3,4,5};
	    int i,j;
	    clrscr();
	    printf(""the list before reversing:\n"");
	    for(i=0;i<max;i++)
		    printf(""%d"",arr[i]);
	    reverse(arr,max);
	    printf(""\n the list after reversing:\n"");
	    for(i=0;i<max;i++)
		    printf(""%d"",arr[i]);
	    getch();
    }

    /*function for reversing elements of array*/
    void reverse(int num[],int max)
   {
	     int i,j,temp;
	     (i=0,j=max-1;i<max/2;i++,j--)
	     {
	            temp=num[i];
		    num[i]=num[j];
		    num[j]=temp;
  	     }
   }
",1
5796108,04/26/2011 20:32:57,480807,10/19/2010 17:38:13,312,5,C program converts number from one base to another,"I'm helping a friend with a homework assignment, she needs to write a simple c program that converts a number from one base to another.

A call to the function will look something like:
>convert 40514 10 16

Where:
20514 is the INPUT NUMBER
10 is the BASE of the INPUT NUMBER
16 is the BASE of the OUTPUT NUMBER

I have a crude familiarity with C, is this a simple thing to do?",c,hex,converter,,,04/27/2011 03:16:21,not a real question,1,67,9,"C program converts number from one base to another I'm helping a friend with a homework assignment, she needs to write a simple c program that converts a number from one base to another.

A call to the function will look something like:
>convert 40514 10 16

Where:
20514 is the INPUT NUMBER
10 is the BASE of the INPUT NUMBER
16 is the BASE of the OUTPUT NUMBER

I have a crude familiarity with C, is this a simple thing to do?",3
5958460,05/11/2011 02:06:06,747888,05/11/2011 02:03:21,1,0,Help building a calculator using C and 8051,"The calculator includes a 4x4 keypad and LCD, let me know if you need full information and it will be great if you can help",c,microcontroller,calculator,8051,keypad,05/11/2011 02:51:32,not a real question,1,25,8,"Help building a calculator using C and 8051 The calculator includes a 4x4 keypad and LCD, let me know if you need full information and it will be great if you can help",5
4940406,02/09/2011 01:11:52,604065,02/05/2011 03:31:09,10,0," array, 2 elements sum to a target","in an array, use 2 elements , do sum, get a target result.
This is an amazon interview question. Want to know answer.
Thanks.",c,interview-questions,amazon,,,02/09/2011 01:24:17,not a real question,1,22,8," array, 2 elements sum to a target in an array, use 2 elements , do sum, get a target result.
This is an amazon interview question. Want to know answer.
Thanks.",3
10086754,04/10/2012 10:08:43,885386,08/09/2011 06:59:11,52,1,How to create a a master slave server system?,"I need to create 5 server programs such that one of it is the master server.

When a client tries to make a connection the master server checks which of the server has the least load(including itself) and makes a connection with the free server.

I guess i should use shared memory concepts where each server program writes to the memory its load and process id. But as I am new to this field I am do not even have a clue about solving the problem.

Any relevant links or ideas will help.

Ps: I am working in unix environment",c,sockets,client-server,master-slave,,04/10/2012 12:56:16,not a real question,1,96,9,"How to create a a master slave server system? I need to create 5 server programs such that one of it is the master server.

When a client tries to make a connection the master server checks which of the server has the least load(including itself) and makes a connection with the free server.

I guess i should use shared memory concepts where each server program writes to the memory its load and process id. But as I am new to this field I am do not even have a clue about solving the problem.

Any relevant links or ideas will help.

Ps: I am working in unix environment",4
7263123,08/31/2011 20:40:50,781331,06/02/2011 14:43:33,1,0,Ruby C Extension - 64bit pointer being truncated causing a segfault,"I'm working on trying to get a ruby extension written in c, working with ruby 1.9.2 on Mac OSX. I keep getting a segfault caused by a 64-bit pointer returned from a function being truncated to a 32-bit value and trying to access low memory.

Here's what I've figured out about it. VALUE is a long, defined in the ruby source code, and the code won't compile unless sizeof(long) is 8 bytes.

In file_b.c:

    VALUE
    rb_helper_function_foo(VALUE file)
    {
      VALUE blah;

      ...
      
      //Using gdb, blah right here is a 64bit address, ex: 0x1 009d 62a0
      return blah;
    }

In file_a.c

    VALUE
    func_do_stuff(int argc, VALUE *argv, VALUE obj)
    {
      VALUE filename, file_path;

      ...
      
      // But here, the size of what is returned is 4 bytes
      // file_path has a size of 8 bytes though
      file_path = rb_helper_function_foo(filename);

      //This statement will segfault :-(
      if(!RTEST(file_path))
      {
        ...
      }
      ...
    }

At the end of the function call, the return value has the correct address, but only the lower 4 bytes get returned: 0x009d52a0 instead of 0x1009d52a0. Accessing the low memory address is causing a segfault.

In the assembly code that gets called during the return, there's this instruction

    movslq %eax, %r12
which only copies the lower 4 bytes, but I need all 8 bytes of %rax to be copied.

I'm on ruby 1.9.2-p290 (though it did the same with p180), Mac OSX 10.6.8, using xcode 4.0.1 (with gcc 4.2.1), but I also tried upgrading to gcc 4.6.1. It has also previously tried xcode 3.2.

Thanks for any help you can give me.",c,ruby,extension,64bit,segmentation-fault,,open,0,366,11,"Ruby C Extension - 64bit pointer being truncated causing a segfault I'm working on trying to get a ruby extension written in c, working with ruby 1.9.2 on Mac OSX. I keep getting a segfault caused by a 64-bit pointer returned from a function being truncated to a 32-bit value and trying to access low memory.

Here's what I've figured out about it. VALUE is a long, defined in the ruby source code, and the code won't compile unless sizeof(long) is 8 bytes.

In file_b.c:

    VALUE
    rb_helper_function_foo(VALUE file)
    {
      VALUE blah;

      ...
      
      //Using gdb, blah right here is a 64bit address, ex: 0x1 009d 62a0
      return blah;
    }

In file_a.c

    VALUE
    func_do_stuff(int argc, VALUE *argv, VALUE obj)
    {
      VALUE filename, file_path;

      ...
      
      // But here, the size of what is returned is 4 bytes
      // file_path has a size of 8 bytes though
      file_path = rb_helper_function_foo(filename);

      //This statement will segfault :-(
      if(!RTEST(file_path))
      {
        ...
      }
      ...
    }

At the end of the function call, the return value has the correct address, but only the lower 4 bytes get returned: 0x009d52a0 instead of 0x1009d52a0. Accessing the low memory address is causing a segfault.

In the assembly code that gets called during the return, there's this instruction

    movslq %eax, %r12
which only copies the lower 4 bytes, but I need all 8 bytes of %rax to be copied.

I'm on ruby 1.9.2-p290 (though it did the same with p180), Mac OSX 10.6.8, using xcode 4.0.1 (with gcc 4.2.1), but I also tried upgrading to gcc 4.6.1. It has also previously tried xcode 3.2.

Thanks for any help you can give me.",5
3611814,08/31/2010 17:58:08,436219,08/31/2010 17:51:38,1,0,palindrome or reverse in c,how to reverse the input number and get the output,c,,,,,08/31/2010 18:08:51,not a real question,1,10,5,palindrome or reverse in c how to reverse the input number and get the output,1
8548210,12/17/2011 22:00:56,1103942,12/17/2011 21:55:27,1,0,C do-while loop,"Hello I am a beginner adn i'm trying to write a program with do..while loop  for: list all the numbers from 100 downwards that are dividable by 7 and 5 but not 11.  
can you help me

thanks

Andy",c,do-while,,,,12/17/2011 22:20:19,not constructive,1,39,3,"C do-while loop Hello I am a beginner adn i'm trying to write a program with do..while loop  for: list all the numbers from 100 downwards that are dividable by 7 and 5 but not 11.  
can you help me

thanks

Andy",2
6276629,06/08/2011 09:21:28,227823,12/09/2009 09:27:55,1,0,convert from geodetic coordinates (ECEF) to local ENU,"How to convert X,Y,Z from local reference (ENU) to world reference (ECEF) and reverse it ??

Input: (lat,long) = center of the local reference system.
       x,y,z = position of the point,in local system reference.
Output: (lat,long)= poistion of the point in WGS84.
Also: reverse coordinate.

I suppose the step is:

1) convert Xlocal,Ylocal,Zlocal  -> Xecef,Yecef,Zecef

2) convert Xecef,Yecef,Zecef     -> Lat,Long (WGS84)


And than


1) convert Lat,Long(WGS84)       -> Xecef,Yecef,Zecef

2) convert Xecef,Yecef,Zecef     -> Xlocal,Ylocal,Zlocal


Thanks all!!!",c,gps,wgs84,,,,open,0,86,8,"convert from geodetic coordinates (ECEF) to local ENU How to convert X,Y,Z from local reference (ENU) to world reference (ECEF) and reverse it ??

Input: (lat,long) = center of the local reference system.
       x,y,z = position of the point,in local system reference.
Output: (lat,long)= poistion of the point in WGS84.
Also: reverse coordinate.

I suppose the step is:

1) convert Xlocal,Ylocal,Zlocal  -> Xecef,Yecef,Zecef

2) convert Xecef,Yecef,Zecef     -> Lat,Long (WGS84)


And than


1) convert Lat,Long(WGS84)       -> Xecef,Yecef,Zecef

2) convert Xecef,Yecef,Zecef     -> Xlocal,Ylocal,Zlocal


Thanks all!!!",3
7511008,09/22/2011 07:19:30,757507,05/17/2011 14:05:57,1,0,Don't understand the output of this C program,"Here's the code:

    #include <stdio.h>
    
    int main (void)
    {
        int value[10];
        int index;
        
        value[0] = 197;
        value[2] = -100;
        value[5] = 350;
        value[3] = value[0] + value[5];
        value[9] = value[5] / 10;
        --value[2];
        
        for(index = 0; index < 10; ++index)
            printf(""value[%i] = %i\n"", index, value[index]);
        return 0;
    }

Here's the output when compile:

    value[0] = 197
    value[1] = 0
    value[2] = -101
    value[3] = 547
    value[4] = 0
    value[5] = 350
    value[6] = 0
    value[7] = 0
    value[8] = 1784505816
    value[9] = 35

I don't understand why value[8] returns 1784505816? 
Isn't value[8] supposed be = value[6] = value[7] = 0? By the way, I compile the code via gcc under Mac OS X Lion.",c,,,,,,open,0,255,8,"Don't understand the output of this C program Here's the code:

    #include <stdio.h>
    
    int main (void)
    {
        int value[10];
        int index;
        
        value[0] = 197;
        value[2] = -100;
        value[5] = 350;
        value[3] = value[0] + value[5];
        value[9] = value[5] / 10;
        --value[2];
        
        for(index = 0; index < 10; ++index)
            printf(""value[%i] = %i\n"", index, value[index]);
        return 0;
    }

Here's the output when compile:

    value[0] = 197
    value[1] = 0
    value[2] = -101
    value[3] = 547
    value[4] = 0
    value[5] = 350
    value[6] = 0
    value[7] = 0
    value[8] = 1784505816
    value[9] = 35

I don't understand why value[8] returns 1784505816? 
Isn't value[8] supposed be = value[6] = value[7] = 0? By the way, I compile the code via gcc under Mac OS X Lion.",1
8858114,01/13/2012 22:28:54,1148629,01/13/2012 22:23:44,1,0,"How to upper case ""n"" first letters in each word from a sentence that given in the input?","    This program doesnt work well it uppercase me the whole sentence.
if someone can tell me how to solve it it wil be amazing!
i get a string from the input and a number ""Shift"" (n) and i need to uper case in each word the first ""n"" letter
    
    
     #include <ctype.h>
    #include <stdio.h>
     #include <stdlib.h>
    
    
    
    
          int main(int argc, char *argv[])
          {
             char text;
             int shift = 0;
             if(argc != 2)
             {
                printf(""Usage: shift_chars shift\n"");
                return 1;
             }
             shift = atoi(argv[1]);
    
    
             while((text=getchar()) != EOF)
             {
    		 		 int i = shift;	
    		
                if(!isalpha(text))
    			{				
    			putchar(text);
    
    
    			}else
    			
    			{
    				if(i > 0 ) {
    					putchar(toupper(text));
    					i--;
    					continue;
    				}
    			}
    
    		 }
    	  return 0;
    	  }
    
    	  

",c,,,,,01/16/2012 10:33:41,too localized,1,390,18,"How to upper case ""n"" first letters in each word from a sentence that given in the input?     This program doesnt work well it uppercase me the whole sentence.
if someone can tell me how to solve it it wil be amazing!
i get a string from the input and a number ""Shift"" (n) and i need to uper case in each word the first ""n"" letter
    
    
     #include <ctype.h>
    #include <stdio.h>
     #include <stdlib.h>
    
    
    
    
          int main(int argc, char *argv[])
          {
             char text;
             int shift = 0;
             if(argc != 2)
             {
                printf(""Usage: shift_chars shift\n"");
                return 1;
             }
             shift = atoi(argv[1]);
    
    
             while((text=getchar()) != EOF)
             {
    		 		 int i = shift;	
    		
                if(!isalpha(text))
    			{				
    			putchar(text);
    
    
    			}else
    			
    			{
    				if(i > 0 ) {
    					putchar(toupper(text));
    					i--;
    					continue;
    				}
    			}
    
    		 }
    	  return 0;
    	  }
    
    	  

",1
8168572,11/17/2011 14:16:44,551625,12/22/2010 19:40:35,121,8,sprintf write to string with \n,"I have this code:

    str1= ""a"";
    str2= ""b"";
    sprintf(string, ""0 %s %s\n"", str1, str2);

string then contains:

<pre>""0 a b""</pre>

instead of (what I want):
<pre>""0 a b
""</pre>

How can I solve that?

Note: I place the quoting of the var string inside "" so that you could understand the situation.",c,sprintf,,,,11/22/2011 08:39:08,too localized,1,54,6,"sprintf write to string with \n I have this code:

    str1= ""a"";
    str2= ""b"";
    sprintf(string, ""0 %s %s\n"", str1, str2);

string then contains:

<pre>""0 a b""</pre>

instead of (what I want):
<pre>""0 a b
""</pre>

How can I solve that?

Note: I place the quoting of the var string inside "" so that you could understand the situation.",2
9865642,03/26/2012 01:37:10,1276591,03/18/2012 06:32:25,3,0,having issue printing data out to output file,"I'm having a problem with getting this code to print out to file due to some undefined behavior. It seems that when I test it the output file opened but was empty. can anyone run it on their system and tell me if it work on your system or is it not working at all. Also can you provide me with the output file if you run it. 

here is the code
http://ideone.com/ku7qc
and the data for the file 
http://ideone.com/TY1U8
thanks",c,output,undefined-behavior,,,03/26/2012 13:24:07,not a real question,1,78,8,"having issue printing data out to output file I'm having a problem with getting this code to print out to file due to some undefined behavior. It seems that when I test it the output file opened but was empty. can anyone run it on their system and tell me if it work on your system or is it not working at all. Also can you provide me with the output file if you run it. 

here is the code
http://ideone.com/ku7qc
and the data for the file 
http://ideone.com/TY1U8
thanks",3
10607591,05/15/2012 19:35:00,682404,03/29/2011 07:57:54,1304,60,Which of these two loops is faster?,"I need to iterate through a set of bytes, searching for a 4 byte value (all 4 bytes are the same). The length of the data is variable and these bytes can be anywhere inside the data; I'm looking for the first instance. I'm trying to find the fastest possible implementation because this logic runs in a critical part of my code.

This will only ever run on x86 & x64, under Windows.

    typedef Byte unsigned char;
    typedef BytePtr Byte*;
    typedef UInt32 unsigned int;
    typedef UInt32Ptr UInt32*;

    const Byte MARKER_BYTE = 0xAA;
    const UInt32 MARKER = 0xAAAAAAAA;

    UInt32 nDataLength = ...;
    BytePtr pData = ...;
    BytePtr pEnd = pData + nDataLength;

    // Option 1 -------------------------------------------
    while ( pData < pEnd )
    {
        if ( *( (UInt32Ptr) pData ) == MARKER )
        {
            ... // Do something here
            break;
        }

        pData++;
    }

    // Option 2 -------------------------------------------
    while ( pData < pEnd )
    {
        if ( ( *pData == MARKER_BYTE ) && ( *( (UInt32Ptr) pData ) == MARKER ) )
        {
            ... // Do something here
            break;
        }

        pData++;
    }

I think `Option 2` is faster but I'm not sure if my reasoning is correct.

`Option 1` first reads 4 bytes from memory, checks it against the 4-byte constant and if not found, it steps onto the next byte and starts over. The next 4-byte ready from memory is going to overlap 3 bytes already read so the same bytes need to be fetched again. Most bytes before my 4-byte marker would be read twice.

`Option 2` only reads 1 byte at a time and if that single byte is a match, it reads the full 4-byte value from that address. This way, all bytes are read only once and only the 4 matching bytes are read twice.

Is my reasoning correct or am I overlooking something?

And before someone brings it up, yes, I really do need to perform this kind of optimization. :)",c,windows,performance,x86,x64,,open,0,469,7,"Which of these two loops is faster? I need to iterate through a set of bytes, searching for a 4 byte value (all 4 bytes are the same). The length of the data is variable and these bytes can be anywhere inside the data; I'm looking for the first instance. I'm trying to find the fastest possible implementation because this logic runs in a critical part of my code.

This will only ever run on x86 & x64, under Windows.

    typedef Byte unsigned char;
    typedef BytePtr Byte*;
    typedef UInt32 unsigned int;
    typedef UInt32Ptr UInt32*;

    const Byte MARKER_BYTE = 0xAA;
    const UInt32 MARKER = 0xAAAAAAAA;

    UInt32 nDataLength = ...;
    BytePtr pData = ...;
    BytePtr pEnd = pData + nDataLength;

    // Option 1 -------------------------------------------
    while ( pData < pEnd )
    {
        if ( *( (UInt32Ptr) pData ) == MARKER )
        {
            ... // Do something here
            break;
        }

        pData++;
    }

    // Option 2 -------------------------------------------
    while ( pData < pEnd )
    {
        if ( ( *pData == MARKER_BYTE ) && ( *( (UInt32Ptr) pData ) == MARKER ) )
        {
            ... // Do something here
            break;
        }

        pData++;
    }

I think `Option 2` is faster but I'm not sure if my reasoning is correct.

`Option 1` first reads 4 bytes from memory, checks it against the 4-byte constant and if not found, it steps onto the next byte and starts over. The next 4-byte ready from memory is going to overlap 3 bytes already read so the same bytes need to be fetched again. Most bytes before my 4-byte marker would be read twice.

`Option 2` only reads 1 byte at a time and if that single byte is a match, it reads the full 4-byte value from that address. This way, all bytes are read only once and only the 4 matching bytes are read twice.

Is my reasoning correct or am I overlooking something?

And before someone brings it up, yes, I really do need to perform this kind of optimization. :)",5
7844033,10/21/2011 01:15:58,697461,04/07/2011 19:22:48,154,0,How to find if kernel virtual address is a pinned memory,"Is there any way to find out if any particular kernel virtual address is pinned? 

Thanks
Abhijeet",c,windows,linux,kernel,,10/21/2011 20:02:50,not a real question,1,16,11,"How to find if kernel virtual address is a pinned memory Is there any way to find out if any particular kernel virtual address is pinned? 

Thanks
Abhijeet",4
5814619,04/28/2011 06:38:05,703955,04/12/2011 11:26:37,4,0,"what is the meaning of printf("" "",...)","what is the meaning of printf("" "",...)",c,,,,,04/28/2011 07:01:15,not a real question,1,7,7,"what is the meaning of printf("" "",...) what is the meaning of printf("" "",...)",1
3522047,08/19/2010 13:06:28,425262,08/19/2010 13:06:28,1,0,how can sovle non linear simultaneous equations?,i am having 12 equations and 12 unkonwns... i want to solve these equations. please help me with software or package or source code.,c,,,,,08/19/2010 13:12:19,off topic,1,24,7,how can sovle non linear simultaneous equations? i am having 12 equations and 12 unkonwns... i want to solve these equations. please help me with software or package or source code.,1
3646730,09/05/2010 16:08:27,440089,09/05/2010 16:08:27,1,0,REALTEK 8139 NIC,I just wanted to write a program in C to get the Network Interface Card(NIC) details of realtek 8139. would you help me out...,c,,,,,09/05/2010 16:53:32,not a real question,1,24,3,REALTEK 8139 NIC I just wanted to write a program in C to get the Network Interface Card(NIC) details of realtek 8139. would you help me out...,1
9816325,03/22/2012 04:10:26,680441,03/28/2011 14:55:31,1082,25,Flexible Array Member (Zero Length Array),"In reference to [GCC's Zero Length Array][1] explanation:


This is particularly useful in the case when a struct is a header for a variable-length object. This is exactly my case. Furthermore, I am concerned with the alignment of my structs in the heap.

In this case, I still really do not understand what's useful about zero length arrays. How are they related to this particular situation?


EDIT:

Is it that I can put as much ""data"" as I want in there?


  [1]: http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html",c,arrays,struct,flexible-array-member,,,open,0,80,6,"Flexible Array Member (Zero Length Array) In reference to [GCC's Zero Length Array][1] explanation:


This is particularly useful in the case when a struct is a header for a variable-length object. This is exactly my case. Furthermore, I am concerned with the alignment of my structs in the heap.

In this case, I still really do not understand what's useful about zero length arrays. How are they related to this particular situation?


EDIT:

Is it that I can put as much ""data"" as I want in there?


  [1]: http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html",4
7904663,10/26/2011 15:05:21,1013566,10/25/2011 21:17:39,1,0,Arch or Gentoo?? which one better suits FPGA/C/C++ developers needs,"For a couple of months now I was trying to find a Linux distro for a workstation. After some research I've finally nailed it down to two competitors: Arch and Gentoo.

Key features:

 - simplicity (ability to build the system bottom up)
 - customization
 - optimization
 - performance
 - rolling release
 - developer-based community
 - ability to learn/grow on it (basically knowledge gain)

I don't want to start another flame war.. rather a discussion on how each of the two can/can't feed my needs.",c,linux,fpga,gentoo,archlinux,10/26/2011 15:16:17,not constructive,1,82,10,"Arch or Gentoo?? which one better suits FPGA/C/C++ developers needs For a couple of months now I was trying to find a Linux distro for a workstation. After some research I've finally nailed it down to two competitors: Arch and Gentoo.

Key features:

 - simplicity (ability to build the system bottom up)
 - customization
 - optimization
 - performance
 - rolling release
 - developer-based community
 - ability to learn/grow on it (basically knowledge gain)

I don't want to start another flame war.. rather a discussion on how each of the two can/can't feed my needs.",5
1318580,08/23/2009 13:41:50,23450,09/29/2008 13:52:59,103,5,Need help with Windows Journal Record Hook,"I want to build a software test automation software and I'm playing around with Windows Hooks for that.

So I built the following C code. Can anyone tell me how to correct it ?

#include ""windows.h""

// the call back function
LRESULT CALLBACK JournalRecordProc(int code, WPARAM wParam, LPARAM lParam)
{
	
	HHOOK hhk = 0;
	
	if (code > 0)
	{
		// save Data in File
	}

	if (code < 0)
	{
		// work done: now pass on to the next one that does hooking
		CallNextHookEx(hhk, code, wParam, lParam);
	}
	
	/*
	if (code == )
	{
		// ESC button pressed -> finished recording
		UnhookWindowsHookEx(hhk);
	}
	*/
		
}

int main()

{
	int iRet = 0;

	HHOOK hHook = 0;

	HINSTANCE hMod = 0;

	HOOKPROC (*hHookProc)(int, WPARAM, LPARAM);

        hHookProc = &JournalRecordProc;

	// type of hook, callback function handle, hinstance [dll ?], 0 for systemwide
	hHook =  SetWindowsHookEx(WH_JOURNALRECORD, hHookProc, hMod, 0);
	
	return iRet;
}

When I compile this I get the compiler errors:

error C2440: '=': 'LRESULT (__stdcall *)(int,WPARAM,LPARAM)' kann nicht in 'HOOKPROC (__cdecl *)(int,WPARAM,LPARAM)' konvertiert werden (could not be converted)

error C2440: 'Funktion': 'HOOKPROC (__cdecl *)(int,WPARAM,LPARAM)' kann nicht in 'HOOKPROC' konvertiert werden (could not be converted)

warning C4024: 'SetWindowsHookExA': Unterschiedliche Typen fr formalen und bergebenen Parameter 2",c,windows,hook,,,,open,0,174,7,"Need help with Windows Journal Record Hook I want to build a software test automation software and I'm playing around with Windows Hooks for that.

So I built the following C code. Can anyone tell me how to correct it ?

#include ""windows.h""

// the call back function
LRESULT CALLBACK JournalRecordProc(int code, WPARAM wParam, LPARAM lParam)
{
	
	HHOOK hhk = 0;
	
	if (code > 0)
	{
		// save Data in File
	}

	if (code < 0)
	{
		// work done: now pass on to the next one that does hooking
		CallNextHookEx(hhk, code, wParam, lParam);
	}
	
	/*
	if (code == )
	{
		// ESC button pressed -> finished recording
		UnhookWindowsHookEx(hhk);
	}
	*/
		
}

int main()

{
	int iRet = 0;

	HHOOK hHook = 0;

	HINSTANCE hMod = 0;

	HOOKPROC (*hHookProc)(int, WPARAM, LPARAM);

        hHookProc = &JournalRecordProc;

	// type of hook, callback function handle, hinstance [dll ?], 0 for systemwide
	hHook =  SetWindowsHookEx(WH_JOURNALRECORD, hHookProc, hMod, 0);
	
	return iRet;
}

When I compile this I get the compiler errors:

error C2440: '=': 'LRESULT (__stdcall *)(int,WPARAM,LPARAM)' kann nicht in 'HOOKPROC (__cdecl *)(int,WPARAM,LPARAM)' konvertiert werden (could not be converted)

error C2440: 'Funktion': 'HOOKPROC (__cdecl *)(int,WPARAM,LPARAM)' kann nicht in 'HOOKPROC' konvertiert werden (could not be converted)

warning C4024: 'SetWindowsHookExA': Unterschiedliche Typen fr formalen und bergebenen Parameter 2",3
3111452,06/24/2010 15:32:45,31516,10/25/2008 23:32:12,3678,111,GCC can't locate headers even when the search directory is correct,"Once again, GCC is making me feel like an idiot for having trouble with the simplest things. I've included a header:

    #include ""PDL.h""

Then, I try to compile:

    arm-none-linux-gnueabi-gcc -I/cygdrive/c/PalmPDK/include ...etc...

But it says:

> PDL.h: no such file or directory

I can change into the include directory I specified above and see PDL.h is there, but GCC just doesn't see it.",c,gcc,include,,,,open,0,64,11,"GCC can't locate headers even when the search directory is correct Once again, GCC is making me feel like an idiot for having trouble with the simplest things. I've included a header:

    #include ""PDL.h""

Then, I try to compile:

    arm-none-linux-gnueabi-gcc -I/cygdrive/c/PalmPDK/include ...etc...

But it says:

> PDL.h: no such file or directory

I can change into the include directory I specified above and see PDL.h is there, but GCC just doesn't see it.",3
10612518,05/16/2012 05:26:02,993389,10/13/2011 11:56:50,1,0,Using Minixml in Dev C++ on windows,"I cant find any info on how to get this working without using VC. 
All i want to do is read data from a xml file. 

How do i build just one library to link onto my project?

Thanks",c,xml,xml-parsing,,,06/01/2012 09:04:12,too localized,1,38,7,"Using Minixml in Dev C++ on windows I cant find any info on how to get this working without using VC. 
All i want to do is read data from a xml file. 

How do i build just one library to link onto my project?

Thanks",3
7045358,08/12/2011 19:29:13,48956,12/24/2008 19:29:33,621,12,How to cause macro expansion before concatonation?,"
    #define JNI_DECLARE( classname, methodname ) \
         classname  ## methodname( JNI* env ) 

    #define JAVA_CLASS Java_com_example
    void JNI_DECLARE( JAVA_CLASS, open ) {}


This expands to:

    void JAVA_CLASS_open( JNI* env ) {}

How do I get:

    void Java_com_example_open( JNI* env ) {}

?
",c,preprocessor,,,,,open,0,64,7,"How to cause macro expansion before concatonation? 
    #define JNI_DECLARE( classname, methodname ) \
         classname  ## methodname( JNI* env ) 

    #define JAVA_CLASS Java_com_example
    void JNI_DECLARE( JAVA_CLASS, open ) {}


This expands to:

    void JAVA_CLASS_open( JNI* env ) {}

How do I get:

    void Java_com_example_open( JNI* env ) {}

?
",2
6608379,07/07/2011 09:20:38,351763,05/27/2010 09:01:46,30,1,[C] Pthreads and undefined reference,"I'm approaching pthreads library in C, I have written down some dummy code in order to get acquainted, but as I try to compile this code, I get an undefined reference to pthread_create, even if I have included the proper library and the number of parameters passed to the function is correct. Can you please help me out?

My code is:

    #include <stdio.h>
    #include <stdlib.h>
    #include <pthread.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <unistd.h>
    #include <string.h>
    
    void *dummy_thread(void *arg)
    {
        pthread_exit(NULL);
    }
    
    void *dummy_fork(void *arg)
    {    
        exit(0);
    }
    
    void pthread_perror(char *string, int errcode)
    {
        char errmsg[256];
        strerror_r(errcode, errmsg, 256);
        printf(""%s:%s\n"", string, errmsg);
    }
    
    int main(int argc, char** argv) 
    {
        pthread_t *threads;
        int rc, nt, *pids;
        long threads_microsecs, fork_microsecs, t;
        struct timeval ora, dopo;
        float perc;
        
        if (argc != 2)
        {
            printf(""Numero di argomenti %d non valido.\n"", argc);
            exit(1);
        }
        nt = strtol(argv[1], NULL, 10);
        if (nt < 0)
        {
            printf(""Numero di thread non valido: %d"", nt);
            exit(1);
        }
        
        threads = (pthread_t *) malloc (nt * sizeof(pthread_t));
        pids = (int *) malloc (nt * sizeof(int));
        
        if (pids == NULL)
        {
            perror(""malloc"");
            exit(1);
        }
        
        gettimeofday(&ora, NULL);
        
        for (t = 0; t < nt; t++)
        {
            if (rc = pthread_create(&threads[t], NULL, dummy_thread, NULL)) 
            {
                pthread_perror(""pthread_create"", rc);
                exit(1);
            }
            gettimeofday(&dopo, NULL);
            threads_microsecs = dopo.tv_usec - ora.tv_usec;
            threads_microsecs += 1000000 * (dopo.tv_sec - ora.tv_sec);
            printf(""Tempo per la creazione dei thread %ld nsec.\n"", threads_microsecs);
            gettimeofday(&ora, NULL);
            
            for (t = 0; t < nt; t++)
            {
                if ((pids[t] = fork()) < 0)
                {
                    perror(""fork"");
                    exit(1);
                }
                if (pids[t] == 0)
                {
                    dummy_fork(NULL);
                } 
            }
            
             gettimeofday(&dopo, NULL);
             fork_microsecs = dopo.tv_usec - ora.tv_usec;
             fork_microsecs += 1000000 * (dopo.tv_sec - ora.tv_sec);
             printf(""Tempo per la creazione dei processi %ld nsec"", fork_microsecs);
             perc = 100 * (((float) fork_microsecs - threads_microsecs)/(float)fork_microsecs);
             printf(""(%.2f%%)\n"", perc);
             
            
        }
        return (EXIT_SUCCESS);
    }",c,reference,pthreads,undefined,,,open,0,1091,5,"[C] Pthreads and undefined reference I'm approaching pthreads library in C, I have written down some dummy code in order to get acquainted, but as I try to compile this code, I get an undefined reference to pthread_create, even if I have included the proper library and the number of parameters passed to the function is correct. Can you please help me out?

My code is:

    #include <stdio.h>
    #include <stdlib.h>
    #include <pthread.h>
    #include <sys/time.h>
    #include <sys/types.h>
    #include <sys/wait.h>
    #include <unistd.h>
    #include <string.h>
    
    void *dummy_thread(void *arg)
    {
        pthread_exit(NULL);
    }
    
    void *dummy_fork(void *arg)
    {    
        exit(0);
    }
    
    void pthread_perror(char *string, int errcode)
    {
        char errmsg[256];
        strerror_r(errcode, errmsg, 256);
        printf(""%s:%s\n"", string, errmsg);
    }
    
    int main(int argc, char** argv) 
    {
        pthread_t *threads;
        int rc, nt, *pids;
        long threads_microsecs, fork_microsecs, t;
        struct timeval ora, dopo;
        float perc;
        
        if (argc != 2)
        {
            printf(""Numero di argomenti %d non valido.\n"", argc);
            exit(1);
        }
        nt = strtol(argv[1], NULL, 10);
        if (nt < 0)
        {
            printf(""Numero di thread non valido: %d"", nt);
            exit(1);
        }
        
        threads = (pthread_t *) malloc (nt * sizeof(pthread_t));
        pids = (int *) malloc (nt * sizeof(int));
        
        if (pids == NULL)
        {
            perror(""malloc"");
            exit(1);
        }
        
        gettimeofday(&ora, NULL);
        
        for (t = 0; t < nt; t++)
        {
            if (rc = pthread_create(&threads[t], NULL, dummy_thread, NULL)) 
            {
                pthread_perror(""pthread_create"", rc);
                exit(1);
            }
            gettimeofday(&dopo, NULL);
            threads_microsecs = dopo.tv_usec - ora.tv_usec;
            threads_microsecs += 1000000 * (dopo.tv_sec - ora.tv_sec);
            printf(""Tempo per la creazione dei thread %ld nsec.\n"", threads_microsecs);
            gettimeofday(&ora, NULL);
            
            for (t = 0; t < nt; t++)
            {
                if ((pids[t] = fork()) < 0)
                {
                    perror(""fork"");
                    exit(1);
                }
                if (pids[t] == 0)
                {
                    dummy_fork(NULL);
                } 
            }
            
             gettimeofday(&dopo, NULL);
             fork_microsecs = dopo.tv_usec - ora.tv_usec;
             fork_microsecs += 1000000 * (dopo.tv_sec - ora.tv_sec);
             printf(""Tempo per la creazione dei processi %ld nsec"", fork_microsecs);
             perc = 100 * (((float) fork_microsecs - threads_microsecs)/(float)fork_microsecs);
             printf(""(%.2f%%)\n"", perc);
             
            
        }
        return (EXIT_SUCCESS);
    }",4
10071700,04/09/2012 10:07:07,1271912,03/15/2012 15:22:50,21,4,What is the most efficient way to choose a random value in a stream?,"What is the most efficient way to choose a random value in a stream? Given that each of them has a chance of occurring equally.

Thanks.",c,algorithm,interview-questions,,,04/09/2012 10:15:59,not a real question,1,25,14,"What is the most efficient way to choose a random value in a stream? What is the most efficient way to choose a random value in a stream? Given that each of them has a chance of occurring equally.

Thanks.",3
6983888,08/08/2011 14:46:05,791174,06/09/2011 14:56:30,9,0,error in creating a binary tree,"    typedef struct {
	char letter;
	int frequency;
    }bintree_elem;	
    typedef struct binary {
	bintree_elem element;
	struct binary *LSON;
	struct binary *RSON;
	struct binary *next;
	int RTAG;
    }binary_node;


    void create_tree(binary_node *head, FILE *fp2) {
	binary_node *p, *q, *new_node, *tail;
	int n = 26, count = 0;
	p = head;
	q = p->next;

	while(count != 25) {
		tail = head;
		new_node = (binary_node*)malloc(sizeof(binary_node));
		while(tail->next != NULL)
			tail = tail->next;
		tail->next = new_node;	
		tail = new_node;
		new_node->element.frequency = (p->element.frequency + q->element.frequency);
		new_node->RSON = p;
		new_node->RSON->RTAG = 0;
		new_node->LSON = q;
		new_node->LSON->RTAG = 1;	
		n = n - 1;
		sort(n, head);
		p = q->next;
		q = p->next;
		count++;
	}

}

heres the code. its actually a huffman tree. This code is the one that causes the trouble. i was given a text and the correct huffman code for each letter. but when i use that text, my program's output is not the same. the max depth of the binary tree formed in that test case is 9. while my binary tree only has a max depth of 6. i tried another test case and the binary tree that should form has a max depth of 10. but my program again produces a binary tree with a max depth of 6. all the values in the nodes are correct and so is my sorting and traversing. What's wrong with that code?",c,,,,,08/09/2011 08:12:20,not a real question,1,210,6,"error in creating a binary tree     typedef struct {
	char letter;
	int frequency;
    }bintree_elem;	
    typedef struct binary {
	bintree_elem element;
	struct binary *LSON;
	struct binary *RSON;
	struct binary *next;
	int RTAG;
    }binary_node;


    void create_tree(binary_node *head, FILE *fp2) {
	binary_node *p, *q, *new_node, *tail;
	int n = 26, count = 0;
	p = head;
	q = p->next;

	while(count != 25) {
		tail = head;
		new_node = (binary_node*)malloc(sizeof(binary_node));
		while(tail->next != NULL)
			tail = tail->next;
		tail->next = new_node;	
		tail = new_node;
		new_node->element.frequency = (p->element.frequency + q->element.frequency);
		new_node->RSON = p;
		new_node->RSON->RTAG = 0;
		new_node->LSON = q;
		new_node->LSON->RTAG = 1;	
		n = n - 1;
		sort(n, head);
		p = q->next;
		q = p->next;
		count++;
	}

}

heres the code. its actually a huffman tree. This code is the one that causes the trouble. i was given a text and the correct huffman code for each letter. but when i use that text, my program's output is not the same. the max depth of the binary tree formed in that test case is 9. while my binary tree only has a max depth of 6. i tried another test case and the binary tree that should form has a max depth of 10. but my program again produces a binary tree with a max depth of 6. all the values in the nodes are correct and so is my sorting and traversing. What's wrong with that code?",1
11572195,07/20/2012 02:55:45,1217616,02/18/2012 04:56:05,5,0,Make won't change files to compile,"I had two files, driver.c, and sort.c. I then changed the name of sort.c to old_sort.c, and created a sort.asm (it works too). I changed my makefile to work with sort.asm, but make is stubborn and it either still compiles sort.c (if I don't change the name of sort.c) or it says undefined reference to 'sort'. Here is my current makefile:<br/>


CFILES = driver.c <br/>
AFILES = sort.asm

TARGET = bubble

include /usr/local/include/cproject.mak

CFILES is for c files, AFILES is for assembly files, TARGET is for the name of the executable, and the cproject.mak makefile is where I actually do my make commands. I am sure it works because I've used it on atleast 20 projects. How can I get make to recognize my sort.asm file?",c,ubuntu,assembly,makefile,make,07/20/2012 19:55:42,not a real question,1,121,6,"Make won't change files to compile I had two files, driver.c, and sort.c. I then changed the name of sort.c to old_sort.c, and created a sort.asm (it works too). I changed my makefile to work with sort.asm, but make is stubborn and it either still compiles sort.c (if I don't change the name of sort.c) or it says undefined reference to 'sort'. Here is my current makefile:<br/>


CFILES = driver.c <br/>
AFILES = sort.asm

TARGET = bubble

include /usr/local/include/cproject.mak

CFILES is for c files, AFILES is for assembly files, TARGET is for the name of the executable, and the cproject.mak makefile is where I actually do my make commands. I am sure it works because I've used it on atleast 20 projects. How can I get make to recognize my sort.asm file?",5
11366939,07/06/2012 17:24:51,977419,10/03/2011 20:49:50,38,1,Why does printing an unsigned char sometimes work and sometimes not? In C,"For a school project, I'm writing a blowfish encryption (just the encryption, not the decryption). I've finished the encryption itself, and I decided I would do the decryption for fun (it's easy enough in Blowfish). 

I used unsigned chars to represent bytes (although I suppose uint8_t would have been more portable). The question I have comes in when I am attempting to print out the decrypted bytes. I am encrypting plain text messages. I've been able to print out the actual text message that I encrypted, but only at a very specific spot. The same exact code seems not to work anywhere else. Here it is:

    int n;
    for(n = 0; n < numBlocks; n++) // Blocks are 32-bit unsigned ints (unsigned long)
    {
         // uchar is just a typedef for unsigned char
         // message is an array of uchars
         message[n] = (uchar) ((blocks[n]>>24));
         message[n+1] = (uchar) ((blocks[n]>>16));
         message[n+2] = (uchar) ((blocks[n]>>8));
         message[n+3] = (uchar) ((blocks[n]));
         // Printing works here; exact message comes back
         printf(""%c%c%c%c"", message[n], message[n+1], message[n+2], message[n+3]); 
    }

But when I try to use the exact same code two lines later, *it doesn't work*.

    for(n = 0; n < numBlocks; n++)
    {
         // Printing doesn't work here.
         // Actually, the first letter works, but none of the others
         printf(""%c%c%c%c"", message[n], message[n+1], message[n+2], message[n+3]); 
    }

I have tried printing out the characters in number format as well, and I can see that they have in fact changed. 

What exactly is going on here? Is this undefined behavior? Does anyone have any reliable solutions? I'm not doing anything to change the value of the message array in between the two calls.

I'm running and compiling this on Sun 5.10 with a sparc processor.",c,char,printf,unsigned,unsigned-char,,open,0,391,13,"Why does printing an unsigned char sometimes work and sometimes not? In C For a school project, I'm writing a blowfish encryption (just the encryption, not the decryption). I've finished the encryption itself, and I decided I would do the decryption for fun (it's easy enough in Blowfish). 

I used unsigned chars to represent bytes (although I suppose uint8_t would have been more portable). The question I have comes in when I am attempting to print out the decrypted bytes. I am encrypting plain text messages. I've been able to print out the actual text message that I encrypted, but only at a very specific spot. The same exact code seems not to work anywhere else. Here it is:

    int n;
    for(n = 0; n < numBlocks; n++) // Blocks are 32-bit unsigned ints (unsigned long)
    {
         // uchar is just a typedef for unsigned char
         // message is an array of uchars
         message[n] = (uchar) ((blocks[n]>>24));
         message[n+1] = (uchar) ((blocks[n]>>16));
         message[n+2] = (uchar) ((blocks[n]>>8));
         message[n+3] = (uchar) ((blocks[n]));
         // Printing works here; exact message comes back
         printf(""%c%c%c%c"", message[n], message[n+1], message[n+2], message[n+3]); 
    }

But when I try to use the exact same code two lines later, *it doesn't work*.

    for(n = 0; n < numBlocks; n++)
    {
         // Printing doesn't work here.
         // Actually, the first letter works, but none of the others
         printf(""%c%c%c%c"", message[n], message[n+1], message[n+2], message[n+3]); 
    }

I have tried printing out the characters in number format as well, and I can see that they have in fact changed. 

What exactly is going on here? Is this undefined behavior? Does anyone have any reliable solutions? I'm not doing anything to change the value of the message array in between the two calls.

I'm running and compiling this on Sun 5.10 with a sparc processor.",5
6925407,08/03/2011 10:59:45,881757,08/03/2011 10:59:45,1,0,Detecting whether a process is idle,"Is there a way to detect whether a Windows process is idle?

idle Means, when a particular application's process is not processing anything(The application is waiting for userinput).

cheers

",c,window,jna,,,,open,0,27,6,"Detecting whether a process is idle Is there a way to detect whether a Windows process is idle?

idle Means, when a particular application's process is not processing anything(The application is waiting for userinput).

cheers

",3
7413041,09/14/2011 07:59:19,537712,12/10/2010 10:21:57,691,51,What does the <> operator do?,"I came across the <> operator in some C code and couldn't figure out for sure what it ment.
I'm guessing it's equal to != (not equal to) operator?

Could somebody please enlighten me?

Am i right to think that <> and != are the same or...?

Thanks in advance.

",c,operators,,,,09/15/2011 01:16:26,too localized,1,46,6,"What does the <> operator do? I came across the <> operator in some C code and couldn't figure out for sure what it ment.
I'm guessing it's equal to != (not equal to) operator?

Could somebody please enlighten me?

Am i right to think that <> and != are the same or...?

Thanks in advance.

",2
11063795,06/16/2012 13:23:28,1460669,06/16/2012 13:18:22,1,0,Read callbacks needed by AudioFileInitializeWithCallbacks? Apple AudioFile API,"
I am trying to write a lowish level audio writer with the AudioFile & ExtAudioFile APIs. I am creating a new audio file with AudioFileInitializeWithCallbacks but it appears that this needs read & get size callbacks implemented. Why can't this just accept a single write callback and trust that the data has been written sucessfully.
 
What if I am writing to a stream which I can not seek into such as a CD or a network socket?
 
Surely this should just continually push data to the write callback and it is my responsibility to write this data where needed returning an error code if the operation didn't succeed.
 
 
The docs for AudioFile_SetSizeProc and AudioFile_WriteProc appear to be incorrect as they both talk about read operations ""inPosition An offset into the data from which to read."", ""@result The callback should return the size of the data."".
 
 
At the moment I have got past this by only writing to a file but I get a kExtAudioFileError_InvalidOperationOrder after the first write procedure. What does this mean? There are no comments in the docs about it.
 
Any pointers or help would be much appriciated.",c,core-audio,extaudiofile,,,,open,0,192,8,"Read callbacks needed by AudioFileInitializeWithCallbacks? Apple AudioFile API 
I am trying to write a lowish level audio writer with the AudioFile & ExtAudioFile APIs. I am creating a new audio file with AudioFileInitializeWithCallbacks but it appears that this needs read & get size callbacks implemented. Why can't this just accept a single write callback and trust that the data has been written sucessfully.
 
What if I am writing to a stream which I can not seek into such as a CD or a network socket?
 
Surely this should just continually push data to the write callback and it is my responsibility to write this data where needed returning an error code if the operation didn't succeed.
 
 
The docs for AudioFile_SetSizeProc and AudioFile_WriteProc appear to be incorrect as they both talk about read operations ""inPosition An offset into the data from which to read."", ""@result The callback should return the size of the data."".
 
 
At the moment I have got past this by only writing to a file but I get a kExtAudioFileError_InvalidOperationOrder after the first write procedure. What does this mean? There are no comments in the docs about it.
 
Any pointers or help would be much appriciated.",3
10484987,05/07/2012 15:42:19,1003575,10/19/2011 16:09:24,21,0,how to manage linux tmp space with C,"I have some questions concerning the usage of tmp linux with C function

- How to get the free space size of tmp with C ( the tmp is not a tmpfs partition) ?

- How to clean the tmp memory with a safe way when it's full with C ?

",c,linux,,,,05/08/2012 18:06:29,not a real question,1,49,8,"how to manage linux tmp space with C I have some questions concerning the usage of tmp linux with C function

- How to get the free space size of tmp with C ( the tmp is not a tmpfs partition) ?

- How to clean the tmp memory with a safe way when it's full with C ?

",2
4383915,12/08/2010 03:32:02,531802,12/06/2010 05:32:30,23,0,undefined behavior of switch,"#include<stdio.h>
  int main()
  {
      int a=1;
      switch(a)
      {   int b=20;
          case 1: printf(""b is %d\n"",b);
                  break;
          default:printf(""b is %d\n"",b);
                  break;
      }
      return 0;
  }

what do you think can be value of b in both of these printf statements ? ofcourse it is not 20.",c,,,,,12/08/2010 03:40:08,not a real question,1,126,4,"undefined behavior of switch #include<stdio.h>
  int main()
  {
      int a=1;
      switch(a)
      {   int b=20;
          case 1: printf(""b is %d\n"",b);
                  break;
          default:printf(""b is %d\n"",b);
                  break;
      }
      return 0;
  }

what do you think can be value of b in both of these printf statements ? ofcourse it is not 20.",1
4107207,11/05/2010 15:10:29,472940,03/17/2010 04:40:18,26,0,C Program memory map,"1. static int i=0;
where will be the variable i allocated? Is it in BSS or initialized data segment?
2. where will be variables of storage class 'extern' and 'register' are stored?

I possible please provide code Snippet to crosscheck the above  ",c,,,,,11/06/2010 00:38:06,not a real question,1,41,4,"C Program memory map 1. static int i=0;
where will be the variable i allocated? Is it in BSS or initialized data segment?
2. where will be variables of storage class 'extern' and 'register' are stored?

I possible please provide code Snippet to crosscheck the above  ",1
7806360,10/18/2011 11:17:58,774739,05/28/2011 23:05:39,957,12,Is this a bug of TokyoCabinet?,"It's basically a binary tree which first searches against hash to decide whether it's `left` or `right`:

    if(hash > rec.hash){
      off = rec.left;
      entoff = rec.off + (sizeof(uint8_t) + sizeof(uint8_t));
    } else if(hash < rec.hash){
      off = rec.right;
      entoff = rec.off + (sizeof(uint8_t) + sizeof(uint8_t)) +
        (hdb->ba64 ? sizeof(uint64_t) : sizeof(uint32_t));
    } else {
      if(!rec.kbuf && !tchdbreadrecbody(hdb, &rec)) return false;
      int kcmp = tcreckeycmp(kbuf, ksiz, rec.kbuf, rec.ksiz);
      if(kcmp > 0){
        off = rec.left;
        ...
      } else if(kcmp < 0){
        off = rec.right;
        ...

Here's how hash calculated:


    static uint64_t tchdbbidx(TCHDB *hdb, const char *kbuf, int ksiz, uint8_t *hp){
      ...
      uint32_t hash = 751;
      const char *rp = kbuf + ksiz;
      while(ksiz--){
        ...
        hash = (hash * 31) ^ *(uint8_t *)--rp;
      }
      *hp = hash;
      ...
    }


But it seems the way the hash calculated can't ensure the orderness of keys,

is it a bug?",c,tokyocabinet,,,,,open,0,280,6,"Is this a bug of TokyoCabinet? It's basically a binary tree which first searches against hash to decide whether it's `left` or `right`:

    if(hash > rec.hash){
      off = rec.left;
      entoff = rec.off + (sizeof(uint8_t) + sizeof(uint8_t));
    } else if(hash < rec.hash){
      off = rec.right;
      entoff = rec.off + (sizeof(uint8_t) + sizeof(uint8_t)) +
        (hdb->ba64 ? sizeof(uint64_t) : sizeof(uint32_t));
    } else {
      if(!rec.kbuf && !tchdbreadrecbody(hdb, &rec)) return false;
      int kcmp = tcreckeycmp(kbuf, ksiz, rec.kbuf, rec.ksiz);
      if(kcmp > 0){
        off = rec.left;
        ...
      } else if(kcmp < 0){
        off = rec.right;
        ...

Here's how hash calculated:


    static uint64_t tchdbbidx(TCHDB *hdb, const char *kbuf, int ksiz, uint8_t *hp){
      ...
      uint32_t hash = 751;
      const char *rp = kbuf + ksiz;
      while(ksiz--){
        ...
        hash = (hash * 31) ^ *(uint8_t *)--rp;
      }
      *hp = hash;
      ...
    }


But it seems the way the hash calculated can't ensure the orderness of keys,

is it a bug?",2
3533164,08/20/2010 17:07:30,234580,12/18/2009 14:10:24,67,0,intrinsically faster: Forth Versus C,"This isn't an attempt to start a flame war about Language A Versus Language B, nor Compiler A Versus Compiler B, it's simple a question on your personal experiences: what language is more faster and, hopefully, use less resources: C or Forth.
Welcome ANY opinion, hopefully based in real experience.

Thanks!!",c,forth,,,,08/20/2010 17:17:04,not constructive,1,49,5,"intrinsically faster: Forth Versus C This isn't an attempt to start a flame war about Language A Versus Language B, nor Compiler A Versus Compiler B, it's simple a question on your personal experiences: what language is more faster and, hopefully, use less resources: C or Forth.
Welcome ANY opinion, hopefully based in real experience.

Thanks!!",2
1345506,08/28/2009 07:17:09,118644,06/06/2009 20:40:11,28,2,Where is the best place to learn C?,"I absolutely loved DiveIntoPython when I picked up Python.

In fact, ""tutorials"" such as DiveIntoPython works really well for me, short brief explaination for syntaxes, and plenty of examples to get things going.

I learn really well via examples.

I do have programming experiences in Java, Scheme, Python, PHP, Javascript, etc.

Is there any where you guys would recommend online to quickly pick up C programming language, and best practises.

Thanks!",c,,,,,09/05/2011 20:11:49,not constructive,1,66,8,"Where is the best place to learn C? I absolutely loved DiveIntoPython when I picked up Python.

In fact, ""tutorials"" such as DiveIntoPython works really well for me, short brief explaination for syntaxes, and plenty of examples to get things going.

I learn really well via examples.

I do have programming experiences in Java, Scheme, Python, PHP, Javascript, etc.

Is there any where you guys would recommend online to quickly pick up C programming language, and best practises.

Thanks!",1
9388278,02/22/2012 02:22:26,1224765,02/22/2012 02:19:37,1,0,building a floating number using c,"I have to input in three, a sign(+ or -),exponent and a significand(y.yyyyyy). Now i have to use these three parts to construct a float number. This program should deal with the property of normalized and denormalized but ignore the infinity and special case concept. I am not sure how to go about this program, if some one would be generous enough to give me a head start. PS- I am not so familiar with using C as a programming language, i have used a very few times.  ",c,floating,,,,02/22/2012 02:38:39,too localized,1,90,6,"building a floating number using c I have to input in three, a sign(+ or -),exponent and a significand(y.yyyyyy). Now i have to use these three parts to construct a float number. This program should deal with the property of normalized and denormalized but ignore the infinity and special case concept. I am not sure how to go about this program, if some one would be generous enough to give me a head start. PS- I am not so familiar with using C as a programming language, i have used a very few times.  ",2
5171868,03/02/2011 18:40:40,498095,11/05/2010 08:15:26,33,3,print to console application overwriting current line,"I want to overwrite the current line in a c console program to achieve output like in the linux shell command ""top"". If possible the method should work under windows and linux.

	while (i < 100) {
           i++;
           sprintf(cTmp, ""%3d"", i);
	       puts(cTmp);
           if ((character = mygetch()) == 'q') {
              break;
           }
        }

I would like to overwrite the previous number in each iteration and if possible look if the user entered a character without pausing the loop. If the user presses the key 'q' the loop should stop immediately.


",c,windows,linux,console-application,,,open,0,153,7,"print to console application overwriting current line I want to overwrite the current line in a c console program to achieve output like in the linux shell command ""top"". If possible the method should work under windows and linux.

	while (i < 100) {
           i++;
           sprintf(cTmp, ""%3d"", i);
	       puts(cTmp);
           if ((character = mygetch()) == 'q') {
              break;
           }
        }

I would like to overwrite the previous number in each iteration and if possible look if the user entered a character without pausing the loop. If the user presses the key 'q' the loop should stop immediately.


",4
9551846,03/04/2012 02:36:35,737842,05/04/2011 11:07:45,1140,72,How to point to an array,"I am writing a shader for OpenGL and I need to be able to pass in an array of data. I need to be able to pass by reference because I cannot copy the whole array. I know that you cannot define a pointer to an array of structs with `Vertices *v[100];` because this will create an array of pointers.

I think you can pass the memory location of the first element in the c array with `bindArrayFunction(&v);` but then how should I use it? Would I increase the pointer by the size of the struct to get every vertex?

Any help or comments would be appreciated.",c,arrays,pointers,pass-by-reference,argument-passing,,open,0,105,6,"How to point to an array I am writing a shader for OpenGL and I need to be able to pass in an array of data. I need to be able to pass by reference because I cannot copy the whole array. I know that you cannot define a pointer to an array of structs with `Vertices *v[100];` because this will create an array of pointers.

I think you can pass the memory location of the first element in the c array with `bindArrayFunction(&v);` but then how should I use it? Would I increase the pointer by the size of the struct to get every vertex?

Any help or comments would be appreciated.",5
3864964,10/05/2010 15:06:51,463688,10/01/2010 09:17:25,149,0,Why the output of the following 3 programs is like this ?,"    #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
    }
    
    O/P: 30
    
    #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
      printf(""Hello"");
    }
    
    O/P: 5
    
    #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
      sum++;
    }
    
    O/P: 30

",c,homework,,,,10/05/2010 22:15:52,not a real question,1,210,12,"Why the output of the following 3 programs is like this ?     #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
    }
    
    O/P: 30
    
    #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
      printf(""Hello"");
    }
    
    O/P: 5
    
    #include<stdio.h>
    int main()
    {
    int p=add(10,20);
    printf(""%d"",p);
    return 0;
    }
    int add(int x, int y)
    {
      int sum=x+y;
      sum++;
    }
    
    O/P: 30

",2
10181463,04/16/2012 20:47:04,1336997,04/16/2012 18:22:53,6,0,Convert a char * to char,"How to convert a char * to char.

I have a char pointer 
 `char * Data`  which gets some value
I also have a variable
 

    Char result

Can I do 
`result = *(Data)`?If I do so its throwing me a null pointer assignment. I want to store the values in an array of result for different values of ""Data"" in a loop. Please help.
Thanks.",c,,,,,04/16/2012 20:59:46,not a real question,1,67,6,"Convert a char * to char How to convert a char * to char.

I have a char pointer 
 `char * Data`  which gets some value
I also have a variable
 

    Char result

Can I do 
`result = *(Data)`?If I do so its throwing me a null pointer assignment. I want to store the values in an array of result for different values of ""Data"" in a loop. Please help.
Thanks.",1
11476410,07/13/2012 18:41:04,861949,07/25/2011 16:11:48,57,10,Twos- complement addition forms an abelian group,"I was reading about techniques to detect overflow in C . one of the examples to show incorrect solution to detect overflow in addition was this one :

    /* Determine whether arguments can be added without overflow */
    int tadd_ok(int x, int y) {
        int sum = x+y;
        return (sum-x == y) && (sum-y == x);
    }

and it said it doesn't work because :<br>
> twos-complement addition forms an abelian group, and so the
> expression (x+y)-x will evaluate to y regardless of whether or not the
> addition overflows, and that (x+y)-y will always evaluate to x

What does it exactly mean ? Does it mean that C compiler replace `sum` with `x+y` ?<br>
To figure out what is it saying I even traced assembly code of the program, but there was no sign of replacement .
",c,optimization,assembly,compiler,,07/16/2012 02:49:34,not a real question,1,156,7,"Twos- complement addition forms an abelian group I was reading about techniques to detect overflow in C . one of the examples to show incorrect solution to detect overflow in addition was this one :

    /* Determine whether arguments can be added without overflow */
    int tadd_ok(int x, int y) {
        int sum = x+y;
        return (sum-x == y) && (sum-y == x);
    }

and it said it doesn't work because :<br>
> twos-complement addition forms an abelian group, and so the
> expression (x+y)-x will evaluate to y regardless of whether or not the
> addition overflows, and that (x+y)-y will always evaluate to x

What does it exactly mean ? Does it mean that C compiler replace `sum` with `x+y` ?<br>
To figure out what is it saying I even traced assembly code of the program, but there was no sign of replacement .
",4
10049264,04/06/2012 21:07:17,1318253,04/06/2012 21:05:18,1,0,Creating a sorted Singly Linked List in C (Insert function),"Here is my insert function [1] http://pastebin.com/1gyYGsp0

Here is the struct header [2] http://pastebin.com/PnTQUaRJ

Any help would be appreciated on where my code is going wrong. 
Segmentation fault.",c,,,,,04/17/2012 11:54:50,not a real question,1,26,10,"Creating a sorted Singly Linked List in C (Insert function) Here is my insert function [1] http://pastebin.com/1gyYGsp0

Here is the struct header [2] http://pastebin.com/PnTQUaRJ

Any help would be appreciated on where my code is going wrong. 
Segmentation fault.",1
7214757,08/27/2011 13:08:21,448413,06/09/2010 10:04:01,460,4,Would this programe give any error(Run time error)?,"I have been asked in an interview is below code contain any error??

  main()
   
   {

   int a; 

   int **p=&a;

  }


   i said it won't any error but will affect the output of program.What you guys think??",c,pointers,,,,08/27/2011 14:30:57,not a real question,1,50,8,"Would this programe give any error(Run time error)? I have been asked in an interview is below code contain any error??

  main()
   
   {

   int a; 

   int **p=&a;

  }


   i said it won't any error but will affect the output of program.What you guys think??",2
3687113,09/10/2010 18:07:58,362250,06/09/2010 09:22:53,61,0,How to control multiple robots through PC using Serial communication?,"I want to **control multiple robots using my laptop**. Robots do not have intelligence, they are sending sensor values to PC which computes the sensors values and sends back result to robots.(Centralized control of robots using PC ).

Robots are communicating with PC through serial communication using Zigbee mudule. 

Problem: **How to make & send a structure** (from robot) **like {sen1, sen2,sen3..,robot id}** where sen1, sen2..are sensors values and robot id is to recognize particular robot. 

additional info: **Using C language, robots are working concurrently**.
",c,robotics,serial-communication,,,,open,0,84,10,"How to control multiple robots through PC using Serial communication? I want to **control multiple robots using my laptop**. Robots do not have intelligence, they are sending sensor values to PC which computes the sensors values and sends back result to robots.(Centralized control of robots using PC ).

Robots are communicating with PC through serial communication using Zigbee mudule. 

Problem: **How to make & send a structure** (from robot) **like {sen1, sen2,sen3..,robot id}** where sen1, sen2..are sensors values and robot id is to recognize particular robot. 

additional info: **Using C language, robots are working concurrently**.
",3
5305635,03/14/2011 22:58:57,659709,03/14/2011 22:58:57,1,0,Converting C code to assembly,"I needed some help converting this C code into assembly:

Idea is:

sz = length of v
k = allocate array of ints, length v
if type = 0
 k[i] = length v[i]
else
 k[i] = sum v[i]

sort k the simplest swapping way:
each time when k[i] and k[j] is swapped, swap v[i] and v[j] too

deallocate k

gcc -O0 -S test.c 
(compile to assembler)
",c,assembly,converting,,,03/15/2011 08:30:07,not a real question,1,57,5,"Converting C code to assembly I needed some help converting this C code into assembly:

Idea is:

sz = length of v
k = allocate array of ints, length v
if type = 0
 k[i] = length v[i]
else
 k[i] = sum v[i]

sort k the simplest swapping way:
each time when k[i] and k[j] is swapped, swap v[i] and v[j] too

deallocate k

gcc -O0 -S test.c 
(compile to assembler)
",3
6292223,06/09/2011 11:42:02,790841,06/09/2011 11:42:02,1,0,Getting the Specified content into the buffer in c,"i am downloading a jsp file from http server in c. But i am getting the contents of the file as shown
 <HTML>
<BODY>
Hello, user
</BODY>
</HTML>
into a buffer. Now i want capture ""Hello,user"" only into my buffer. Can anyone help me in finding the code in C.",c,,,,,06/09/2011 12:51:00,not a real question,1,45,9,"Getting the Specified content into the buffer in c i am downloading a jsp file from http server in c. But i am getting the contents of the file as shown
 <HTML>
<BODY>
Hello, user
</BODY>
</HTML>
into a buffer. Now i want capture ""Hello,user"" only into my buffer. Can anyone help me in finding the code in C.",1
6151879,05/27/2011 11:54:46,772599,05/27/2011 07:03:45,1,0,How to define a MACRO,"How can I define a 40 bit MACRO.

For eg, if I want to define ""deadbeef"" (32 bit ) as a MACRO I'll do:

\#define MYMACRO 0xdeadbeef

But how do I do it if I want to define ""deadbeefs"" ( 40 bits).

Thanks.",c,,,,,05/29/2011 15:29:34,not a real question,1,39,5,"How to define a MACRO How can I define a 40 bit MACRO.

For eg, if I want to define ""deadbeef"" (32 bit ) as a MACRO I'll do:

\#define MYMACRO 0xdeadbeef

But how do I do it if I want to define ""deadbeefs"" ( 40 bits).

Thanks.",1
1678799,11/05/2009 07:01:15,133466,07/05/2009 23:02:59,360,1,Why does the following equation always round up?,"    size = (size_in_bytes + sizeof(int) - 1) / sizeof(int);

This is more of a math questions than real programming question...
Is it because C always round down?",c,,,,,,open,0,29,8,"Why does the following equation always round up?     size = (size_in_bytes + sizeof(int) - 1) / sizeof(int);

This is more of a math questions than real programming question...
Is it because C always round down?",1
5323486,03/16/2011 09:49:32,662223,03/16/2011 09:49:32,1,0,How we can make a programe of adding two numbers?,"How we can make a programe, of adding two numbers and then display it, by using of 'C' Language?",c,integer,,,,03/16/2011 16:03:53,not a real question,1,19,10,"How we can make a programe of adding two numbers? How we can make a programe, of adding two numbers and then display it, by using of 'C' Language?",2
8458727,12/10/2011 18:09:58,1091500,12/10/2011 17:54:07,1,0,Shifting in one bit (this bit should be '1'),"## The code - commented ##

void main()
{

    unsigned int BHR;
        
    BHR = (BHR << 1);  /*shifting left by one */
         
    BHR = (BHR | 0x1);  /* ?????, how can i do this? shifted bit = 1 (LSB of BHR) */         
           
    BHR = (BHR & 0xFFFFFFFE);  /* shifted bit = 0 (LSB of BHR)

}

",c,bit,shift,,,12/10/2011 20:24:42,not a real question,1,105,9,"Shifting in one bit (this bit should be '1') ## The code - commented ##

void main()
{

    unsigned int BHR;
        
    BHR = (BHR << 1);  /*shifting left by one */
         
    BHR = (BHR | 0x1);  /* ?????, how can i do this? shifted bit = 1 (LSB of BHR) */         
           
    BHR = (BHR & 0xFFFFFFFE);  /* shifted bit = 0 (LSB of BHR)

}

",3
9915497,03/28/2012 20:54:09,1261015,03/10/2012 12:37:43,21,0,How can I read complex numbers from a file to a matrix in C?,"I have a file containing all the values for a 64x64 matrix, and all the values are complex numbers. Because it is a big matrix, I don't want to type them one by one at the source code, and I want to read them from the file. I have the following code, but it is not working, while when I try to print the array then I get some stupid and unrelated numbers, zeros and stuff like that.

          complex double twidder[64][64];
          int flag = 0;
          int i, k;
    
          FILE *twidderFile;
        
          twidderFile = fopen(""twidder_factor.txt"", ""r"");
        
          if(twidderFile == NULL)
          {
              fprintf(stderr, ""Can't open the file twidder_factor.txt!\n"");
              exit(1);
          }
        
          for(i = 0; i < 64; i++)
          {
              for(k = 0; k < 64; k++)
              {
                  if((flag = fscanf(twidderFile, ""%f"", &twidder[i][k])) == EOF)
                  {
                      break;
                  }
              }
              if(flag == EOF)
              {
                  break;
              }
          }
        
          if(flag == EOF)
          {
              fprintf(stderr, ""Error has been encountered while reading values from twidder_factor.txt!\n"");
              exit(1);
          }
    
    for(i = 0; i < 64; i++)
    {
       for(k = 0; k < 64; k++)
       {
          printf(""%.0f %c %.0fj\t"", creal(twidder[i][k]), cimag(twidder[i][k]) >= 0 ? '+' : '-', cimag(twidder[i][k]) >= 0 ? cimag(twidder[i][k]) : -cimag(twidder[i][k]));
       }
       printf(""\n"");
    }

Please note that, at the beginning of the source code I have the following code and have changed the imaginary part to be denoted by the letter j.

    #include <stdio.h>
    #include <complex.h>
    #undef I
    #define j _Imaginary_I

I guess I'm doing something from at the fscanf statement. In case you are curious about the numbers that I have in my file, here are some examples:

-12540 + 30273j

3211 + 32609j

32767

-30273 - 12540j

32767j

-12314j

30273 + 12539j

I have them in 64x64 matrix form, so the file contains 64 lines (rows) and each row element is separated by a tab with the other one.

Thanks in advance for helping.
",c,file,matrix,numbers,complex,,open,0,733,14,"How can I read complex numbers from a file to a matrix in C? I have a file containing all the values for a 64x64 matrix, and all the values are complex numbers. Because it is a big matrix, I don't want to type them one by one at the source code, and I want to read them from the file. I have the following code, but it is not working, while when I try to print the array then I get some stupid and unrelated numbers, zeros and stuff like that.

          complex double twidder[64][64];
          int flag = 0;
          int i, k;
    
          FILE *twidderFile;
        
          twidderFile = fopen(""twidder_factor.txt"", ""r"");
        
          if(twidderFile == NULL)
          {
              fprintf(stderr, ""Can't open the file twidder_factor.txt!\n"");
              exit(1);
          }
        
          for(i = 0; i < 64; i++)
          {
              for(k = 0; k < 64; k++)
              {
                  if((flag = fscanf(twidderFile, ""%f"", &twidder[i][k])) == EOF)
                  {
                      break;
                  }
              }
              if(flag == EOF)
              {
                  break;
              }
          }
        
          if(flag == EOF)
          {
              fprintf(stderr, ""Error has been encountered while reading values from twidder_factor.txt!\n"");
              exit(1);
          }
    
    for(i = 0; i < 64; i++)
    {
       for(k = 0; k < 64; k++)
       {
          printf(""%.0f %c %.0fj\t"", creal(twidder[i][k]), cimag(twidder[i][k]) >= 0 ? '+' : '-', cimag(twidder[i][k]) >= 0 ? cimag(twidder[i][k]) : -cimag(twidder[i][k]));
       }
       printf(""\n"");
    }

Please note that, at the beginning of the source code I have the following code and have changed the imaginary part to be denoted by the letter j.

    #include <stdio.h>
    #include <complex.h>
    #undef I
    #define j _Imaginary_I

I guess I'm doing something from at the fscanf statement. In case you are curious about the numbers that I have in my file, here are some examples:

-12540 + 30273j

3211 + 32609j

32767

-30273 - 12540j

32767j

-12314j

30273 + 12539j

I have them in 64x64 matrix form, so the file contains 64 lines (rows) and each row element is separated by a tab with the other one.

Thanks in advance for helping.
",5
7160371,08/23/2011 11:35:00,859227,07/23/2011 11:00:32,11,0,"C, segmentation fault in fprintf.c:32","I don't what is wrong with fprintf that when the log file size reaches about 6 MB, I get segmentation fault. The call stack shows:

    #0 _IO_vfprintf_internal() at vfprintf.c:1287
    #1 __fprintf() at fprintf.c:32
    #2 my_source.c:344

That line is printed normally before reaching 6 MB and from the call stack I don't think there is any problem with my fprintf statement. 

Is there any comment on that?",c,segmentation-fault,fprintf,,,08/23/2011 11:44:12,not a real question,1,74,5,"C, segmentation fault in fprintf.c:32 I don't what is wrong with fprintf that when the log file size reaches about 6 MB, I get segmentation fault. The call stack shows:

    #0 _IO_vfprintf_internal() at vfprintf.c:1287
    #1 __fprintf() at fprintf.c:32
    #2 my_source.c:344

That line is printed normally before reaching 6 MB and from the call stack I don't think there is any problem with my fprintf statement. 

Is there any comment on that?",3
10165080,04/15/2012 18:59:55,1216980,02/17/2012 19:15:17,6,0,popularity among C language standards?,"People recommend reading K&R, but that book describes an older standard of C, does it not? Do people still use older standards of C?

I'm very comfortable with programming in the C++/ Java paradigms (OO, imperative), so I probably would be able to write something in C. I feel like I have to know the nuance of the language to use it well. Which book describes the standard which most people adhere to? Do people always move forward with the new standards?",c,standards,,,,04/15/2012 21:13:19,not constructive,1,81,5,"popularity among C language standards? People recommend reading K&R, but that book describes an older standard of C, does it not? Do people still use older standards of C?

I'm very comfortable with programming in the C++/ Java paradigms (OO, imperative), so I probably would be able to write something in C. I feel like I have to know the nuance of the language to use it well. Which book describes the standard which most people adhere to? Do people always move forward with the new standards?",2
6779004,07/21/2011 15:54:41,787756,06/07/2011 15:25:27,1,0,How to initialize pointers properly,"I have the following code that calls the function uint32_pack. This program compiles with no errors in Dev-C++ but does not produce the correct result when 'tag' is an even number.  In Visual Studio the program compiles but produces errors and I'm guessing that these errors are why I don't get the correct output when 'tag' is even. I'm still trying to get my head around pointers and I'm not sure where I went wrong when declaring them. Thanks for your help.

Here is the code where the errors come from:

      1  int uint32_pack (uint8_t *fieldnumber, uint32_t value, uint8_t *out);
        
      2  int main(){
      
      3 uint32_t initvalue = 2;
      
    4  int return_rv;
      
    5  uint8_t *tag = (uint8_t *) malloc(sizeof(uint8_t));
      
    6  *tag = 38;
        
      7  uint8_t *tempout= (uint8_t *) malloc(30);
        
      8  return_rv = uint32_pack (tag, initvalue, tempout);
       
      9  free(tempout);
      
    10  free(tag);
        
        	}

And the errors from VS as are follows:

error C2143: syntax error : missing ';' before 'type' (on line 7)

error C2065: 'tempout' : undeclared identifier        (on line 8)

warning C4047: 'function' : 'unsigned char *' differs in levels of indirection from 'int' (on line 8)

warning C4024: 'uint32_pack' : different types for formal and actual parameter 3 (on line 8) 

error C2065: 'tempout' : undeclared identifier  (on line 9)

warning C4022: 'free' : pointer mismatch for actual parameter 1 (on line 9)",c,visual-studio-2010,function,pointers,,,open,0,352,5,"How to initialize pointers properly I have the following code that calls the function uint32_pack. This program compiles with no errors in Dev-C++ but does not produce the correct result when 'tag' is an even number.  In Visual Studio the program compiles but produces errors and I'm guessing that these errors are why I don't get the correct output when 'tag' is even. I'm still trying to get my head around pointers and I'm not sure where I went wrong when declaring them. Thanks for your help.

Here is the code where the errors come from:

      1  int uint32_pack (uint8_t *fieldnumber, uint32_t value, uint8_t *out);
        
      2  int main(){
      
      3 uint32_t initvalue = 2;
      
    4  int return_rv;
      
    5  uint8_t *tag = (uint8_t *) malloc(sizeof(uint8_t));
      
    6  *tag = 38;
        
      7  uint8_t *tempout= (uint8_t *) malloc(30);
        
      8  return_rv = uint32_pack (tag, initvalue, tempout);
       
      9  free(tempout);
      
    10  free(tag);
        
        	}

And the errors from VS as are follows:

error C2143: syntax error : missing ';' before 'type' (on line 7)

error C2065: 'tempout' : undeclared identifier        (on line 8)

warning C4047: 'function' : 'unsigned char *' differs in levels of indirection from 'int' (on line 8)

warning C4024: 'uint32_pack' : different types for formal and actual parameter 3 (on line 8) 

error C2065: 'tempout' : undeclared identifier  (on line 9)

warning C4022: 'free' : pointer mismatch for actual parameter 1 (on line 9)",4
2921159,05/27/2010 12:44:23,105167,05/12/2009 05:55:29,540,0,segmentation fault while printing array in C ,"    for (k=0;k<5;k++)
    	printf(""%s \n"",&array);

The array has data 
123
11
2312
121
231

and it should print the data exactly the same way . Even though its printing at the end its giving segmentation fault.",c,,,,,05/28/2010 07:00:45,not a real question,1,36,8,"segmentation fault while printing array in C      for (k=0;k<5;k++)
    	printf(""%s \n"",&array);

The array has data 
123
11
2312
121
231

and it should print the data exactly the same way . Even though its printing at the end its giving segmentation fault.",1
6720460,07/16/2011 21:48:33,59468,01/27/2009 19:03:16,183,1,Error Compiling an Deterministic Pushdown Automaton in C (DPDA),"I was reading about how to implement a DPDA and found this code in the following Internet address: [http://code.zhoubot.com/][1], This c file implements a simple pushdown automata. The automata will read in a description of their transition function and input, perform its computation on the input, and then print their output.

The input format is like:
e01:e0$:000111:a:ad:aeeb$:b0eb0:b10ce:c10ce:ce$de
The input is separated by a semicolon :, first section is input alphabet, second is stack alphabet, then input and the last whole bunch are transition functions.


    /* This C file implements a Determinitic Pushdown Automata
     * author: Kevin Zhou
     * Computer Science and Electronics
     * University of Bristol
     */
    
    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    
    typedef struct stack {
        char content;
        struct stack *next;
    } Stack;
    
    typedef struct transistion {
        char current_state;
        char input_symbol;
        char pull;
        char new_state;
        char push;
    } Transistion;
    
    /* list of transistion functions */
    typedef struct list {
        Transistion *content;
        struct list *next;
    } List;
    
    typedef struct pda {
        char *input_alpha;
        char *stack_alpha;
        char *input;
        char start;
        char *accept;
        List *transistion;
    } PDA;
    
    /* create a new empty stack */
    Stack *create_stack( void ) {
        Stack *s = calloc(1,sizeof(Stack));
        if(s==NULL) {
            printf(""Out of Memory!"");
            exit(1);
        }
        return s;
    }
    
    /* test if the stack is empty */
    int isempty( Stack *s ) {
        return (s->next==NULL)? 1:0;
    }
    
    Stack *push_stack (Stack *s, char c) {
        Stack *new = calloc(1,sizeof(Stack));
        if(new ==NULL) {
            printf(""Out of Memory!"");
            exit(1);
        }
        new -> content = c;
        new -> next = s;
        return new;
    }
    
    Stack *pull_stack (Stack *s) {
        Stack *head;
        if(isempty(s)) {
            return '\0';
        }
        head = s;
        s = head -> next;
        return s;
    }
    
    /*return the top elememt in the stack */
    char top (Stack *s) {
        return s->content;
    }
    
    /*  replace a value 'ontop' which on top of the stack with a newvalue 'newvalue'
        epsilon represents an empty element*/
    
    Stack *replace(Stack *sta, char ontop, char newvalue, char epsilon) {
        if(ontop == epsilon && newvalue == epsilon) return sta;
        if(ontop == epsilon && newvalue != epsilon) {
            sta = push_stack(sta,newvalue);
            return sta;
        }
        if(ontop != epsilon && newvalue == epsilon) {
            if(ontop != top(sta)) return NULL;
            sta = pull_stack(sta);
            return sta;
        }
        if(ontop != top(sta)) return NULL;
        sta = pull_stack(sta);
        sta = push_stack(sta,newvalue);
        return sta;
    }
    
    /* turn the input string into transistion fields */
    Transistion *get_transistion(char *s) {
        Transistion *t = calloc(1,sizeof(Transistion));
        t->current_state = s[0];
        t->input_symbol = s[1];
        t->pull = s[2];
        t->new_state = s[3];
        t->push = s[4];
        return t;
    }
    
    /* turn the string into transitions and add into list */
    List *insert_list( List *l, char *elem ) {
        List *t = calloc(1,sizeof(List));
        List *head = l;
        while(l->next!=NULL)
            l = l->next;
        t->content = get_transistion(elem);
        t->next = NULL;
        l->next = t;
        return head;
    }
    
    /* insert a transistion into a list */
    List *insert_list_transistion( List *l, Transistion *tr) {
        List *t = calloc(1,sizeof(List));
        List *head = l;
        while(l->next!=NULL)
            l = l->next;
        t->content = tr;
        t->next = NULL;
        l->next = t;
        return head;
    }
    
    /*test if the char c is in the string s */
    int contains ( char c, char *s ) {
        int i=0;
        while(1) {
            if(c== s[i]) return 1;
            if(s[i] == '\0') return 0;
            i++;
        }
    }
    
    /* test if the input is a valid input */
    int is_valid_input( char *input_alpha, char *input ) {
        int i=0;
        char c;
        while(1) {
            c = input[i];
            if(c == '\0') break;
            if(!contains(c,input_alpha)) return 0;
            i++;
        }
        return 1;
    }
    
    /* test if the input is a valid transistion */
    int is_valid_transistion ( List *l, PDA *m) {
        Transistion *t;
        while(1) {
            if(l==NULL) break;
            t = l->content;
            if(!contains(t->input_symbol,m->input_alpha)) return 0;
            if(!contains(t->pull,m->stack_alpha)) return 0;
            if(!contains(t->push,m->stack_alpha)) return 0;
            l = l->next;
        }
        return 1;
    }
    
    /* create a pushdown automata */
    PDA *createPDA (char *input) {
        PDA *m = calloc(1,sizeof(PDA));
        List *tr = calloc(1,sizeof(List));
        char *buffer;
        char *epsilon = calloc(1,sizeof(char));
        /*read input alphabet of PDA*/
        buffer = strtok(input,"":"");
        if(buffer == NULL) {
            printf(""Error in reading input alphabet!\n"");
            exit(1);
        }
        m->input_alpha = buffer;
        epsilon[0] = m->input_alpha[0];
        /*read stack alphabet*/
        buffer = strtok(NULL,"":"");
    
        if(buffer == NULL) {
            printf(""Error in reading stack alphabet!\n"");
            exit(1);
        }
        m->stack_alpha = buffer;
    
        /*read input sequence*/
        buffer = strtok(NULL,"":"");
    
        if(buffer == NULL) {
            printf(""Error in reading input sequence!\n"");
            exit(1);
        }
    
        if(!is_valid_input(m->input_alpha,buffer)) {
            printf(""Error! Input contains some invalid characters that don't match the input alphabet!\n"");
            exit(1);
        }
    
        m->input = buffer;
    
        /*read start state*/
        buffer = strtok(NULL,"":"");
        if(buffer == NULL) {
            printf(""Invalid string!\n"");
            exit(1);
        }
        m->start = buffer[0];
    
        /*read accept state*/
        buffer = strtok(NULL,"":"");
        if(buffer == NULL) {
            printf(""Invalid string!\n"");
            exit(1);
        }
        m->accept = buffer;
    
        /*read transistion function*/
        while(1) {
            buffer = strtok(NULL,"":"");
            if(buffer == NULL) break;
            tr = insert_list(tr,buffer);
        }
    
        if(!is_valid_transistion(tr->next,m)) {
            printf(""Error! Invalid transistion functions!\n"");
            exit(1);
        }
    
        m->transistion = tr->next;
        return m;
    }
    
    /*print a stack */
    void print_stack2(Stack *s) {
        if(s==NULL) {
            return;
        }
        print_stack2(s->next);
        printf(""%c"",s->content);
    }
    
    void print_stack(Stack *s) {
        print_stack2(s);
        printf(""\n"");
    }
    
    /* find a proper transistion fuction for the current state */
    Transistion *find_transistion(List *list,char input,char current,char e) {
        Transistion *t;
        while(1) {
            if(list==NULL) return NULL;
            t = list -> content;
            if(t->current_state == current && t->input_symbol == input)
                return t;
            if(t->current_state == current && t->input_symbol == e)
                return t;
            list = list->next;
        }
    }
    
    int isAccept(char current, char* accept) {
        int i=0;
        while(1) {
            if(accept[i]=='\0') return 0;
            if(accept[i]==current) return 1;
            i++;
        }
    }
    
    /*simulate the Pushdown automata */
    void simulate(PDA *m) {
        /* first symbol in input symbol used to represent the usual */
        const char epsilon = m->input_alpha[0];
        char current_state = m->start;
        char input;
        int i=0;
        Stack *sta = create_stack();
        Transistion *current_transistion;
        Stack *backup;
    
        while(1) {
    
            /*get input*/
            input = m->input[i];
    
            if(input == '\0'&&isAccept(current_state,m->accept)) {
                printf(""Accept\n"");
                print_stack(sta);
                break;
            }
            /*get transistion function*/
            current_transistion = find_transistion(m->transistion,input,current_state,epsilon);
    
            if(current_transistion==NULL) {
                printf(""Reject\n"");
                print_stack(sta);
                break;
            }
    
            current_state = current_transistion->new_state;
            backup = sta;
            sta = replace(sta, current_transistion->pull, current_transistion->push,epsilon);
            if(sta == NULL) {
                printf(""Reject\n"");
                print_stack(backup);
                break;
            }
            if(current_transistion->input_symbol != epsilon&&current_transistion->input_symbol != '\0')
                i++;
        }
    }
    
    void print(PDA *m) {
        printf(""input alphabet:%s\n"",m->input_alpha);
        printf(""stack alphabet:%s\n"",m->stack_alpha);
        printf(""input sequence:%s\n"",m->input);
        printf(""start state:%c\n"",m->start);
        printf(""accept state:%s\n"",m->accept);
    }
    
    int main(void) {
        char s[300];
        PDA *p;
        scanf(""%s"",s);
        p = createPDA(s);
        simulate(p);
        return 0;
    }

When trying to compile, the compiler tells me the following error:

    Line 41: ""error: invalid conversion from 'void *' to 'Stack *'

how I can fix this error, since I'm trying to understand
code.


  [1]: http://code.zhoubot.com/",c,compiler-errors,stack,pushdown-automaton,,,open,0,3345,9,"Error Compiling an Deterministic Pushdown Automaton in C (DPDA) I was reading about how to implement a DPDA and found this code in the following Internet address: [http://code.zhoubot.com/][1], This c file implements a simple pushdown automata. The automata will read in a description of their transition function and input, perform its computation on the input, and then print their output.

The input format is like:
e01:e0$:000111:a:ad:aeeb$:b0eb0:b10ce:c10ce:ce$de
The input is separated by a semicolon :, first section is input alphabet, second is stack alphabet, then input and the last whole bunch are transition functions.


    /* This C file implements a Determinitic Pushdown Automata
     * author: Kevin Zhou
     * Computer Science and Electronics
     * University of Bristol
     */
    
    #include<stdio.h>
    #include<stdlib.h>
    #include<string.h>
    
    typedef struct stack {
        char content;
        struct stack *next;
    } Stack;
    
    typedef struct transistion {
        char current_state;
        char input_symbol;
        char pull;
        char new_state;
        char push;
    } Transistion;
    
    /* list of transistion functions */
    typedef struct list {
        Transistion *content;
        struct list *next;
    } List;
    
    typedef struct pda {
        char *input_alpha;
        char *stack_alpha;
        char *input;
        char start;
        char *accept;
        List *transistion;
    } PDA;
    
    /* create a new empty stack */
    Stack *create_stack( void ) {
        Stack *s = calloc(1,sizeof(Stack));
        if(s==NULL) {
            printf(""Out of Memory!"");
            exit(1);
        }
        return s;
    }
    
    /* test if the stack is empty */
    int isempty( Stack *s ) {
        return (s->next==NULL)? 1:0;
    }
    
    Stack *push_stack (Stack *s, char c) {
        Stack *new = calloc(1,sizeof(Stack));
        if(new ==NULL) {
            printf(""Out of Memory!"");
            exit(1);
        }
        new -> content = c;
        new -> next = s;
        return new;
    }
    
    Stack *pull_stack (Stack *s) {
        Stack *head;
        if(isempty(s)) {
            return '\0';
        }
        head = s;
        s = head -> next;
        return s;
    }
    
    /*return the top elememt in the stack */
    char top (Stack *s) {
        return s->content;
    }
    
    /*  replace a value 'ontop' which on top of the stack with a newvalue 'newvalue'
        epsilon represents an empty element*/
    
    Stack *replace(Stack *sta, char ontop, char newvalue, char epsilon) {
        if(ontop == epsilon && newvalue == epsilon) return sta;
        if(ontop == epsilon && newvalue != epsilon) {
            sta = push_stack(sta,newvalue);
            return sta;
        }
        if(ontop != epsilon && newvalue == epsilon) {
            if(ontop != top(sta)) return NULL;
            sta = pull_stack(sta);
            return sta;
        }
        if(ontop != top(sta)) return NULL;
        sta = pull_stack(sta);
        sta = push_stack(sta,newvalue);
        return sta;
    }
    
    /* turn the input string into transistion fields */
    Transistion *get_transistion(char *s) {
        Transistion *t = calloc(1,sizeof(Transistion));
        t->current_state = s[0];
        t->input_symbol = s[1];
        t->pull = s[2];
        t->new_state = s[3];
        t->push = s[4];
        return t;
    }
    
    /* turn the string into transitions and add into list */
    List *insert_list( List *l, char *elem ) {
        List *t = calloc(1,sizeof(List));
        List *head = l;
        while(l->next!=NULL)
            l = l->next;
        t->content = get_transistion(elem);
        t->next = NULL;
        l->next = t;
        return head;
    }
    
    /* insert a transistion into a list */
    List *insert_list_transistion( List *l, Transistion *tr) {
        List *t = calloc(1,sizeof(List));
        List *head = l;
        while(l->next!=NULL)
            l = l->next;
        t->content = tr;
        t->next = NULL;
        l->next = t;
        return head;
    }
    
    /*test if the char c is in the string s */
    int contains ( char c, char *s ) {
        int i=0;
        while(1) {
            if(c== s[i]) return 1;
            if(s[i] == '\0') return 0;
            i++;
        }
    }
    
    /* test if the input is a valid input */
    int is_valid_input( char *input_alpha, char *input ) {
        int i=0;
        char c;
        while(1) {
            c = input[i];
            if(c == '\0') break;
            if(!contains(c,input_alpha)) return 0;
            i++;
        }
        return 1;
    }
    
    /* test if the input is a valid transistion */
    int is_valid_transistion ( List *l, PDA *m) {
        Transistion *t;
        while(1) {
            if(l==NULL) break;
            t = l->content;
            if(!contains(t->input_symbol,m->input_alpha)) return 0;
            if(!contains(t->pull,m->stack_alpha)) return 0;
            if(!contains(t->push,m->stack_alpha)) return 0;
            l = l->next;
        }
        return 1;
    }
    
    /* create a pushdown automata */
    PDA *createPDA (char *input) {
        PDA *m = calloc(1,sizeof(PDA));
        List *tr = calloc(1,sizeof(List));
        char *buffer;
        char *epsilon = calloc(1,sizeof(char));
        /*read input alphabet of PDA*/
        buffer = strtok(input,"":"");
        if(buffer == NULL) {
            printf(""Error in reading input alphabet!\n"");
            exit(1);
        }
        m->input_alpha = buffer;
        epsilon[0] = m->input_alpha[0];
        /*read stack alphabet*/
        buffer = strtok(NULL,"":"");
    
        if(buffer == NULL) {
            printf(""Error in reading stack alphabet!\n"");
            exit(1);
        }
        m->stack_alpha = buffer;
    
        /*read input sequence*/
        buffer = strtok(NULL,"":"");
    
        if(buffer == NULL) {
            printf(""Error in reading input sequence!\n"");
            exit(1);
        }
    
        if(!is_valid_input(m->input_alpha,buffer)) {
            printf(""Error! Input contains some invalid characters that don't match the input alphabet!\n"");
            exit(1);
        }
    
        m->input = buffer;
    
        /*read start state*/
        buffer = strtok(NULL,"":"");
        if(buffer == NULL) {
            printf(""Invalid string!\n"");
            exit(1);
        }
        m->start = buffer[0];
    
        /*read accept state*/
        buffer = strtok(NULL,"":"");
        if(buffer == NULL) {
            printf(""Invalid string!\n"");
            exit(1);
        }
        m->accept = buffer;
    
        /*read transistion function*/
        while(1) {
            buffer = strtok(NULL,"":"");
            if(buffer == NULL) break;
            tr = insert_list(tr,buffer);
        }
    
        if(!is_valid_transistion(tr->next,m)) {
            printf(""Error! Invalid transistion functions!\n"");
            exit(1);
        }
    
        m->transistion = tr->next;
        return m;
    }
    
    /*print a stack */
    void print_stack2(Stack *s) {
        if(s==NULL) {
            return;
        }
        print_stack2(s->next);
        printf(""%c"",s->content);
    }
    
    void print_stack(Stack *s) {
        print_stack2(s);
        printf(""\n"");
    }
    
    /* find a proper transistion fuction for the current state */
    Transistion *find_transistion(List *list,char input,char current,char e) {
        Transistion *t;
        while(1) {
            if(list==NULL) return NULL;
            t = list -> content;
            if(t->current_state == current && t->input_symbol == input)
                return t;
            if(t->current_state == current && t->input_symbol == e)
                return t;
            list = list->next;
        }
    }
    
    int isAccept(char current, char* accept) {
        int i=0;
        while(1) {
            if(accept[i]=='\0') return 0;
            if(accept[i]==current) return 1;
            i++;
        }
    }
    
    /*simulate the Pushdown automata */
    void simulate(PDA *m) {
        /* first symbol in input symbol used to represent the usual */
        const char epsilon = m->input_alpha[0];
        char current_state = m->start;
        char input;
        int i=0;
        Stack *sta = create_stack();
        Transistion *current_transistion;
        Stack *backup;
    
        while(1) {
    
            /*get input*/
            input = m->input[i];
    
            if(input == '\0'&&isAccept(current_state,m->accept)) {
                printf(""Accept\n"");
                print_stack(sta);
                break;
            }
            /*get transistion function*/
            current_transistion = find_transistion(m->transistion,input,current_state,epsilon);
    
            if(current_transistion==NULL) {
                printf(""Reject\n"");
                print_stack(sta);
                break;
            }
    
            current_state = current_transistion->new_state;
            backup = sta;
            sta = replace(sta, current_transistion->pull, current_transistion->push,epsilon);
            if(sta == NULL) {
                printf(""Reject\n"");
                print_stack(backup);
                break;
            }
            if(current_transistion->input_symbol != epsilon&&current_transistion->input_symbol != '\0')
                i++;
        }
    }
    
    void print(PDA *m) {
        printf(""input alphabet:%s\n"",m->input_alpha);
        printf(""stack alphabet:%s\n"",m->stack_alpha);
        printf(""input sequence:%s\n"",m->input);
        printf(""start state:%c\n"",m->start);
        printf(""accept state:%s\n"",m->accept);
    }
    
    int main(void) {
        char s[300];
        PDA *p;
        scanf(""%s"",s);
        p = createPDA(s);
        simulate(p);
        return 0;
    }

When trying to compile, the compiler tells me the following error:

    Line 41: ""error: invalid conversion from 'void *' to 'Stack *'

how I can fix this error, since I'm trying to understand
code.


  [1]: http://code.zhoubot.com/",4
9150397,02/05/2012 15:22:31,1017584,10/28/2011 01:27:07,16,0,warning: ignoring return value of 'system' c,"In my program I put this code for instructs program to spawn a command. This can be used to start another program using a key in my program, such as to spawn firefox. Using program-command run_command ""firefox"" will have program call system( ""firefox &"" ). 

        case RUN_COMMAND:
            if( arg ) {
                char commandline[ 256 ];
                snprintf( commandline, sizeof (commandline), ""%s &"", arg );
                if( cmd->screen ) {
                    char message[ 256 ];
                    snprintf( message, sizeof (message), _(""Running: %s""), arg );
                    screen_show_message( cmd->screen, message );
                }
                system( commandline );
            }
            break;


When I compile it give this error:

    warning: ignoring return value of 'system', declared with attribute warn_unused_result [-Wunused-result]",c,,,,,02/05/2012 22:51:43,not a real question,1,282,7,"warning: ignoring return value of 'system' c In my program I put this code for instructs program to spawn a command. This can be used to start another program using a key in my program, such as to spawn firefox. Using program-command run_command ""firefox"" will have program call system( ""firefox &"" ). 

        case RUN_COMMAND:
            if( arg ) {
                char commandline[ 256 ];
                snprintf( commandline, sizeof (commandline), ""%s &"", arg );
                if( cmd->screen ) {
                    char message[ 256 ];
                    snprintf( message, sizeof (message), _(""Running: %s""), arg );
                    screen_show_message( cmd->screen, message );
                }
                system( commandline );
            }
            break;


When I compile it give this error:

    warning: ignoring return value of 'system', declared with attribute warn_unused_result [-Wunused-result]",1
100904,09/19/2008 10:12:36,18657,09/19/2008 08:47:58,1,0,How can I overcome inconsistent behaviour of snprintf in different UNIX-like operating systems??,"Per man pages, snprintf is returning number of bytes written from glibc version 2.2 onwards. But on lower versions of libc2.2 and HP-UX, it returns a positive integer, which could lead to a buffer overflow.

How can one overcome this and write portable code?",c,,,,,,open,0,43,13,"How can I overcome inconsistent behaviour of snprintf in different UNIX-like operating systems?? Per man pages, snprintf is returning number of bytes written from glibc version 2.2 onwards. But on lower versions of libc2.2 and HP-UX, it returns a positive integer, which could lead to a buffer overflow.

How can one overcome this and write portable code?",1
5778906,04/25/2011 13:40:48,676531,03/25/2011 10:31:02,94,9,error in c code,i have a c code which gives me error that is segmented fault what that error means i don't get it.,c,,,,,04/25/2011 13:42:59,not a real question,1,21,4,error in c code i have a c code which gives me error that is segmented fault what that error means i don't get it.,1
7927072,10/28/2011 08:54:04,966379,09/27/2011 06:21:23,29,0,Wheather C standard library is static library or dynamic library?," Is C standard library function(ex.prinf, scanf) treated as static libray function or dynamic library function?",c,,,,,11/14/2011 11:51:16,not a real question,1,16,10,"Wheather C standard library is static library or dynamic library?  Is C standard library function(ex.prinf, scanf) treated as static libray function or dynamic library function?",1
6275558,06/08/2011 07:34:52,373466,06/22/2010 17:57:32,167,1,Question about while(!EOF)...,"Im reading in values from `stdin` and I want to keep reading the file until I have completed reading it all the way, so I am using 

    while(!EOF){ scanf(...) }

However, the code fragment doesn't seem to do anything,

    while(!EOF){
    	
    		
    	scanf(""%d %d %d %d"", &imageWidth, &imageHeight, &safeRegionStart, &safeRegionWidth);
    
    	printf(""---imageWidth=%d imageHeight=%d safeRegionStart=%d safeRegionWidth=%d---\n"", imageWidth, imageHeight, safeRegionStart, safeRegionWidth);
    	totalP = imageWidth * imageHeight ;
    	totalSafeP = imageHeight * safeRegionWidth;
    	
    
    	printf(""---total # of pixels: %d Total # of safe Pixels: %d---\n\n"", totalP, totalSafeP);
    
    	i=1;
    
    	while(i!=totalP)
    	{
    		i++;
    		scanf(""%d"", &pixel);
    		printf(""\nValue of pixel %d"", pixel);
    		
     			
    	}//End for scanning all pixels*/
    }//while loop
",c,stdin,eof,,,,open,0,180,3,"Question about while(!EOF)... Im reading in values from `stdin` and I want to keep reading the file until I have completed reading it all the way, so I am using 

    while(!EOF){ scanf(...) }

However, the code fragment doesn't seem to do anything,

    while(!EOF){
    	
    		
    	scanf(""%d %d %d %d"", &imageWidth, &imageHeight, &safeRegionStart, &safeRegionWidth);
    
    	printf(""---imageWidth=%d imageHeight=%d safeRegionStart=%d safeRegionWidth=%d---\n"", imageWidth, imageHeight, safeRegionStart, safeRegionWidth);
    	totalP = imageWidth * imageHeight ;
    	totalSafeP = imageHeight * safeRegionWidth;
    	
    
    	printf(""---total # of pixels: %d Total # of safe Pixels: %d---\n\n"", totalP, totalSafeP);
    
    	i=1;
    
    	while(i!=totalP)
    	{
    		i++;
    		scanf(""%d"", &pixel);
    		printf(""\nValue of pixel %d"", pixel);
    		
     			
    	}//End for scanning all pixels*/
    }//while loop
",3
3855307,10/04/2010 12:43:18,465818,10/04/2010 12:37:27,1,0,fprintf keeps putting in extra characters I don't want. Can't I stop this?,"Im trying to write out an image file that has the following structure: 

    P5      //magic number
    512 512 //dimension of image
    255     //max value per pixel
    [Image Data.....]

The standard says after max value there should be a whitespace or newline, then the image data.  For whatever mysterious reason, the code below >always< adds in 2 characters at the end of the header (A carriage return and line feed). Which shifts every pixel off by 1. 

Here's what I do:

       FILE *outfile; 
       outfile = fopen(filename,""w"");
       int i =0, j =0;
       if(outfile==NULL || outfile == 0){
       printf(""Output Failed\n"");
       return;
       }
       //print header first 
       fprintf(outfile, ""P5\r%d %d\r255"",width,height);  
       //print out data now, all one line.
       for(i = 0; i<height; i++){
             for(j=0;j<width;j++){
                  fprintf(outfile, ""%c"",pic[j][i]);
             }
       }
       
       fclose(outfile);
       printf(""output to %s complete.\n"", filename);          
       return;

Is there a C subtlety that I'm missing here? How do I get it to not print that extra character? I did a few experiments and I'm at a loss. Thanks for your time. ",c,file-io,,,,,open,0,337,13,"fprintf keeps putting in extra characters I don't want. Can't I stop this? Im trying to write out an image file that has the following structure: 

    P5      //magic number
    512 512 //dimension of image
    255     //max value per pixel
    [Image Data.....]

The standard says after max value there should be a whitespace or newline, then the image data.  For whatever mysterious reason, the code below >always< adds in 2 characters at the end of the header (A carriage return and line feed). Which shifts every pixel off by 1. 

Here's what I do:

       FILE *outfile; 
       outfile = fopen(filename,""w"");
       int i =0, j =0;
       if(outfile==NULL || outfile == 0){
       printf(""Output Failed\n"");
       return;
       }
       //print header first 
       fprintf(outfile, ""P5\r%d %d\r255"",width,height);  
       //print out data now, all one line.
       for(i = 0; i<height; i++){
             for(j=0;j<width;j++){
                  fprintf(outfile, ""%c"",pic[j][i]);
             }
       }
       
       fclose(outfile);
       printf(""output to %s complete.\n"", filename);          
       return;

Is there a C subtlety that I'm missing here? How do I get it to not print that extra character? I did a few experiments and I'm at a loss. Thanks for your time. ",2
7630294,10/03/2011 01:04:57,722000,04/23/2011 18:41:47,144,1,Program to add digits of a number,"This is a program to a 5 digit number from user and output the sum of digits. The program works for some numbers. See the output image

    #include <stdio.h>
    #include <conio.h>
    #include <math.h>
    
    long sumDigits(long n)
    {
     long sum = 0;
     int rem;
    
     if(n>0)
     {
       rem = n%10;
       sum = sumDigits(n/10) + rem;
     }
    
     return sum;
    }
    
    
    
    void main()
    {
     long num,digits,sum;
    
     clrscr();
     printf(""Enter a number: "");
    
     start_again:
     scanf(""%ld"", &num);
    
     digits = log10(num) + 1;
     if(digits>5)
      {
        printf(""The number you have entered has more than 5 digits. \nPlease enter a new number \n"");
        goto start_again;
      }
    
     sum = sumDigits(num);
     printf(""\nSum of digits = %ld"", sum);
    
     getch();
    }

This is the output I get:

![enter image description here][1]


  [1]: http://i.stack.imgur.com/zYB29.png",c,homework,,,,10/03/2011 08:36:39,not a real question,1,289,7,"Program to add digits of a number This is a program to a 5 digit number from user and output the sum of digits. The program works for some numbers. See the output image

    #include <stdio.h>
    #include <conio.h>
    #include <math.h>
    
    long sumDigits(long n)
    {
     long sum = 0;
     int rem;
    
     if(n>0)
     {
       rem = n%10;
       sum = sumDigits(n/10) + rem;
     }
    
     return sum;
    }
    
    
    
    void main()
    {
     long num,digits,sum;
    
     clrscr();
     printf(""Enter a number: "");
    
     start_again:
     scanf(""%ld"", &num);
    
     digits = log10(num) + 1;
     if(digits>5)
      {
        printf(""The number you have entered has more than 5 digits. \nPlease enter a new number \n"");
        goto start_again;
      }
    
     sum = sumDigits(num);
     printf(""\nSum of digits = %ld"", sum);
    
     getch();
    }

This is the output I get:

![enter image description here][1]


  [1]: http://i.stack.imgur.com/zYB29.png",2
3501399,08/17/2010 10:17:44,421382,08/16/2010 05:17:20,6,0,c program fo directory monitor,i want c program for directory monitor,c,,,,,08/17/2010 10:26:52,not a real question,1,7,5,c program fo directory monitor i want c program for directory monitor,1
10939911,06/07/2012 21:09:07,1440212,06/06/2012 15:51:16,3,0,String compare function in C,"    map[0][4]='\0';
	city1[0][4]='\0';
	strcpy(map[0],city1[0]);
	map[0][0]='z';
	printf(""%s"",map[0]);
	printf(""%s"",city1[0]);
	printf(""%d \n"",strcmp(map[0],city1[0]));
Hello guys the output of this fuction is `zail
nail
12 `,Why it is so? What i did not understand aboutstrcmp? why 12 not any other number",c,string,,,,06/11/2012 21:49:32,not a real question,1,30,5,"String compare function in C     map[0][4]='\0';
	city1[0][4]='\0';
	strcpy(map[0],city1[0]);
	map[0][0]='z';
	printf(""%s"",map[0]);
	printf(""%s"",city1[0]);
	printf(""%d \n"",strcmp(map[0],city1[0]));
Hello guys the output of this fuction is `zail
nail
12 `,Why it is so? What i did not understand aboutstrcmp? why 12 not any other number",2
7360391,09/09/2011 10:38:21,775964,05/30/2011 08:47:06,416,26,In multi thread application how can i redirect stderr & stdout in separate file as per thread?,"i have multi thread application in which i m creating thread like this

    int main(int argc,char *argv[])
    {
        pthread_t thread_id[argc-1];
        int i;
        struct parameter thread_data[argc-1];
        int status;
        for(i=0;i<argc-1;i++)
    	{
    	thread_data[i].ip_filename = argv[i+1];
    	strcpy (thread_data[i].op_filename,argv[i+1]);
    	strcat (thread_data[i].op_filename,"".h264"");
    	}
    
       for(i=0;i<argc-1;i++)
        {
       	pthread_create (&thread_id[i], NULL , &thread_function, &thread_data[i]);
       }      
    }

now in thread function 

**i want to redirect stderr & stdout in one separate file as per thread**

somethig like thread log file

how can i do so.? 
",c,linux,pthreads,,,,open,0,167,17,"In multi thread application how can i redirect stderr & stdout in separate file as per thread? i have multi thread application in which i m creating thread like this

    int main(int argc,char *argv[])
    {
        pthread_t thread_id[argc-1];
        int i;
        struct parameter thread_data[argc-1];
        int status;
        for(i=0;i<argc-1;i++)
    	{
    	thread_data[i].ip_filename = argv[i+1];
    	strcpy (thread_data[i].op_filename,argv[i+1]);
    	strcat (thread_data[i].op_filename,"".h264"");
    	}
    
       for(i=0;i<argc-1;i++)
        {
       	pthread_create (&thread_id[i], NULL , &thread_function, &thread_data[i]);
       }      
    }

now in thread function 

**i want to redirect stderr & stdout in one separate file as per thread**

somethig like thread log file

how can i do so.? 
",3
7440065,09/16/2011 04:08:46,948102,09/16/2011 04:00:11,1,0,How to return a char function in C prog?,"I am not sure how to store the return char function so I can return it to be used in the main function,

    char process_3 (int step_2)
    {
	if (step_2 % 2 == 0)
	{
		printf (""A"");
	}
	else if (step_2 % 3 == 0)
	{
		printf (""F"");
	}
	if (step_2 % 5 == 0)
	{
		printf (""K"");
	}
	else if (step_2 % 7 == 0)
	{
		printf (""P"");
	}
	if (step_2 % 11 == 0 || step_2 % 13 == 0)
	{
		printf (""T"");
	}
	else
	{
		printf (""Z"");
	}
	return process_3;
   }
",c,,,,,09/16/2011 11:06:20,too localized,1,77,9,"How to return a char function in C prog? I am not sure how to store the return char function so I can return it to be used in the main function,

    char process_3 (int step_2)
    {
	if (step_2 % 2 == 0)
	{
		printf (""A"");
	}
	else if (step_2 % 3 == 0)
	{
		printf (""F"");
	}
	if (step_2 % 5 == 0)
	{
		printf (""K"");
	}
	else if (step_2 % 7 == 0)
	{
		printf (""P"");
	}
	if (step_2 % 11 == 0 || step_2 % 13 == 0)
	{
		printf (""T"");
	}
	else
	{
		printf (""Z"");
	}
	return process_3;
   }
",1
10684499,05/21/2012 11:37:24,472531,10/11/2010 17:24:46,16,0,Sharing same variable between more than one independent program in Linux,"I want to share a variable between more than one independent C executables in Linux. That is, a program will write on a array and set a flag so that no other program can use it, and after this operation it'll unset the flag and then another program will read the array. I tries using the same custom header file(containing the variable) in every program, but it seems different instances of the variables are created when the programs are invoked. Please, help.
Thanks in advanced.",c,linux,,,,05/22/2012 14:54:56,not a real question,1,84,11,"Sharing same variable between more than one independent program in Linux I want to share a variable between more than one independent C executables in Linux. That is, a program will write on a array and set a flag so that no other program can use it, and after this operation it'll unset the flag and then another program will read the array. I tries using the same custom header file(containing the variable) in every program, but it seems different instances of the variables are created when the programs are invoked. Please, help.
Thanks in advanced.",2
5928168,05/08/2011 14:58:37,347432,05/21/2010 20:10:05,23,0,"Stupid mistakes in C. Break, Switch, If. 1990 Crash of Telephone Network","I was hesitating to ask this, since it seems very easy.

What is wrong in this pseudocode?

In the switching software (written in C), there was a long   
""do... while"" construct, which contained   
a ""switch"" statement, which contained   
an ""if' clause, which contained a   
""break,"" which was intended for   
the ""if"" clause, but instead broke from   
the ""switch"" statement. 

This caused a crash of the telefone system in 1990. 
http://users.csc.calpoly.edu/~jdalbey/SWE/Papers/att_collapse.html

I need a very simple, explaination, why this code is wrong. I think the most simple answer is that within a if clause a break is not possible? So what statement needs to be written instead of a break within a if clause for getting the wanted effect, which is breaking the if clause? 

",c,history,common-mistakes,,,05/09/2011 13:49:27,not a real question,1,134,12,"Stupid mistakes in C. Break, Switch, If. 1990 Crash of Telephone Network I was hesitating to ask this, since it seems very easy.

What is wrong in this pseudocode?

In the switching software (written in C), there was a long   
""do... while"" construct, which contained   
a ""switch"" statement, which contained   
an ""if' clause, which contained a   
""break,"" which was intended for   
the ""if"" clause, but instead broke from   
the ""switch"" statement. 

This caused a crash of the telefone system in 1990. 
http://users.csc.calpoly.edu/~jdalbey/SWE/Papers/att_collapse.html

I need a very simple, explaination, why this code is wrong. I think the most simple answer is that within a if clause a break is not possible? So what statement needs to be written instead of a break within a if clause for getting the wanted effect, which is breaking the if clause? 

",3
8484104,12/13/2011 03:50:24,838025,07/10/2011 23:11:14,18,0,C scanf format string warning,"I'm working on Euler #3 (http://projecteuler.net/problem=3). I think I've got the logic right, but I'm getting an error when trying to use scanf (and printf) with a long. I'm current trying to use %li and this is the error I'm getting:

    euler3.c: In function main:
    euler3.c:30: warning: format %li expects type long int **, but argument 2 has type long int
    euler3.c:30: warning: format %li expects type long int *, but argument 2 has type long int

I understand the error, but for the life of me I can't find the solution. Here's my code if it's needed.



    #include <stdio.h>
    
    long greatestPrime(long num)
    {
            int i;
    
            for(i = 2; i <= num; i++)
            {
                    if(num%i == 0)
                    {
                            num = num/i;
                            i--;
                    }
            }
    
            return num;
    }
    
    int main(int argc, char *argv[])
    {
            unsigned long greatest;
    
            printf(""Enter number to find prime factor: "");
            scanf(""%li"",greatest);
    
            printf(""%li"",greatestPrime(greatest));
    
            return 0;
    }




Thanks in advance!",c,project-euler,scanf,format-string,,,open,0,428,5,"C scanf format string warning I'm working on Euler #3 (http://projecteuler.net/problem=3). I think I've got the logic right, but I'm getting an error when trying to use scanf (and printf) with a long. I'm current trying to use %li and this is the error I'm getting:

    euler3.c: In function main:
    euler3.c:30: warning: format %li expects type long int **, but argument 2 has type long int
    euler3.c:30: warning: format %li expects type long int *, but argument 2 has type long int

I understand the error, but for the life of me I can't find the solution. Here's my code if it's needed.



    #include <stdio.h>
    
    long greatestPrime(long num)
    {
            int i;
    
            for(i = 2; i <= num; i++)
            {
                    if(num%i == 0)
                    {
                            num = num/i;
                            i--;
                    }
            }
    
            return num;
    }
    
    int main(int argc, char *argv[])
    {
            unsigned long greatest;
    
            printf(""Enter number to find prime factor: "");
            scanf(""%li"",greatest);
    
            printf(""%li"",greatestPrime(greatest));
    
            return 0;
    }




Thanks in advance!",4
5890524,05/04/2011 22:18:41,253458,01/18/2010 19:20:20,133,0,if I am listening on 2 ports with one Listening Socket how can I tell which port received the packet?,"I have an application that is listening on 2 ports, it appears that when I can my function
WS_SetUpListener (see code below) with 2 different ports, I receive the same ListeningSocket for both, so when a packet arrives at either of the 2 ports, how can I tell what port it was sent to?

I call the function as follows: 

    ListeningSocket = WS_SetUpListener(port);

the code for it is:

    SOCKET WS_SetUpListener(int port)
    {
	char port_buf[20] = {0};
	struct addrinfo *result = NULL, hints;

	SOCKET ListenSocket = INVALID_SOCKET;

	//char recvbuf[DEFAULT_BUFLEN];
	int iResult;
	//int iSendResult;
	int recvbuflen = DEFAULT_BUFLEN;

	sprintf_s(port_buf, sizeof(port_buf), ""%d"", port);


	ZeroMemory(&hints, sizeof (hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the local address and port to be used by the server
	iResult = getaddrinfo(NULL, port_buf, &hints, &result);
	if (iResult != 0) 
	{
		printf(""getaddrinfo failed: %d\n"", iResult);
		return INVALID_SOCKET;
	}

	// Create a SOCKET for the server to listen for client connections
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (ListenSocket == INVALID_SOCKET)
	{
		printf(""***ERROR*** at socket(): %ld\n"", WSAGetLastError());
		freeaddrinfo(result);
		return INVALID_SOCKET;
	}

	// Set up the TCP listening socket
	iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR)
	{
		printf(""bind failed: %d\n"", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(ListenSocket);
		return INVALID_SOCKET;
	}

	freeaddrinfo(result);

	iResult = listen(ListenSocket, SOMAXCONN);
	if ( iResult == SOCKET_ERROR ) 
	{
	    printf( ""Error at bind(): %ld\n"", WSAGetLastError() );
		closesocket(ListenSocket);
		return INVALID_SOCKET;
	}

	return ListenSocket;
     }",c,windows,sockets,,,,open,0,200,20,"if I am listening on 2 ports with one Listening Socket how can I tell which port received the packet? I have an application that is listening on 2 ports, it appears that when I can my function
WS_SetUpListener (see code below) with 2 different ports, I receive the same ListeningSocket for both, so when a packet arrives at either of the 2 ports, how can I tell what port it was sent to?

I call the function as follows: 

    ListeningSocket = WS_SetUpListener(port);

the code for it is:

    SOCKET WS_SetUpListener(int port)
    {
	char port_buf[20] = {0};
	struct addrinfo *result = NULL, hints;

	SOCKET ListenSocket = INVALID_SOCKET;

	//char recvbuf[DEFAULT_BUFLEN];
	int iResult;
	//int iSendResult;
	int recvbuflen = DEFAULT_BUFLEN;

	sprintf_s(port_buf, sizeof(port_buf), ""%d"", port);


	ZeroMemory(&hints, sizeof (hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the local address and port to be used by the server
	iResult = getaddrinfo(NULL, port_buf, &hints, &result);
	if (iResult != 0) 
	{
		printf(""getaddrinfo failed: %d\n"", iResult);
		return INVALID_SOCKET;
	}

	// Create a SOCKET for the server to listen for client connections
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (ListenSocket == INVALID_SOCKET)
	{
		printf(""***ERROR*** at socket(): %ld\n"", WSAGetLastError());
		freeaddrinfo(result);
		return INVALID_SOCKET;
	}

	// Set up the TCP listening socket
	iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR)
	{
		printf(""bind failed: %d\n"", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(ListenSocket);
		return INVALID_SOCKET;
	}

	freeaddrinfo(result);

	iResult = listen(ListenSocket, SOMAXCONN);
	if ( iResult == SOCKET_ERROR ) 
	{
	    printf( ""Error at bind(): %ld\n"", WSAGetLastError() );
		closesocket(ListenSocket);
		return INVALID_SOCKET;
	}

	return ListenSocket;
     }",3
736670,04/10/2009 04:10:15,66593,02/15/2009 08:10:45,31,2,"To find the smallest no. from the given list of no. (Question is bit tricky, cannot explain just in Title)","Please give me a simple logic to build this very small program in Java or C programming..

There is an array for e.g.

a[0] - 2
a[1] - 2
a[2] - 2
a[3] - 3
a[4] - 3
a[5] - 4
a[6] - 3

Now i want to find out the smallest no. from the given list of nos. The question is some what tricky in which, we can see a[0] consists of smallest no. but if it is rejected (some logic, due to which it is rejected) then it should call a[1] being the second smallest and third smallest and so on and so forth.. It should return me the array position of the smallest no.

One thing should be noted in mind that no array content should be deleted or anything else, the state of array should not be changed.. A constraint which i have taken up in my project and it will not allow me to change the state of the array.

So please give me some very small concept or function or program which could do this needful task.. This is the small concept in my project.. So desperately need an answer..",c,java,,,,,open,0,185,20,"To find the smallest no. from the given list of no. (Question is bit tricky, cannot explain just in Title) Please give me a simple logic to build this very small program in Java or C programming..

There is an array for e.g.

a[0] - 2
a[1] - 2
a[2] - 2
a[3] - 3
a[4] - 3
a[5] - 4
a[6] - 3

Now i want to find out the smallest no. from the given list of nos. The question is some what tricky in which, we can see a[0] consists of smallest no. but if it is rejected (some logic, due to which it is rejected) then it should call a[1] being the second smallest and third smallest and so on and so forth.. It should return me the array position of the smallest no.

One thing should be noted in mind that no array content should be deleted or anything else, the state of array should not be changed.. A constraint which i have taken up in my project and it will not allow me to change the state of the array.

So please give me some very small concept or function or program which could do this needful task.. This is the small concept in my project.. So desperately need an answer..",2
4301711,11/29/2010 07:37:10,523608,11/29/2010 07:37:10,1,0,about numerical functions available in c language's library,give the list and their discription of  numerical functions available in c language's library,c,,,,,11/29/2010 07:39:33,not a real question,1,15,8,about numerical functions available in c language's library give the list and their discription of  numerical functions available in c language's library,1
9027346,01/27/2012 00:06:22,1172503,01/27/2012 00:03:05,1,0,How to create a large integer datatype in C without using longint datatype from library?,"I want to create a large integer datatype without using longinteger datatype and define basic function like add, multiply, etc.",c,,,,,01/27/2012 00:17:16,not a real question,1,20,15,"How to create a large integer datatype in C without using longint datatype from library? I want to create a large integer datatype without using longinteger datatype and define basic function like add, multiply, etc.",1
7479889,09/20/2011 03:45:12,953932,09/20/2011 03:45:12,1,0,strtok_r tokens with delimiters,"I've found similar posts, but no clear answers to my questions about strtok_r.
So, I'm using strtok_r to parse a command line to get commands I need to execute via execv with flags, however, for testing purposes, I print out. When trying to delimit multiple characters, excluding whitespace, it works fine. But when testing for whitespace, using the code below:


        void tokenize(char *str1)
        {
          char *token;
          char *saveptr1;
          int j, i;


          const char *delim = "" "";
          i = strlen(str1);

          for(j = 0; j < i; j++, str1 = NULL)
          {
            token = strtok_r(str1, delim, &saveptr1);
            if(token == NULL)
              break;

            printf(""save: %s\n"", token);
            printf(""\n"");
          }
        }

I get the following output for a test string (ls -al):

save: ls

any thoughts?

",c,strtok,,,,,open,0,267,4,"strtok_r tokens with delimiters I've found similar posts, but no clear answers to my questions about strtok_r.
So, I'm using strtok_r to parse a command line to get commands I need to execute via execv with flags, however, for testing purposes, I print out. When trying to delimit multiple characters, excluding whitespace, it works fine. But when testing for whitespace, using the code below:


        void tokenize(char *str1)
        {
          char *token;
          char *saveptr1;
          int j, i;


          const char *delim = "" "";
          i = strlen(str1);

          for(j = 0; j < i; j++, str1 = NULL)
          {
            token = strtok_r(str1, delim, &saveptr1);
            if(token == NULL)
              break;

            printf(""save: %s\n"", token);
            printf(""\n"");
          }
        }

I get the following output for a test string (ls -al):

save: ls

any thoughts?

",2
10089345,04/10/2012 13:03:25,597858,02/01/2011 04:28:34,494,12,any alternate algorithm in C,"The question is to write a program that takes an integer keyed in from the terminal and extracts and displays each digit of the integer in English. so, if a user types 932, the program should display 'nine three two'..

My algorithm is to reverse the number first so that 932 becomes 239. now I extract the last digit using mod operator and print. divide the number by 10. extract the last digit again and so on...

Is there any other alogirthm (shorter and efficient) possible?

it is possible to extract the last digit of an integer. Is it possible to extract the first digit and so on?",c,algorithm,,,,,open,0,105,5,"any alternate algorithm in C The question is to write a program that takes an integer keyed in from the terminal and extracts and displays each digit of the integer in English. so, if a user types 932, the program should display 'nine three two'..

My algorithm is to reverse the number first so that 932 becomes 239. now I extract the last digit using mod operator and print. divide the number by 10. extract the last digit again and so on...

Is there any other alogirthm (shorter and efficient) possible?

it is possible to extract the last digit of an integer. Is it possible to extract the first digit and so on?",2
2754493,05/02/2010 18:36:48,74815,03/06/2009 17:55:05,13987,640,Hello world in C with no semi-colons?,"I recently heard this was used as an interview question.  I suspect there is a very simple answer; I must be over-thinking it.

> Can you write Hello World in C without
> using any semi-colons?  If so, how?",c,hello-world,interview-questions,semicolon,,05/23/2012 01:49:53,not constructive,1,39,7,"Hello world in C with no semi-colons? I recently heard this was used as an interview question.  I suspect there is a very simple answer; I must be over-thinking it.

> Can you write Hello World in C without
> using any semi-colons?  If so, how?",4
10659238,05/18/2012 20:24:10,1387216,05/10/2012 13:29:45,29,0,Key-indexed search in existence tables,"I have a doubt about one of my book's statement.

Talking about key-indexed search in a symbol table, at a certain point it says: ""*If there aren't records (but only keys), we can use a bit table. In this case, the symbol table is called existence table, because we can consider the k-th bit as an indicator whether the k key there is or there isn't in the table. For example, using a 313-word table on a 32-bit computer, we can use this method to quickly determine whether a given 4-digit internal telephone number was already assigned.*""

Well, I know what a word is, thus that existence table should be a 10.016-bit table, in that case. But what does it mean? What does that fact of the 4-digit telephone number have to do with it? And so, how you can implement a symbol table with key-indexed search, when the records correspond to the keys?",c,,,,,,open,0,152,5,"Key-indexed search in existence tables I have a doubt about one of my book's statement.

Talking about key-indexed search in a symbol table, at a certain point it says: ""*If there aren't records (but only keys), we can use a bit table. In this case, the symbol table is called existence table, because we can consider the k-th bit as an indicator whether the k key there is or there isn't in the table. For example, using a 313-word table on a 32-bit computer, we can use this method to quickly determine whether a given 4-digit internal telephone number was already assigned.*""

Well, I know what a word is, thus that existence table should be a 10.016-bit table, in that case. But what does it mean? What does that fact of the 4-digit telephone number have to do with it? And so, how you can implement a symbol table with key-indexed search, when the records correspond to the keys?",1
9778586,03/19/2012 22:00:07,331637,05/03/2010 17:17:57,776,30,Comparing version numbers in ANSI C,"I'm in need of a piece of c code that can compare two version-numbers, preferably in <a href=""http://semver.org/"">'semantic versioning'</a> format (0.1.7, 1.3.2), to determine which one is the later version. 

Yes, I could certainly write this code myself. However, I expect thousands of developers to have done this before me, so I decided to see whether I could benefit from some community work first.",c,versioning,semantic-versioning,,,03/19/2012 22:12:45,not a real question,1,64,6,"Comparing version numbers in ANSI C I'm in need of a piece of c code that can compare two version-numbers, preferably in <a href=""http://semver.org/"">'semantic versioning'</a> format (0.1.7, 1.3.2), to determine which one is the later version. 

Yes, I could certainly write this code myself. However, I expect thousands of developers to have done this before me, so I decided to see whether I could benefit from some community work first.",3
11686699,07/27/2012 11:17:50,1055475,11/19/2011 16:11:07,60,0,Hints and tips for writing a screensaver using xscreensaver?,"I have been doing some light OpenGL programming for a couple of months and now I want to write a screensaver using the xscreensaver library.

I saw http://stackoverflow.com/questions/1124817/how-to-develop-linux-screen-saver before asking this but I think that particular question is not specific enough.

I want some tips about how to go about writing a screensaver using xscreensaver. Any tutorial links would be helpful too.

Note: I downloaded the xscreensaver source and read README.hacking. I am fooling around with the code for greynetic.c in the source's hacks directory but I don't understand how I should go about compiling and executing any changes I make to the greynetic.c file.

Bonus question: I read this webpage - http://www.dis.uniroma1.it/~liberato/screensaver/simplesquares.html The author has provided the source to simplesquares.c but compiling with gcc and running the executable shows no output at all. Am I doing something wrong?

PS: Maybe someone with enough reputation could create a screensaver tag? Because this question doesn't quite fit well anywhere else.",c,linux,opengl,,,07/28/2012 07:01:12,not a real question,1,154,9,"Hints and tips for writing a screensaver using xscreensaver? I have been doing some light OpenGL programming for a couple of months and now I want to write a screensaver using the xscreensaver library.

I saw http://stackoverflow.com/questions/1124817/how-to-develop-linux-screen-saver before asking this but I think that particular question is not specific enough.

I want some tips about how to go about writing a screensaver using xscreensaver. Any tutorial links would be helpful too.

Note: I downloaded the xscreensaver source and read README.hacking. I am fooling around with the code for greynetic.c in the source's hacks directory but I don't understand how I should go about compiling and executing any changes I make to the greynetic.c file.

Bonus question: I read this webpage - http://www.dis.uniroma1.it/~liberato/screensaver/simplesquares.html The author has provided the source to simplesquares.c but compiling with gcc and running the executable shows no output at all. Am I doing something wrong?

PS: Maybe someone with enough reputation could create a screensaver tag? Because this question doesn't quite fit well anywhere else.",3
5855490,05/02/2011 09:27:46,734215,05/02/2011 09:27:46,1,0,Print top three numbers and their position,Write a program to print top three numbers and their positions in the list using only while loop and if else statement in a given list of 10 numbers taken from the user.,c,,,,,05/02/2011 10:13:28,not a real question,1,33,7,Print top three numbers and their position Write a program to print top three numbers and their positions in the list using only while loop and if else statement in a given list of 10 numbers taken from the user.,1
6493058,06/27/2011 12:47:44,386764,07/08/2010 14:31:32,50,0,Read text from a website in C,"I'm trying to read a simple text string from a website into my C program. I'm using LabWindows CVI, which is basically just C.

Here's the text:  
http://www.swpc.noaa.gov/ftpdir/latest/wwv.txt",c,http,text,,,06/27/2011 13:57:54,not a real question,1,28,7,"Read text from a website in C I'm trying to read a simple text string from a website into my C program. I'm using LabWindows CVI, which is basically just C.

Here's the text:  
http://www.swpc.noaa.gov/ftpdir/latest/wwv.txt",3
9959537,03/31/2012 20:43:19,924387,09/01/2011 23:07:38,6,0,Base16 with custom hextable,"I'd like to encode/decode data using Base16 but with a custom hextable (as opposed to the conventional '0123456789ABCDEF')

I've considered simply replacing every digit/letter with the corresponding one after writing it but I find that inefficient for obvious reasons

This is for an iphone app, which means I'm using objective-c code but that C and C++ also work with it.

I tried the code here: http://www.koders.com/c/fid4FE13B3E182CA09D7F399059A96DBF0A7968BA5C.aspx?s=base64

    #ifdef HAVE_CONFIG_H
    #  include <config.h>
    #endif
    
    #include <string.h>
    #include <stdlib.h>
    
    #include ""ggz.h""
    #include ""base16.h""
    
    /* Function to encode strings to base16 (hex) with a nibble per hex character */
    
    char *ggz_base16_encode(const char *text, int length)
    {
    	char *ret = NULL;
    	int i;
    	static const char hextable[20] = ""0123456789abcdef"";
    
    	if(!text) return NULL;
    
    	ret = ggz_malloc((length * 2 + 1)*sizeof(*ret));
    	if(!ret) return NULL;
    
    	for(i = 0; i < length; i++){
    		ret[i*2] = hextable[(text[i]&0xf0)>>4];
    		ret[i*2+1] = hextable[text[i]&0xf];
    	}
    	return ret;
    }

But I don't find the decoding method on the same site, and also its not working anyways. This is my corresponding objective-c code for it:

    NSString *txt = @""hello"";
    NSData *data = [txt dataUsingEncoding:NSUTF8StringEncoding];
    const char *nc = ggz_base16_encode(data.bytes, [data length]);
    NSString *str = [[NSString alloc] initWithCString:nc encoding:NSUTF8StringEncoding];
    }

Help would be much appreciated.

Thanks",c,ios,hex,,,,open,0,303,4,"Base16 with custom hextable I'd like to encode/decode data using Base16 but with a custom hextable (as opposed to the conventional '0123456789ABCDEF')

I've considered simply replacing every digit/letter with the corresponding one after writing it but I find that inefficient for obvious reasons

This is for an iphone app, which means I'm using objective-c code but that C and C++ also work with it.

I tried the code here: http://www.koders.com/c/fid4FE13B3E182CA09D7F399059A96DBF0A7968BA5C.aspx?s=base64

    #ifdef HAVE_CONFIG_H
    #  include <config.h>
    #endif
    
    #include <string.h>
    #include <stdlib.h>
    
    #include ""ggz.h""
    #include ""base16.h""
    
    /* Function to encode strings to base16 (hex) with a nibble per hex character */
    
    char *ggz_base16_encode(const char *text, int length)
    {
    	char *ret = NULL;
    	int i;
    	static const char hextable[20] = ""0123456789abcdef"";
    
    	if(!text) return NULL;
    
    	ret = ggz_malloc((length * 2 + 1)*sizeof(*ret));
    	if(!ret) return NULL;
    
    	for(i = 0; i < length; i++){
    		ret[i*2] = hextable[(text[i]&0xf0)>>4];
    		ret[i*2+1] = hextable[text[i]&0xf];
    	}
    	return ret;
    }

But I don't find the decoding method on the same site, and also its not working anyways. This is my corresponding objective-c code for it:

    NSString *txt = @""hello"";
    NSData *data = [txt dataUsingEncoding:NSUTF8StringEncoding];
    const char *nc = ggz_base16_encode(data.bytes, [data length]);
    NSString *str = [[NSString alloc] initWithCString:nc encoding:NSUTF8StringEncoding];
    }

Help would be much appreciated.

Thanks",3
3156286,07/01/2010 08:53:56,291427,03/11/2010 11:46:27,51,0,standard structure for C header and source files,"Is there any standardized structure of C source and header files?

I'm thinking about something like this (example for C source file):
<code>

// static variables 

// public variables

// static methods

// public methods

</code>

",c,templates,,,,,open,0,30,8,"standard structure for C header and source files Is there any standardized structure of C source and header files?

I'm thinking about something like this (example for C source file):
<code>

// static variables 

// public variables

// static methods

// public methods

</code>

",2
6167685,05/29/2011 12:21:19,381088,07/01/2010 12:36:12,566,0,"Please review code for ""Merge 2 sorted linked list..""","My coding skill is pretty rusty and moreover, I have never paid much attention to writing elegant code. I want to start on this. Problem is to merge 2 sorted linked list. Algorithmically this is trivial, but looks a good problem to practice coding.

    struct node
    {
    char *data;
    struct node *nextp;
    }

    typedef struct node node;
    typedef struct node list; //I do 2 typedefs here to signify when conceptually I
    //mean a whole list and when just a single node.is this a good practice? or only  
    //one that confuses.

    node * add(node *listp, char *data)
    {
    node * newp=(node *)malloc(sizeof(node));
    newp->data=(char *)malloc(sizeof(strlen(data));
    strcpy(newp->data,data); // allocate space in newp->data . should there be +1?
    newp->next=NULL;
    if(listp==NULL) 
    listp=nextp ;
    else
    listp->nextp=newp;
    return newp;
    }

    list *mergelist(list * list1p, list *list2p)
    {
    // initialize mergedlistp;
    node* mergedlistendp=NULL;
    list* leftlistp = NULL;

    if (list1p == NULL) leftlistp=list2p;
    if(list2p == NULL) leftlistp = list1p;

    if(list1p != NULL && list2p!= NULL)
    {
    while(1)
    {

    if(strcmp(list1p -> data,list2p -> data) <=0)
    {
    mergedlistendp=add (mergedlistendp,list1p->data);
    list1p=list1p -> next;
    if(list1p == NULL)
    {leftlistp=list2p; break;}
    }
    else
    {
    mergedlistendp=add (mergedlistendp,list2p->data);
    list2p=list2p -> next;
    if(list2p == NULL)
    {leftlistp=list1p; break;}
    }
    
    }
    
    for(leftlistp!=NULL;leftlistp = leftlistp->next) 
    add(mergedlistendp,leftlistp->data);

    return mergedlistendp; // I have to return mergedlistp here (i.e. head of list)
    //. How to store address of mergedlistendp the first time it is assigned a value?
}


I know that this forum has many experts and I would like my code to be reviewed.Any feedback on naming, program flow, correctness, better code, indenting, idioms etc is appreciated. Please advise on how corner cases are handled more elegantly.

Thanks!",c,interview-questions,linked-list,,,05/29/2011 12:37:12,off topic,1,427,9,"Please review code for ""Merge 2 sorted linked list.."" My coding skill is pretty rusty and moreover, I have never paid much attention to writing elegant code. I want to start on this. Problem is to merge 2 sorted linked list. Algorithmically this is trivial, but looks a good problem to practice coding.

    struct node
    {
    char *data;
    struct node *nextp;
    }

    typedef struct node node;
    typedef struct node list; //I do 2 typedefs here to signify when conceptually I
    //mean a whole list and when just a single node.is this a good practice? or only  
    //one that confuses.

    node * add(node *listp, char *data)
    {
    node * newp=(node *)malloc(sizeof(node));
    newp->data=(char *)malloc(sizeof(strlen(data));
    strcpy(newp->data,data); // allocate space in newp->data . should there be +1?
    newp->next=NULL;
    if(listp==NULL) 
    listp=nextp ;
    else
    listp->nextp=newp;
    return newp;
    }

    list *mergelist(list * list1p, list *list2p)
    {
    // initialize mergedlistp;
    node* mergedlistendp=NULL;
    list* leftlistp = NULL;

    if (list1p == NULL) leftlistp=list2p;
    if(list2p == NULL) leftlistp = list1p;

    if(list1p != NULL && list2p!= NULL)
    {
    while(1)
    {

    if(strcmp(list1p -> data,list2p -> data) <=0)
    {
    mergedlistendp=add (mergedlistendp,list1p->data);
    list1p=list1p -> next;
    if(list1p == NULL)
    {leftlistp=list2p; break;}
    }
    else
    {
    mergedlistendp=add (mergedlistendp,list2p->data);
    list2p=list2p -> next;
    if(list2p == NULL)
    {leftlistp=list1p; break;}
    }
    
    }
    
    for(leftlistp!=NULL;leftlistp = leftlistp->next) 
    add(mergedlistendp,leftlistp->data);

    return mergedlistendp; // I have to return mergedlistp here (i.e. head of list)
    //. How to store address of mergedlistendp the first time it is assigned a value?
}


I know that this forum has many experts and I would like my code to be reviewed.Any feedback on naming, program flow, correctness, better code, indenting, idioms etc is appreciated. Please advise on how corner cases are handled more elegantly.

Thanks!",3
5838714,04/30/2011 00:48:54,708969,04/15/2011 00:37:33,8,0,"Convert a .c file, that was created on a Mac, to Windows","Is there a way to convert a .c file that was created on a Mac to be compatible with VS2010? Or am I stuck having to re-type the code by hand?

Thanks!",c,windows,visual-studio-2010,osx,,04/30/2011 11:47:12,not a real question,1,31,12,"Convert a .c file, that was created on a Mac, to Windows Is there a way to convert a .c file that was created on a Mac to be compatible with VS2010? Or am I stuck having to re-type the code by hand?

Thanks!",4
5753838,04/22/2011 08:52:05,239522,12/28/2009 11:20:47,199,0,Use #define preprocessor directive in a weird way,"Today I just finish reading and experimenting on C about how to use `#define` to create a manifest constant , after that something came into my mind , and below is the code.

    #include <stdio.h>
    #define dummy main
    #define yam {
    #define apple }

    int dummy(void)        //constant substitution main with dummy
    yam                          // constant substitution { with yam
      printf(""It works!!\n"");
      return 0;
    apple                           //constant substitution } with apple

<b>As expected , it works like charm , I just wonder why something like that didn't cause any error , maybe i could understand why the `main()` could be substituted because `main` is an identifier(**name given to a function , variable and constant) , but why the `{}` can be substituted with a symbolic name too??The second thing is , what data type C use to store this symbolic constant which is not a character enclosed in single quote `""""` nor an integer or floating-point number.</b>


<i>Thanks for spending time reading my post , your help is much appreciated.</i>

 ",c,define,identifier,,,,open,0,255,8,"Use #define preprocessor directive in a weird way Today I just finish reading and experimenting on C about how to use `#define` to create a manifest constant , after that something came into my mind , and below is the code.

    #include <stdio.h>
    #define dummy main
    #define yam {
    #define apple }

    int dummy(void)        //constant substitution main with dummy
    yam                          // constant substitution { with yam
      printf(""It works!!\n"");
      return 0;
    apple                           //constant substitution } with apple

<b>As expected , it works like charm , I just wonder why something like that didn't cause any error , maybe i could understand why the `main()` could be substituted because `main` is an identifier(**name given to a function , variable and constant) , but why the `{}` can be substituted with a symbolic name too??The second thing is , what data type C use to store this symbolic constant which is not a character enclosed in single quote `""""` nor an integer or floating-point number.</b>


<i>Thanks for spending time reading my post , your help is much appreciated.</i>

 ",3
11052800,06/15/2012 14:36:39,1124295,12/31/2011 12:26:09,23,0,Game programming C,"i want to make a litle game (like snake) who is live runned.
i mean that a string is change in ""live"" without new lines by a loop.
search in google alot, couldnt fine anything at all.
example : 
 hello world
  hello world
   hello world
    hello world
     hello world
      hello world
in the same line, deleting the first, replace the second without new lines.",c,linux,,,,06/15/2012 14:40:11,not a real question,1,76,3,"Game programming C i want to make a litle game (like snake) who is live runned.
i mean that a string is change in ""live"" without new lines by a loop.
search in google alot, couldnt fine anything at all.
example : 
 hello world
  hello world
   hello world
    hello world
     hello world
      hello world
in the same line, deleting the first, replace the second without new lines.",2
9389557,02/22/2012 05:30:20,1089679,12/09/2011 12:08:53,184,2,FOTA : How can i do firmware update over the air?,"Here i want to update my device fireware.

After downloading the file from somewhere(server) what can i do for update the firmware?

Please Tell me the way how can i achieve this and which things i have to keep in my mind to achieve this goal.

What is the Steps for this?

i want to make first design how can i go ahead to achieve this goal.

i researched on this on google but i cant get any useful link which give me clear idea about this.

Please provides me some useful links so from that i can get clear idea about this.

here i have on link regarding my research [link][1]


  [1]: http://www.zeeis.com/firmware-over-the-air/?gclid=CJShrIDssK4CFUp76wod-G5URA",c,firmware,ota,,,02/22/2012 14:32:52,not a real question,1,108,11,"FOTA : How can i do firmware update over the air? Here i want to update my device fireware.

After downloading the file from somewhere(server) what can i do for update the firmware?

Please Tell me the way how can i achieve this and which things i have to keep in my mind to achieve this goal.

What is the Steps for this?

i want to make first design how can i go ahead to achieve this goal.

i researched on this on google but i cant get any useful link which give me clear idea about this.

Please provides me some useful links so from that i can get clear idea about this.

here i have on link regarding my research [link][1]


  [1]: http://www.zeeis.com/firmware-over-the-air/?gclid=CJShrIDssK4CFUp76wod-G5URA",3
7549940,09/26/2011 01:48:45,956759,09/21/2011 11:01:04,24,0,Could someone explain these code snippets?,"In the following code, could someone explain to me how the following works?

	/*
	 * sniffex.c
	 *
	 * Sniffer example of TCP/IP packet capture using libpcap.
	 * 
	 * Version 0.1.1 (2005-07-05)
	 * Copyright (c) 2005 The Tcpdump Group
	 *
	 * This software is intended to be used as a practical example and 
	 * demonstration of the libpcap library; available at:
	 * http://www.tcpdump.org/
	 *
	 ****************************************************************************
	 *
	 * This software is a modification of Tim Carstens' ""sniffer.c""
	 * demonstration source code, released as follows:
	 * 
	 * sniffer.c
	 * Copyright (c) 2002 Tim Carstens
	 * 2002-01-07
	 * Demonstration of using libpcap
	 * timcarst -at- yahoo -dot- com
	 * 
	 * ""sniffer.c"" is distributed under these terms:
	 * 
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 4. The name ""Tim Carstens"" may not be used to endorse or promote
	 *    products derived from this software without prior written permission
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
	 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	 * SUCH DAMAGE.
	 * <end of ""sniffer.c"" terms>
	 *
	 * This software, ""sniffex.c"", is a derivative work of ""sniffer.c"" and is
	 * covered by the following terms:
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Because this is a derivative work, you must comply with the ""sniffer.c""
	 *    terms reproduced above.
	 * 2. Redistributions of source code must retain the Tcpdump Group copyright
	 *    notice at the top of this source file, this list of conditions and the
	 *    following disclaimer.
	 * 3. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 4. The names ""tcpdump"" or ""libpcap"" may not be used to endorse or promote
	 *    products derived from this software without prior written permission.
	 *
	 * THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.
	 * BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
	 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
	 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
	 * PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
	 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
	 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
	 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
	 * REPAIR OR CORRECTION.
	 * 
	 * IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
	 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
	 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
	 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
	 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
	 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
	 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
	 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGES.
	 * <end of ""sniffex.c"" terms>
	 * 
	 ****************************************************************************
	 *
	 * Below is an excerpt from an email from Guy Harris on the tcpdump-workers
	 * mail list when someone asked, ""How do I get the length of the TCP
	 * payload?"" Guy Harris' slightly snipped response (edited by him to
	 * speak of the IPv4 header length and TCP data offset without referring
	 * to bitfield structure members) is reproduced below:
	 * 
	 * The Ethernet size is always 14 bytes.
	 * 
	 * <snip>...</snip>
	 *
	 * In fact, you *MUST* assume the Ethernet header is 14 bytes, *and*, if 
	 * you're using structures, you must use structures where the members 
	 * always have the same size on all platforms, because the sizes of the 
	 * fields in Ethernet - and IP, and TCP, and... - headers are defined by 
	 * the protocol specification, not by the way a particular platform's C 
	 * compiler works.)
	 *
	 * The IP header size, in bytes, is the value of the IP header length,
	 * as extracted from the ""ip_vhl"" field of ""struct sniff_ip"" with
	 * the ""IP_HL()"" macro, times 4 (""times 4"" because it's in units of
	 * 4-byte words).  If that value is less than 20 - i.e., if the value
	 * extracted with ""IP_HL()"" is less than 5 - you have a malformed
	 * IP datagram.
	 *
	 * The TCP header size, in bytes, is the value of the TCP data offset,
	 * as extracted from the ""th_offx2"" field of ""struct sniff_tcp"" with
	 * the ""TH_OFF()"" macro, times 4 (for the same reason - 4-byte words).
	 * If that value is less than 20 - i.e., if the value extracted with
	 * ""TH_OFF()"" is less than 5 - you have a malformed TCP segment.
	 *
	 * So, to find the IP header in an Ethernet packet, look 14 bytes after 
	 * the beginning of the packet data.  To find the TCP header, look 
	 * ""IP_HL(ip)*4"" bytes after the beginning of the IP header.  To find the
	 * TCP payload, look ""TH_OFF(tcp)*4"" bytes after the beginning of the TCP
	 * header.
	 * 
	 * To find out how much payload there is:
	 *
	 * Take the IP *total* length field - ""ip_len"" in ""struct sniff_ip"" 
	 * - and, first, check whether it's less than ""IP_HL(ip)*4"" (after
	 * you've checked whether ""IP_HL(ip)"" is >= 5).  If it is, you have
	 * a malformed IP datagram.
	 *
	 * Otherwise, subtract ""IP_HL(ip)*4"" from it; that gives you the length
	 * of the TCP segment, including the TCP header.  If that's less than
	 * ""TH_OFF(tcp)*4"" (after you've checked whether ""TH_OFF(tcp)"" is >= 5),
	 * you have a malformed TCP segment.
	 *
	 * Otherwise, subtract ""TH_OFF(tcp)*4"" from it; that gives you the
	 * length of the TCP payload.
	 *
	 * Note that you also need to make sure that you don't go past the end 
	 * of the captured data in the packet - you might, for example, have a 
	 * 15-byte Ethernet packet that claims to contain an IP datagram, but if 
	 * it's 15 bytes, it has only one byte of Ethernet payload, which is too 
	 * small for an IP header.  The length of the captured data is given in 
	 * the ""caplen"" field in the ""struct pcap_pkthdr""; it might be less than 
	 * the length of the packet, if you're capturing with a snapshot length 
	 * other than a value >= the maximum packet size.
	 * <end of response>
	 * 
	 ****************************************************************************
	 * 
	 * Example compiler command-line for GCC:
	 *   gcc -Wall -o sniffex sniffex.c -lpcap
	 * 
	 ****************************************************************************
	 *
	 * Code Comments
	 *
	 * This section contains additional information and explanations regarding
	 * comments in the source code. It serves as documentaion and rationale
	 * for why the code is written as it is without hindering readability, as it
	 * might if it were placed along with the actual code inline. References in
	 * the code appear as footnote notation (e.g. [1]).
	 *
	 * 1. Ethernet headers are always exactly 14 bytes, so we define this
	 * explicitly with ""#define"". Since some compilers might pad structures to a
	 * multiple of 4 bytes - some versions of GCC for ARM may do this -
	 * ""sizeof (struct sniff_ethernet)"" isn't used.
	 * 
	 * 2. Check the link-layer type of the device that's being opened to make
	 * sure it's Ethernet, since that's all we handle in this example. Other
	 * link-layer types may have different length headers (see [1]).
	 *
	 * 3. This is the filter expression that tells libpcap which packets we're
	 * interested in (i.e. which packets to capture). Since this source example
	 * focuses on IP and TCP, we use the expression ""ip"", so we know we'll only
	 * encounter IP packets. The capture filter syntax, along with some
	 * examples, is documented in the tcpdump man page under ""expression.""
	 * Below are a few simple examples:
	 *
	 * Expression			Description
	 * ----------			-----------
	 * ip					Capture all IP packets.
	 * tcp					Capture only TCP packets.
	 * tcp port 80			Capture only TCP packets with a port equal to 80.
	 * ip host 10.1.2.3		Capture all IP packets to or from host 10.1.2.3.
	 *
	 ****************************************************************************
	 *
	 */

	#define APP_NAME		""sniffex""
	#define APP_DESC		""Sniffer example using libpcap""
	#define APP_COPYRIGHT	""Copyright (c) 2005 The Tcpdump Group""
	#define APP_DISCLAIMER	""THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.""

	#include <pcap.h>
	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	#include <ctype.h>
	#include <errno.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <arpa/inet.h>

	/* default snap length (maximum bytes per packet to capture) */
	#define SNAP_LEN 1518

	/* ethernet headers are always exactly 14 bytes [1] */
	#define SIZE_ETHERNET 14

	/* Ethernet addresses are 6 bytes */
	#define ETHER_ADDR_LEN	6

	/* Ethernet header */
	struct sniff_ethernet {
			u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
			u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
			u_short ether_type;                     /* IP? ARP? RARP? etc */
	};

	/* IP header */
	struct sniff_ip {
			u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
			u_char  ip_tos;                 /* type of service */
			u_short ip_len;                 /* total length */
			u_short ip_id;                  /* identification */
			u_short ip_off;                 /* fragment offset field */
			#define IP_RF 0x8000            /* reserved fragment flag */
			#define IP_DF 0x4000            /* dont fragment flag */
			#define IP_MF 0x2000            /* more fragments flag */
			#define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
			u_char  ip_ttl;                 /* time to live */
			u_char  ip_p;                   /* protocol */
			u_short ip_sum;                 /* checksum */
			struct  in_addr ip_src,ip_dst;  /* source and dest address */
	};
	#define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
	#define IP_V(ip)                (((ip)->ip_vhl) >> 4)

	/* TCP header */
	typedef u_int tcp_seq;

	struct sniff_tcp {
			u_short th_sport;               /* source port */
			u_short th_dport;               /* destination port */
			tcp_seq th_seq;                 /* sequence number */
			tcp_seq th_ack;                 /* acknowledgement number */
			u_char  th_offx2;               /* data offset, rsvd */
	#define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
			u_char  th_flags;
			#define TH_FIN  0x01
			#define TH_SYN  0x02
			#define TH_RST  0x04
			#define TH_PUSH 0x08
			#define TH_ACK  0x10
			#define TH_URG  0x20
			#define TH_ECE  0x40
			#define TH_CWR  0x80
			#define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
			u_short th_win;                 /* window */
			u_short th_sum;                 /* checksum */
			u_short th_urp;                 /* urgent pointer */
	};

	void
	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);

	void
	print_payload(const u_char *payload, int len);

	void
	print_hex_ascii_line(const u_char *payload, int len, int offset);

	void
	print_app_banner(void);

	void
	print_app_usage(void);

	/*
	 * app name/banner
	 */
	void
	print_app_banner(void)
	{

		printf(""%s - %s\n"", APP_NAME, APP_DESC);
		printf(""%s\n"", APP_COPYRIGHT);
		printf(""%s\n"", APP_DISCLAIMER);
		printf(""\n"");

	return;
	}

	/*
	 * print help text
	 */
	void
	print_app_usage(void)
	{

		printf(""Usage: %s [interface]\n"", APP_NAME);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""    interface    Listen on <interface> for packets.\n"");
		printf(""\n"");

	return;
	}

	/*
	 * print data in rows of 16 bytes: offset   hex   ascii
	 *
	 * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
	 */
	void
	print_hex_ascii_line(const u_char *payload, int len, int offset)
	{

		int i;
		int gap;
		const u_char *ch;

		/* offset */
		printf(""%05d   "", offset);
	
		/* hex */
		ch = payload;
		for(i = 0; i < len; i++) {
			printf(""%02x "", *ch);
			ch++;
			/* print extra space after 8th byte for visual aid */
			if (i == 7)
				printf("" "");
		}
		/* print space to handle line less than 8 bytes */
		if (len < 8)
			printf("" "");
	
		/* fill hex gap with spaces if not full line */
		if (len < 16) {
			gap = 16 - len;
			for (i = 0; i < gap; i++) {
				printf(""   "");
			}
		}
		printf(""   "");
	
		/* ascii (if printable) */
		ch = payload;
		for(i = 0; i < len; i++) {
			if (isprint(*ch))
				printf(""%c"", *ch);
			else
				printf(""."");
			ch++;
		}

		printf(""\n"");

	return;
	}

	/*
	 * print packet payload data (avoid printing binary data)
	 */
	void
	print_payload(const u_char *payload, int len)
	{

		int len_rem = len;
		int line_width = 16;			/* number of bytes per line */
		int line_len;
		int offset = 0;					/* zero-based offset counter */
		const u_char *ch = payload;

		if (len <= 0)
			return;

		/* data fits on one line */
		if (len <= line_width) {
			print_hex_ascii_line(ch, len, offset);
			return;
		}

		/* data spans multiple lines */
		for ( ;; ) {
			/* compute current line length */
			line_len = line_width % len_rem;
			/* print line */
			print_hex_ascii_line(ch, line_len, offset);
			/* compute total remaining */
			len_rem = len_rem - line_len;
			/* shift pointer to remaining bytes to print */
			ch = ch + line_len;
			/* add offset */
			offset = offset + line_width;
			/* check if we have line width chars or less */
			if (len_rem <= line_width) {
				/* print last line and get out */
				print_hex_ascii_line(ch, len_rem, offset);
				break;
			}
		}

	return;
	}

	/*
	 * dissect/print packet
	 */
	void
	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
	{

		static int count = 1;                   /* packet counter */
	
		/* declare pointers to packet headers */
		const struct sniff_ethernet *ethernet;  /* The ethernet header [1] */
		const struct sniff_ip *ip;              /* The IP header */
		const struct sniff_tcp *tcp;            /* The TCP header */
		const char *payload;                    /* Packet payload */

		int size_ip;
		int size_tcp;
		int size_payload;
	
		printf(""\nPacket number %d:\n"", count);
		count++;
	
		/* define ethernet header */
		ethernet = (struct sniff_ethernet*)(packet);
	
		/* define/compute ip header offset */
		ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);
		size_ip = IP_HL(ip)*4;
		if (size_ip < 20) {
			printf(""   * Invalid IP header length: %u bytes\n"", size_ip);
			return;
		}

		/* print source and destination IP addresses */
		printf(""       From: %s\n"", inet_ntoa(ip->ip_src));
		printf(""         To: %s\n"", inet_ntoa(ip->ip_dst));
	
		/* determine protocol */	
		switch(ip->ip_p) {
			case IPPROTO_TCP:
				printf(""   Protocol: TCP\n"");
				break;
			case IPPROTO_UDP:
				printf(""   Protocol: UDP\n"");
				return;
			case IPPROTO_ICMP:
				printf(""   Protocol: ICMP\n"");
				return;
			case IPPROTO_IP:
				printf(""   Protocol: IP\n"");
				return;
			default:
				printf(""   Protocol: unknown\n"");
				return;
		}
	
		/*
		 *  OK, this packet is TCP.
		 */
	
		/* define/compute tcp header offset */
		tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
		size_tcp = TH_OFF(tcp)*4;
		if (size_tcp < 20) {
			printf(""   * Invalid TCP header length: %u bytes\n"", size_tcp);
			return;
		}
	
		printf(""   Src port: %d\n"", ntohs(tcp->th_sport));
		printf(""   Dst port: %d\n"", ntohs(tcp->th_dport));
	
		/* define/compute tcp payload (segment) offset */
		payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
	
		/* compute tcp payload (segment) size */
		size_payload = ntohs(ip->ip_len) - (size_ip + size_tcp);
	
		/*
		 * Print payload data; it might be binary, so don't just
		 * treat it as a string.
		 */
		if (size_payload > 0) {
			printf(""   Payload (%d bytes):\n"", size_payload);
			print_payload(payload, size_payload);
		}

	return;
	}

	int main(int argc, char **argv)
	{

		char *dev = NULL;			/* capture device name */
		char errbuf[PCAP_ERRBUF_SIZE];		/* error buffer */
		pcap_t *handle;				/* packet capture handle */

		char filter_exp[] = ""ip"";		/* filter expression [3] */
		struct bpf_program fp;			/* compiled filter program (expression) */
		bpf_u_int32 mask;			/* subnet mask */
		bpf_u_int32 net;			/* ip */
		int num_packets = 10;			/* number of packets to capture */

		print_app_banner();

		/* check for capture device name on command-line */
		if (argc == 2) {
			dev = argv[1];
		}
		else if (argc > 2) {
			fprintf(stderr, ""error: unrecognized command-line options\n\n"");
			print_app_usage();
			exit(EXIT_FAILURE);
		}
		else {
			/* find a capture device if not specified on command-line */
			dev = pcap_lookupdev(errbuf);
			if (dev == NULL) {
				fprintf(stderr, ""Couldn't find default device: %s\n"",
					errbuf);
				exit(EXIT_FAILURE);
			}
		}
	
		/* get network number and mask associated with capture device */
		if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
			fprintf(stderr, ""Couldn't get netmask for device %s: %s\n"",
				dev, errbuf);
			net = 0;
			mask = 0;
		}

		/* print capture info */
		printf(""Device: %s\n"", dev);
		printf(""Number of packets: %d\n"", num_packets);
		printf(""Filter expression: %s\n"", filter_exp);

		/* open capture device */
		handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
		if (handle == NULL) {
			fprintf(stderr, ""Couldn't open device %s: %s\n"", dev, errbuf);
			exit(EXIT_FAILURE);
		}

		/* make sure we're capturing on an Ethernet device [2] */
		if (pcap_datalink(handle) != DLT_EN10MB) {
			fprintf(stderr, ""%s is not an Ethernet\n"", dev);
			exit(EXIT_FAILURE);
		}

		/* compile the filter expression */
		if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
			fprintf(stderr, ""Couldn't parse filter %s: %s\n"",
				filter_exp, pcap_geterr(handle));
			exit(EXIT_FAILURE);
		}

		/* apply the compiled filter */
		if (pcap_setfilter(handle, &fp) == -1) {
			fprintf(stderr, ""Couldn't install filter %s: %s\n"",
				filter_exp, pcap_geterr(handle));
			exit(EXIT_FAILURE);
		}

		/* now we can set our callback function */
		pcap_loop(handle, num_packets, got_packet, NULL);

		/* cleanup */
		pcap_freecode(&fp);
		pcap_close(handle);

		printf(""\nCapture complete.\n"");

	return 0;
	}

Questions: 

    (struct sniff_ethernet*)(packet) // <== A char casted to a struct = a struct with valid data?
    (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip); // <== A char plus a couple ints casted to a struct = a struct with valid data?

",c,pcap,libpcap,sniffer,,09/26/2011 02:48:38,not constructive,1,3187,6,"Could someone explain these code snippets? In the following code, could someone explain to me how the following works?

	/*
	 * sniffex.c
	 *
	 * Sniffer example of TCP/IP packet capture using libpcap.
	 * 
	 * Version 0.1.1 (2005-07-05)
	 * Copyright (c) 2005 The Tcpdump Group
	 *
	 * This software is intended to be used as a practical example and 
	 * demonstration of the libpcap library; available at:
	 * http://www.tcpdump.org/
	 *
	 ****************************************************************************
	 *
	 * This software is a modification of Tim Carstens' ""sniffer.c""
	 * demonstration source code, released as follows:
	 * 
	 * sniffer.c
	 * Copyright (c) 2002 Tim Carstens
	 * 2002-01-07
	 * Demonstration of using libpcap
	 * timcarst -at- yahoo -dot- com
	 * 
	 * ""sniffer.c"" is distributed under these terms:
	 * 
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 4. The name ""Tim Carstens"" may not be used to endorse or promote
	 *    products derived from this software without prior written permission
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
	 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	 * SUCH DAMAGE.
	 * <end of ""sniffer.c"" terms>
	 *
	 * This software, ""sniffex.c"", is a derivative work of ""sniffer.c"" and is
	 * covered by the following terms:
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Because this is a derivative work, you must comply with the ""sniffer.c""
	 *    terms reproduced above.
	 * 2. Redistributions of source code must retain the Tcpdump Group copyright
	 *    notice at the top of this source file, this list of conditions and the
	 *    following disclaimer.
	 * 3. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 4. The names ""tcpdump"" or ""libpcap"" may not be used to endorse or promote
	 *    products derived from this software without prior written permission.
	 *
	 * THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.
	 * BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
	 * FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
	 * OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
	 * PROVIDE THE PROGRAM ""AS IS"" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
	 * OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
	 * TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
	 * PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
	 * REPAIR OR CORRECTION.
	 * 
	 * IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
	 * WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
	 * REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
	 * INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
	 * OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
	 * TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
	 * YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
	 * PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGES.
	 * <end of ""sniffex.c"" terms>
	 * 
	 ****************************************************************************
	 *
	 * Below is an excerpt from an email from Guy Harris on the tcpdump-workers
	 * mail list when someone asked, ""How do I get the length of the TCP
	 * payload?"" Guy Harris' slightly snipped response (edited by him to
	 * speak of the IPv4 header length and TCP data offset without referring
	 * to bitfield structure members) is reproduced below:
	 * 
	 * The Ethernet size is always 14 bytes.
	 * 
	 * <snip>...</snip>
	 *
	 * In fact, you *MUST* assume the Ethernet header is 14 bytes, *and*, if 
	 * you're using structures, you must use structures where the members 
	 * always have the same size on all platforms, because the sizes of the 
	 * fields in Ethernet - and IP, and TCP, and... - headers are defined by 
	 * the protocol specification, not by the way a particular platform's C 
	 * compiler works.)
	 *
	 * The IP header size, in bytes, is the value of the IP header length,
	 * as extracted from the ""ip_vhl"" field of ""struct sniff_ip"" with
	 * the ""IP_HL()"" macro, times 4 (""times 4"" because it's in units of
	 * 4-byte words).  If that value is less than 20 - i.e., if the value
	 * extracted with ""IP_HL()"" is less than 5 - you have a malformed
	 * IP datagram.
	 *
	 * The TCP header size, in bytes, is the value of the TCP data offset,
	 * as extracted from the ""th_offx2"" field of ""struct sniff_tcp"" with
	 * the ""TH_OFF()"" macro, times 4 (for the same reason - 4-byte words).
	 * If that value is less than 20 - i.e., if the value extracted with
	 * ""TH_OFF()"" is less than 5 - you have a malformed TCP segment.
	 *
	 * So, to find the IP header in an Ethernet packet, look 14 bytes after 
	 * the beginning of the packet data.  To find the TCP header, look 
	 * ""IP_HL(ip)*4"" bytes after the beginning of the IP header.  To find the
	 * TCP payload, look ""TH_OFF(tcp)*4"" bytes after the beginning of the TCP
	 * header.
	 * 
	 * To find out how much payload there is:
	 *
	 * Take the IP *total* length field - ""ip_len"" in ""struct sniff_ip"" 
	 * - and, first, check whether it's less than ""IP_HL(ip)*4"" (after
	 * you've checked whether ""IP_HL(ip)"" is >= 5).  If it is, you have
	 * a malformed IP datagram.
	 *
	 * Otherwise, subtract ""IP_HL(ip)*4"" from it; that gives you the length
	 * of the TCP segment, including the TCP header.  If that's less than
	 * ""TH_OFF(tcp)*4"" (after you've checked whether ""TH_OFF(tcp)"" is >= 5),
	 * you have a malformed TCP segment.
	 *
	 * Otherwise, subtract ""TH_OFF(tcp)*4"" from it; that gives you the
	 * length of the TCP payload.
	 *
	 * Note that you also need to make sure that you don't go past the end 
	 * of the captured data in the packet - you might, for example, have a 
	 * 15-byte Ethernet packet that claims to contain an IP datagram, but if 
	 * it's 15 bytes, it has only one byte of Ethernet payload, which is too 
	 * small for an IP header.  The length of the captured data is given in 
	 * the ""caplen"" field in the ""struct pcap_pkthdr""; it might be less than 
	 * the length of the packet, if you're capturing with a snapshot length 
	 * other than a value >= the maximum packet size.
	 * <end of response>
	 * 
	 ****************************************************************************
	 * 
	 * Example compiler command-line for GCC:
	 *   gcc -Wall -o sniffex sniffex.c -lpcap
	 * 
	 ****************************************************************************
	 *
	 * Code Comments
	 *
	 * This section contains additional information and explanations regarding
	 * comments in the source code. It serves as documentaion and rationale
	 * for why the code is written as it is without hindering readability, as it
	 * might if it were placed along with the actual code inline. References in
	 * the code appear as footnote notation (e.g. [1]).
	 *
	 * 1. Ethernet headers are always exactly 14 bytes, so we define this
	 * explicitly with ""#define"". Since some compilers might pad structures to a
	 * multiple of 4 bytes - some versions of GCC for ARM may do this -
	 * ""sizeof (struct sniff_ethernet)"" isn't used.
	 * 
	 * 2. Check the link-layer type of the device that's being opened to make
	 * sure it's Ethernet, since that's all we handle in this example. Other
	 * link-layer types may have different length headers (see [1]).
	 *
	 * 3. This is the filter expression that tells libpcap which packets we're
	 * interested in (i.e. which packets to capture). Since this source example
	 * focuses on IP and TCP, we use the expression ""ip"", so we know we'll only
	 * encounter IP packets. The capture filter syntax, along with some
	 * examples, is documented in the tcpdump man page under ""expression.""
	 * Below are a few simple examples:
	 *
	 * Expression			Description
	 * ----------			-----------
	 * ip					Capture all IP packets.
	 * tcp					Capture only TCP packets.
	 * tcp port 80			Capture only TCP packets with a port equal to 80.
	 * ip host 10.1.2.3		Capture all IP packets to or from host 10.1.2.3.
	 *
	 ****************************************************************************
	 *
	 */

	#define APP_NAME		""sniffex""
	#define APP_DESC		""Sniffer example using libpcap""
	#define APP_COPYRIGHT	""Copyright (c) 2005 The Tcpdump Group""
	#define APP_DISCLAIMER	""THERE IS ABSOLUTELY NO WARRANTY FOR THIS PROGRAM.""

	#include <pcap.h>
	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	#include <ctype.h>
	#include <errno.h>
	#include <sys/types.h>
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <arpa/inet.h>

	/* default snap length (maximum bytes per packet to capture) */
	#define SNAP_LEN 1518

	/* ethernet headers are always exactly 14 bytes [1] */
	#define SIZE_ETHERNET 14

	/* Ethernet addresses are 6 bytes */
	#define ETHER_ADDR_LEN	6

	/* Ethernet header */
	struct sniff_ethernet {
			u_char  ether_dhost[ETHER_ADDR_LEN];    /* destination host address */
			u_char  ether_shost[ETHER_ADDR_LEN];    /* source host address */
			u_short ether_type;                     /* IP? ARP? RARP? etc */
	};

	/* IP header */
	struct sniff_ip {
			u_char  ip_vhl;                 /* version << 4 | header length >> 2 */
			u_char  ip_tos;                 /* type of service */
			u_short ip_len;                 /* total length */
			u_short ip_id;                  /* identification */
			u_short ip_off;                 /* fragment offset field */
			#define IP_RF 0x8000            /* reserved fragment flag */
			#define IP_DF 0x4000            /* dont fragment flag */
			#define IP_MF 0x2000            /* more fragments flag */
			#define IP_OFFMASK 0x1fff       /* mask for fragmenting bits */
			u_char  ip_ttl;                 /* time to live */
			u_char  ip_p;                   /* protocol */
			u_short ip_sum;                 /* checksum */
			struct  in_addr ip_src,ip_dst;  /* source and dest address */
	};
	#define IP_HL(ip)               (((ip)->ip_vhl) & 0x0f)
	#define IP_V(ip)                (((ip)->ip_vhl) >> 4)

	/* TCP header */
	typedef u_int tcp_seq;

	struct sniff_tcp {
			u_short th_sport;               /* source port */
			u_short th_dport;               /* destination port */
			tcp_seq th_seq;                 /* sequence number */
			tcp_seq th_ack;                 /* acknowledgement number */
			u_char  th_offx2;               /* data offset, rsvd */
	#define TH_OFF(th)      (((th)->th_offx2 & 0xf0) >> 4)
			u_char  th_flags;
			#define TH_FIN  0x01
			#define TH_SYN  0x02
			#define TH_RST  0x04
			#define TH_PUSH 0x08
			#define TH_ACK  0x10
			#define TH_URG  0x20
			#define TH_ECE  0x40
			#define TH_CWR  0x80
			#define TH_FLAGS        (TH_FIN|TH_SYN|TH_RST|TH_ACK|TH_URG|TH_ECE|TH_CWR)
			u_short th_win;                 /* window */
			u_short th_sum;                 /* checksum */
			u_short th_urp;                 /* urgent pointer */
	};

	void
	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);

	void
	print_payload(const u_char *payload, int len);

	void
	print_hex_ascii_line(const u_char *payload, int len, int offset);

	void
	print_app_banner(void);

	void
	print_app_usage(void);

	/*
	 * app name/banner
	 */
	void
	print_app_banner(void)
	{

		printf(""%s - %s\n"", APP_NAME, APP_DESC);
		printf(""%s\n"", APP_COPYRIGHT);
		printf(""%s\n"", APP_DISCLAIMER);
		printf(""\n"");

	return;
	}

	/*
	 * print help text
	 */
	void
	print_app_usage(void)
	{

		printf(""Usage: %s [interface]\n"", APP_NAME);
		printf(""\n"");
		printf(""Options:\n"");
		printf(""    interface    Listen on <interface> for packets.\n"");
		printf(""\n"");

	return;
	}

	/*
	 * print data in rows of 16 bytes: offset   hex   ascii
	 *
	 * 00000   47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0d 0a   GET / HTTP/1.1..
	 */
	void
	print_hex_ascii_line(const u_char *payload, int len, int offset)
	{

		int i;
		int gap;
		const u_char *ch;

		/* offset */
		printf(""%05d   "", offset);
	
		/* hex */
		ch = payload;
		for(i = 0; i < len; i++) {
			printf(""%02x "", *ch);
			ch++;
			/* print extra space after 8th byte for visual aid */
			if (i == 7)
				printf("" "");
		}
		/* print space to handle line less than 8 bytes */
		if (len < 8)
			printf("" "");
	
		/* fill hex gap with spaces if not full line */
		if (len < 16) {
			gap = 16 - len;
			for (i = 0; i < gap; i++) {
				printf(""   "");
			}
		}
		printf(""   "");
	
		/* ascii (if printable) */
		ch = payload;
		for(i = 0; i < len; i++) {
			if (isprint(*ch))
				printf(""%c"", *ch);
			else
				printf(""."");
			ch++;
		}

		printf(""\n"");

	return;
	}

	/*
	 * print packet payload data (avoid printing binary data)
	 */
	void
	print_payload(const u_char *payload, int len)
	{

		int len_rem = len;
		int line_width = 16;			/* number of bytes per line */
		int line_len;
		int offset = 0;					/* zero-based offset counter */
		const u_char *ch = payload;

		if (len <= 0)
			return;

		/* data fits on one line */
		if (len <= line_width) {
			print_hex_ascii_line(ch, len, offset);
			return;
		}

		/* data spans multiple lines */
		for ( ;; ) {
			/* compute current line length */
			line_len = line_width % len_rem;
			/* print line */
			print_hex_ascii_line(ch, line_len, offset);
			/* compute total remaining */
			len_rem = len_rem - line_len;
			/* shift pointer to remaining bytes to print */
			ch = ch + line_len;
			/* add offset */
			offset = offset + line_width;
			/* check if we have line width chars or less */
			if (len_rem <= line_width) {
				/* print last line and get out */
				print_hex_ascii_line(ch, len_rem, offset);
				break;
			}
		}

	return;
	}

	/*
	 * dissect/print packet
	 */
	void
	got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet)
	{

		static int count = 1;                   /* packet counter */
	
		/* declare pointers to packet headers */
		const struct sniff_ethernet *ethernet;  /* The ethernet header [1] */
		const struct sniff_ip *ip;              /* The IP header */
		const struct sniff_tcp *tcp;            /* The TCP header */
		const char *payload;                    /* Packet payload */

		int size_ip;
		int size_tcp;
		int size_payload;
	
		printf(""\nPacket number %d:\n"", count);
		count++;
	
		/* define ethernet header */
		ethernet = (struct sniff_ethernet*)(packet);
	
		/* define/compute ip header offset */
		ip = (struct sniff_ip*)(packet + SIZE_ETHERNET);
		size_ip = IP_HL(ip)*4;
		if (size_ip < 20) {
			printf(""   * Invalid IP header length: %u bytes\n"", size_ip);
			return;
		}

		/* print source and destination IP addresses */
		printf(""       From: %s\n"", inet_ntoa(ip->ip_src));
		printf(""         To: %s\n"", inet_ntoa(ip->ip_dst));
	
		/* determine protocol */	
		switch(ip->ip_p) {
			case IPPROTO_TCP:
				printf(""   Protocol: TCP\n"");
				break;
			case IPPROTO_UDP:
				printf(""   Protocol: UDP\n"");
				return;
			case IPPROTO_ICMP:
				printf(""   Protocol: ICMP\n"");
				return;
			case IPPROTO_IP:
				printf(""   Protocol: IP\n"");
				return;
			default:
				printf(""   Protocol: unknown\n"");
				return;
		}
	
		/*
		 *  OK, this packet is TCP.
		 */
	
		/* define/compute tcp header offset */
		tcp = (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip);
		size_tcp = TH_OFF(tcp)*4;
		if (size_tcp < 20) {
			printf(""   * Invalid TCP header length: %u bytes\n"", size_tcp);
			return;
		}
	
		printf(""   Src port: %d\n"", ntohs(tcp->th_sport));
		printf(""   Dst port: %d\n"", ntohs(tcp->th_dport));
	
		/* define/compute tcp payload (segment) offset */
		payload = (u_char *)(packet + SIZE_ETHERNET + size_ip + size_tcp);
	
		/* compute tcp payload (segment) size */
		size_payload = ntohs(ip->ip_len) - (size_ip + size_tcp);
	
		/*
		 * Print payload data; it might be binary, so don't just
		 * treat it as a string.
		 */
		if (size_payload > 0) {
			printf(""   Payload (%d bytes):\n"", size_payload);
			print_payload(payload, size_payload);
		}

	return;
	}

	int main(int argc, char **argv)
	{

		char *dev = NULL;			/* capture device name */
		char errbuf[PCAP_ERRBUF_SIZE];		/* error buffer */
		pcap_t *handle;				/* packet capture handle */

		char filter_exp[] = ""ip"";		/* filter expression [3] */
		struct bpf_program fp;			/* compiled filter program (expression) */
		bpf_u_int32 mask;			/* subnet mask */
		bpf_u_int32 net;			/* ip */
		int num_packets = 10;			/* number of packets to capture */

		print_app_banner();

		/* check for capture device name on command-line */
		if (argc == 2) {
			dev = argv[1];
		}
		else if (argc > 2) {
			fprintf(stderr, ""error: unrecognized command-line options\n\n"");
			print_app_usage();
			exit(EXIT_FAILURE);
		}
		else {
			/* find a capture device if not specified on command-line */
			dev = pcap_lookupdev(errbuf);
			if (dev == NULL) {
				fprintf(stderr, ""Couldn't find default device: %s\n"",
					errbuf);
				exit(EXIT_FAILURE);
			}
		}
	
		/* get network number and mask associated with capture device */
		if (pcap_lookupnet(dev, &net, &mask, errbuf) == -1) {
			fprintf(stderr, ""Couldn't get netmask for device %s: %s\n"",
				dev, errbuf);
			net = 0;
			mask = 0;
		}

		/* print capture info */
		printf(""Device: %s\n"", dev);
		printf(""Number of packets: %d\n"", num_packets);
		printf(""Filter expression: %s\n"", filter_exp);

		/* open capture device */
		handle = pcap_open_live(dev, SNAP_LEN, 1, 1000, errbuf);
		if (handle == NULL) {
			fprintf(stderr, ""Couldn't open device %s: %s\n"", dev, errbuf);
			exit(EXIT_FAILURE);
		}

		/* make sure we're capturing on an Ethernet device [2] */
		if (pcap_datalink(handle) != DLT_EN10MB) {
			fprintf(stderr, ""%s is not an Ethernet\n"", dev);
			exit(EXIT_FAILURE);
		}

		/* compile the filter expression */
		if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {
			fprintf(stderr, ""Couldn't parse filter %s: %s\n"",
				filter_exp, pcap_geterr(handle));
			exit(EXIT_FAILURE);
		}

		/* apply the compiled filter */
		if (pcap_setfilter(handle, &fp) == -1) {
			fprintf(stderr, ""Couldn't install filter %s: %s\n"",
				filter_exp, pcap_geterr(handle));
			exit(EXIT_FAILURE);
		}

		/* now we can set our callback function */
		pcap_loop(handle, num_packets, got_packet, NULL);

		/* cleanup */
		pcap_freecode(&fp);
		pcap_close(handle);

		printf(""\nCapture complete.\n"");

	return 0;
	}

Questions: 

    (struct sniff_ethernet*)(packet) // <== A char casted to a struct = a struct with valid data?
    (struct sniff_tcp*)(packet + SIZE_ETHERNET + size_ip); // <== A char plus a couple ints casted to a struct = a struct with valid data?

",4
3219771,07/10/2010 15:24:52,252929,01/18/2010 05:21:54,159,3,Pointer help in C/C++,      I want to know about the pointer in C and C++ that how does it help in saving the memory. I searched it but did not get the satisfactory answer.Please help me out.,c,pointer,in,,,07/10/2010 19:31:14,not a real question,1,39,4,Pointer help in C/C++       I want to know about the pointer in C and C++ that how does it help in saving the memory. I searched it but did not get the satisfactory answer.Please help me out.,3
8662917,12/29/2011 00:41:22,1048116,11/15/2011 17:32:53,98,0,C - Array of Char Arrays,"Im trying to work with the example in the K and R book for this topic, but struggling.

I want an array of Char Arrays, whereby each element of the 'Father' Array points to an array of characters (string). Basically, I am reading from a file, line at a time, storing each line into an array, and then trying to store that array, into another array, which I can then sort via qsort.

But I can't seem to get anywhere with this! Anyhelp on my code is much appreciated, i.e. where to go from where I am!

EDIT: The problem is, the printing function isn't printing out my words that should be within the array of arrays, instead its just printing garbage, the main problem is, I'm not sure whether i am de-referencing things correctly, or not at all, whether I am adding it to the array of arrays correctly etc.

Regards.

    #define MAXLINES 5000 /* max no. lines to be stored */
    #define MAXLEN 1000 /* max length of single line */

    char *lineptr[MAXLINES];

    void writelines(char *lineptr[], int nlines);

    int main(int argc, char *argv[]) {
     int nlines = 0, i, j, k;
     char line[MAXLEN];
     FILE *fpIn;
     fpIn = fopen(argv[1], ""rb"");
     while((fgets(line, 65, fpIn)) != NULL) {
         j = strlen(line);
         if (j > 0 && (line[j-1] == '\n')) {
             line[j-1] = '\0';
         }
         if (j > 8) {
             lineptr[nlines++] = line;
         }
     }  
     for(i = 0; i < nlines; i++)
         printf(""%s\n"", lineptr[i] );
    return 0;    
    }",c,arrays,pointers,io,fopen,,open,0,369,6,"C - Array of Char Arrays Im trying to work with the example in the K and R book for this topic, but struggling.

I want an array of Char Arrays, whereby each element of the 'Father' Array points to an array of characters (string). Basically, I am reading from a file, line at a time, storing each line into an array, and then trying to store that array, into another array, which I can then sort via qsort.

But I can't seem to get anywhere with this! Anyhelp on my code is much appreciated, i.e. where to go from where I am!

EDIT: The problem is, the printing function isn't printing out my words that should be within the array of arrays, instead its just printing garbage, the main problem is, I'm not sure whether i am de-referencing things correctly, or not at all, whether I am adding it to the array of arrays correctly etc.

Regards.

    #define MAXLINES 5000 /* max no. lines to be stored */
    #define MAXLEN 1000 /* max length of single line */

    char *lineptr[MAXLINES];

    void writelines(char *lineptr[], int nlines);

    int main(int argc, char *argv[]) {
     int nlines = 0, i, j, k;
     char line[MAXLEN];
     FILE *fpIn;
     fpIn = fopen(argv[1], ""rb"");
     while((fgets(line, 65, fpIn)) != NULL) {
         j = strlen(line);
         if (j > 0 && (line[j-1] == '\n')) {
             line[j-1] = '\0';
         }
         if (j > 8) {
             lineptr[nlines++] = line;
         }
     }  
     for(i = 0; i < nlines; i++)
         printf(""%s\n"", lineptr[i] );
    return 0;    
    }",5
59597,09/12/2008 17:41:14,2399,08/22/2008 01:36:28,335,1,what is the best definition for main() in c,"what is the best definition for main().<br>
what do other programming languages use for start of program. is there any other keyword in other programming languages<br>
c uses main()<br>
java uses main()<br>
",c,main,,,,07/12/2011 14:57:11,not constructive,1,29,9,"what is the best definition for main() in c what is the best definition for main().<br>
what do other programming languages use for start of program. is there any other keyword in other programming languages<br>
c uses main()<br>
java uses main()<br>
",2
10036381,04/05/2012 21:36:57,1316302,04/05/2012 21:12:05,1,0,Arrow Operator vs. Dot Operator,"It seems to me that C's arrow operator (->) is unnecessary. The dot operator (.) should be sufficient. Take the following code:

    typedef struct {
        int member;
    } my_type;

    my_type   foo;
    my_type * bar;
    int       val;

    val = foo.member;
    val = bar->member;

We see that the arrow operator must be used to dereference bar. However, I would prefer to write

    val = bar.member;

There is no ambiguity as to whether I am trying to pull 'member' from a structure or from a pointer to the structure. But it is easy to use the wrong operator, especially when refactoring code. (For example, maybe I am doing some complex operations on foo, so I move the code into a new function and pass a pointer to foo). I don't think I need to care whether foo is a pointer or not; the compiler can worry about the details.

So the question: wouldn't it be simpler to eliminate -> from the C language?",c,pointers,structures,,,04/05/2012 21:43:38,not constructive,1,196,5,"Arrow Operator vs. Dot Operator It seems to me that C's arrow operator (->) is unnecessary. The dot operator (.) should be sufficient. Take the following code:

    typedef struct {
        int member;
    } my_type;

    my_type   foo;
    my_type * bar;
    int       val;

    val = foo.member;
    val = bar->member;

We see that the arrow operator must be used to dereference bar. However, I would prefer to write

    val = bar.member;

There is no ambiguity as to whether I am trying to pull 'member' from a structure or from a pointer to the structure. But it is easy to use the wrong operator, especially when refactoring code. (For example, maybe I am doing some complex operations on foo, so I move the code into a new function and pass a pointer to foo). I don't think I need to care whether foo is a pointer or not; the compiler can worry about the details.

So the question: wouldn't it be simpler to eliminate -> from the C language?",3
1935546,12/20/2009 11:19:48,11567,09/16/2008 09:12:06,328,39,What are the main C / C++ specifications,"Many post refer to *C89*, *C99*, etc. I was surprised to see that there were no wiki repository for the C/C++ programmer to follow and learn about them at SO.

I'd invite everyone to build, then edit, one big post with the dates/sites links, summary of differences to previous spec, etc. It would be excellent to have a list of compilers and the standard it follows, with notable exceptions, if any.

If you feel the question could be ampler/broader, and include platforms, I think that deserves another wiki post (but I'm not doing that one), as this is already non-programming in a code-listing sense, and I hate poll-Qs on SO (unless featuring humour, w/ or wo/ John Skeet).",c,c++,standards,language-specification,wiki,12/20/2009 13:26:50,not a real question,1,116,8,"What are the main C / C++ specifications Many post refer to *C89*, *C99*, etc. I was surprised to see that there were no wiki repository for the C/C++ programmer to follow and learn about them at SO.

I'd invite everyone to build, then edit, one big post with the dates/sites links, summary of differences to previous spec, etc. It would be excellent to have a list of compilers and the standard it follows, with notable exceptions, if any.

If you feel the question could be ampler/broader, and include platforms, I think that deserves another wiki post (but I'm not doing that one), as this is already non-programming in a code-listing sense, and I hate poll-Qs on SO (unless featuring humour, w/ or wo/ John Skeet).",5
10200471,04/17/2012 23:04:50,1232870,02/25/2012 18:07:01,9,0,Thread safe unique transaction ID,"Thank you all for helping me, I'm sharing the below code as it can provide 4 byte transaction/session ID that is thread safe, or at least I think it is :). it will provide very decent amount of unique IDs for 16 threads / 16 processes. 
the below is basic test for the function, p_no is the process number.

    int get_id(int choice, unsigned int pid);
    	int start_(int id);
    	void *print_message_function( void *ptr );
    	void *print_message_function2( void *ptr );
    	 
    	  unsigned int pid_arr[15][2];
    	int p_no = 1;
    	int main()
    	{
    	     pthread_t thread1, thread2;
    	     char *message1 = ""Thread 1"";
    	     char *message2 = ""Thread 2"";    
    	     int  iret1, iret2;
    	int s,f;
    		for (s=0;s<15;s++)
    		{
    		for (f=0;f<2;f++)
    		pid_arr[s][f]= 0;
    
    		}
    
    	     iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1);
    	     iret2 = pthread_create( &thread2, NULL, print_message_function2, (void*) message2);
    
    	     pthread_join( thread1, NULL);
    	     pthread_join( thread2, NULL); 
    	     exit(0);
    	}
    
    	void *print_message_function( void *ptr )
    	{
    	int one=0;
    
    	get_id(1/*register*/,(unsigned int)pthread_self());
    	while (1)
    	{
    
    	int ret = get_id(0,(unsigned int)pthread_self());
    	printf(""thread 1 = %u\n"",ret);
    	sleep(1);
    	}
    
    	}
    	void *print_message_function2( void *ptr )
    	{
    	int one=0;
    
    	get_id(1/*register*/,(unsigned int)pthread_self());
    
    	while (1)
    	{
    
    	int ret = get_id(0,(unsigned int)pthread_self());
    	printf(""thread 2 = %u\n"",ret);
    	sleep(1);
    	}
    
    	}
    
    
    	int get_id(int choice, unsigned int pid)
    	{
    	int x;
    
    
    	   if (choice==1) // thread registeration part 
    	    {
    	       for(x=0;x<15;x++)
    		{
    		    if (pid_arr[x][0] == 0) 
    		    {
    		    pid_arr[x][0] = pid;	 
    		   pid_arr[x][1] = ((p_no<<4) | x) << 24;   
    	 
    		   break;
    		    }
    		 }
    
    	    }
    	 
    	int y;
    	       for(y=0;y<15;y++) // tranaction ID part 
    		{
    		   if (pid_arr[y][0]==pid)	
    		    {
    	 
    		     if(pid_arr[y][1] >= ((((p_no<<4) | y) << 24) | 0xfffffd) )
    			((p_no<<4) | x) << 24; 
    		    else 
    			pid_arr[y][1]++;
    		    return (unsigned int) pid_arr[y][1];
    		    break;
    		   }
    		}
    
    	}",c,multithreading,,,,04/19/2012 02:37:03,not a real question,1,711,5,"Thread safe unique transaction ID Thank you all for helping me, I'm sharing the below code as it can provide 4 byte transaction/session ID that is thread safe, or at least I think it is :). it will provide very decent amount of unique IDs for 16 threads / 16 processes. 
the below is basic test for the function, p_no is the process number.

    int get_id(int choice, unsigned int pid);
    	int start_(int id);
    	void *print_message_function( void *ptr );
    	void *print_message_function2( void *ptr );
    	 
    	  unsigned int pid_arr[15][2];
    	int p_no = 1;
    	int main()
    	{
    	     pthread_t thread1, thread2;
    	     char *message1 = ""Thread 1"";
    	     char *message2 = ""Thread 2"";    
    	     int  iret1, iret2;
    	int s,f;
    		for (s=0;s<15;s++)
    		{
    		for (f=0;f<2;f++)
    		pid_arr[s][f]= 0;
    
    		}
    
    	     iret1 = pthread_create( &thread1, NULL, print_message_function, (void*) message1);
    	     iret2 = pthread_create( &thread2, NULL, print_message_function2, (void*) message2);
    
    	     pthread_join( thread1, NULL);
    	     pthread_join( thread2, NULL); 
    	     exit(0);
    	}
    
    	void *print_message_function( void *ptr )
    	{
    	int one=0;
    
    	get_id(1/*register*/,(unsigned int)pthread_self());
    	while (1)
    	{
    
    	int ret = get_id(0,(unsigned int)pthread_self());
    	printf(""thread 1 = %u\n"",ret);
    	sleep(1);
    	}
    
    	}
    	void *print_message_function2( void *ptr )
    	{
    	int one=0;
    
    	get_id(1/*register*/,(unsigned int)pthread_self());
    
    	while (1)
    	{
    
    	int ret = get_id(0,(unsigned int)pthread_self());
    	printf(""thread 2 = %u\n"",ret);
    	sleep(1);
    	}
    
    	}
    
    
    	int get_id(int choice, unsigned int pid)
    	{
    	int x;
    
    
    	   if (choice==1) // thread registeration part 
    	    {
    	       for(x=0;x<15;x++)
    		{
    		    if (pid_arr[x][0] == 0) 
    		    {
    		    pid_arr[x][0] = pid;	 
    		   pid_arr[x][1] = ((p_no<<4) | x) << 24;   
    	 
    		   break;
    		    }
    		 }
    
    	    }
    	 
    	int y;
    	       for(y=0;y<15;y++) // tranaction ID part 
    		{
    		   if (pid_arr[y][0]==pid)	
    		    {
    	 
    		     if(pid_arr[y][1] >= ((((p_no<<4) | y) << 24) | 0xfffffd) )
    			((p_no<<4) | x) << 24; 
    		    else 
    			pid_arr[y][1]++;
    		    return (unsigned int) pid_arr[y][1];
    		    break;
    		   }
    		}
    
    	}",2
7992490,11/03/2011 09:18:48,200404,11/01/2009 07:27:16,1,0,How to judge an overflow when adding signed to unsigned,"I'm trying to detect the overflow when adding a signed offset to an unsigned position

    uint32 position;
    int32 offset;  // it could be negative
    uint32 position = position+offset;

How can I check whether the result is overflow or underflow?

I have thought of an ugly way but not sure of its correctness.

* underflow: `offset < 0 && position + offset >= position`
* overflow: `offset > 0 && position + offset <= position`

And I'm also wondering if there's a more elegant way to do it.",c,overflow,unsigned,signed,underflow,,open,0,92,10,"How to judge an overflow when adding signed to unsigned I'm trying to detect the overflow when adding a signed offset to an unsigned position

    uint32 position;
    int32 offset;  // it could be negative
    uint32 position = position+offset;

How can I check whether the result is overflow or underflow?

I have thought of an ugly way but not sure of its correctness.

* underflow: `offset < 0 && position + offset >= position`
* overflow: `offset > 0 && position + offset <= position`

And I'm also wondering if there's a more elegant way to do it.",5
10719704,05/23/2012 12:15:24,599110,02/01/2011 21:31:26,156,13,C / determine port on which a packet was received,"I have created four sockets with different port configurations. With the `select` function I read from one of the four file descriptors. But how can I find out on which port I received the UDP packet, I do only have the file descriptor, right? Depending on the port I need to process received packets differently. The `recv_from` function fills a `struct sockaddr` from which I can read out the source port of the packet, but not the destination port.

Thanks in advance for your help.",c,sockets,,,,,open,0,84,10,"C / determine port on which a packet was received I have created four sockets with different port configurations. With the `select` function I read from one of the four file descriptors. But how can I find out on which port I received the UDP packet, I do only have the file descriptor, right? Depending on the port I need to process received packets differently. The `recv_from` function fills a `struct sockaddr` from which I can read out the source port of the packet, but not the destination port.

Thanks in advance for your help.",2
854541,05/12/2009 19:51:31,105623,05/12/2009 19:26:03,1,0,Layout of Pixel-data in Memory?,"I'm writing a C++ library for an image format that is based on PNG. One stopping point for me is that I'm unsure as to how I ought to lay out the pixel data in memory; as far as I'm aware, there are two practical approaches:

1. An array of size (width * height); each pixel can be accessed by array[y*width + x].
2. An array of size (height), containing pointers to arrays of size (width).

The standard reference implementation for PNG (libpng) uses method 2 of the above, while I've seen others use method 1. Is one better than the other, or is each a method with its own pros and cons, to where a compromise must be made? Further, which format do most graphical display systems use (perhaps for ease of using the output of my library into other APIs)?",c,c++,image,,,,open,0,139,5,"Layout of Pixel-data in Memory? I'm writing a C++ library for an image format that is based on PNG. One stopping point for me is that I'm unsure as to how I ought to lay out the pixel data in memory; as far as I'm aware, there are two practical approaches:

1. An array of size (width * height); each pixel can be accessed by array[y*width + x].
2. An array of size (height), containing pointers to arrays of size (width).

The standard reference implementation for PNG (libpng) uses method 2 of the above, while I've seen others use method 1. Is one better than the other, or is each a method with its own pros and cons, to where a compromise must be made? Further, which format do most graphical display systems use (perhaps for ease of using the output of my library into other APIs)?",3
11284583,07/01/2012 18:26:28,1254683,03/07/2012 12:37:39,53,1,create my own blob detection in C,"i there guys i doing a little school project and for that i need to detect a white paper sheet, try to see if i can do the blob detection with opencv but opencv its not my area, i want do do my own blob detection for the sheet try to search for examples but i can't find anything.
What i want my blob detector to do is: detect the white paper sheet then give the coordinates of the 4 corners of the sheet, and then draw a polygon over it
the blob detector must detect the white sheet even if is drawings inside the sheet.
Any help could be great just got one week the finish this.",c,computer-science,blobs,,,07/02/2012 09:21:58,not a real question,1,115,7,"create my own blob detection in C i there guys i doing a little school project and for that i need to detect a white paper sheet, try to see if i can do the blob detection with opencv but opencv its not my area, i want do do my own blob detection for the sheet try to search for examples but i can't find anything.
What i want my blob detector to do is: detect the white paper sheet then give the coordinates of the 4 corners of the sheet, and then draw a polygon over it
the blob detector must detect the white sheet even if is drawings inside the sheet.
Any help could be great just got one week the finish this.",3
5465251,03/28/2011 21:24:13,680981,03/28/2011 21:19:17,1,0,How come when i enter gcc -framework foundation files -o progname into gnu shell it says command not found?,can somone figure this out i used a guide and did everthing and it still wont work,c,gcc,gnu,,,03/28/2011 22:57:43,not a real question,1,17,19,How come when i enter gcc -framework foundation files -o progname into gnu shell it says command not found? can somone figure this out i used a guide and did everthing and it still wont work,3
9442729,02/25/2012 09:06:26,1174292,01/27/2012 20:05:16,11,2,Simple stuff for c programmers,"To which of the following is 

    myFunc( int x )

equivalent to?

    a) myFunc( int *x );
    b) myFunc( int x[] );
    c) myFunc( int x[10] );

Please explain your answer..",c,,,,,02/25/2012 11:09:37,not constructive,1,42,5,"Simple stuff for c programmers To which of the following is 

    myFunc( int x )

equivalent to?

    a) myFunc( int *x );
    b) myFunc( int x[] );
    c) myFunc( int x[10] );

Please explain your answer..",1
7380261,09/11/2011 18:10:09,939439,09/11/2011 18:10:09,1,0,How to set a bitmask in C of all 1s from a given lowbit to highbit using only bitwise operators,"The allowed operators are ! ~ & ^ | + << >>. The only data type I'm allowed to use are ints and the only constants I can declare have to be between 0 and 255 inclusive. The function takes in an int lowbit and an int highbit and returns a bitmask with 1s from lowbit to highbit inclusive.

    e.g. bitmask(3,5) = 0x38

I have a pretty good idea how to do it using shift but the problem I'm having is that when lowbit > highbit the function returns a bitmask of all 0's. I have no idea how to do that.",c,homework,bitwise,bitmask,,09/11/2011 18:21:55,too localized,1,104,20,"How to set a bitmask in C of all 1s from a given lowbit to highbit using only bitwise operators The allowed operators are ! ~ & ^ | + << >>. The only data type I'm allowed to use are ints and the only constants I can declare have to be between 0 and 255 inclusive. The function takes in an int lowbit and an int highbit and returns a bitmask with 1s from lowbit to highbit inclusive.

    e.g. bitmask(3,5) = 0x38

I have a pretty good idea how to do it using shift but the problem I'm having is that when lowbit > highbit the function returns a bitmask of all 0's. I have no idea how to do that.",4
6798639,07/23/2011 06:15:34,357538,06/03/2010 13:40:57,99,3,How to block a linux program from being print screened?,"I need to prevent my users from print screening the data that my program displays.
Right now the idea I have is to make it a full screen program, where probably calling any other linux shortcuts or applications is blocked, and the print screen key is blocked.
Is this approach correct?
How would I go about getting this done?",c,linux,printing,screen,x11,07/24/2011 09:25:20,off topic,1,56,10,"How to block a linux program from being print screened? I need to prevent my users from print screening the data that my program displays.
Right now the idea I have is to make it a full screen program, where probably calling any other linux shortcuts or applications is blocked, and the print screen key is blocked.
Is this approach correct?
How would I go about getting this done?",5
5552722,04/05/2011 13:36:56,692977,04/05/2011 13:31:55,1,0,L1 constrained Regression in C,"I need Lasso/L1 constrained Regression Library in C. AFAIK, NAG does not support it. R has a package to do it but I need to do it in C. Any idea?",c,mathematical-optimization,lasso,,,,open,0,31,5,"L1 constrained Regression in C I need Lasso/L1 constrained Regression Library in C. AFAIK, NAG does not support it. R has a package to do it but I need to do it in C. Any idea?",3
11347527,07/05/2012 15:24:49,1351637,04/23/2012 15:04:38,5,1,Matlab MEX C++ two files with same name in different folders,"I'm trying to compile some C++ files that have the same name (fileA) but located in different folders (folder1 and folder2), lets say:
    folder1/fileA.cpp
    folder1/fileB.cpp
    folder2/fileA.cpp
    folder2/fileC.cpp
These files contain different classes.
But mex creates the objects for both fileA in the same folder so when it tries to generate the final W32 file some classes are missing.
Is there any way of telling mex to do not ""flatten"" the folders structure and then not overwriting one fileA.obj with the other fileA.obj?",c,matlab,mex,,,,open,0,91,11,"Matlab MEX C++ two files with same name in different folders I'm trying to compile some C++ files that have the same name (fileA) but located in different folders (folder1 and folder2), lets say:
    folder1/fileA.cpp
    folder1/fileB.cpp
    folder2/fileA.cpp
    folder2/fileC.cpp
These files contain different classes.
But mex creates the objects for both fileA in the same folder so when it tries to generate the final W32 file some classes are missing.
Is there any way of telling mex to do not ""flatten"" the folders structure and then not overwriting one fileA.obj with the other fileA.obj?",3
599365,03/01/2009 06:21:09,56951,01/20/2009 04:37:13,186,22,What is your favorite C programming trick?,"For example, I recently came across this in the linux kernel:
<pre>
/* Force a compilation error if condition is true */
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
</pre>

So, in your code, if you have some structure which must be, say a multiple of 8 bytes in size, maybe because of some hardware constraints, you can do:
<pre>
BUILD_BUG_ON((sizeof(struct mystruct) % 8) != 0);
</pre>
and it won't compile unless the size of struct mystruct is a multiple of 8, and if it is a multiple of 8, no runtime code is generated at all.

Another trick I know is from the book ""Graphics Gems"" which allows a single header file to both declare and initialize variables in one module while in other modules using that module, merely declare them as externs.

<pre>
#ifdef DEFINE_MYHEADER_GLOBALS
#define GLOBAL
#define INIT(x, y) (x) = (y)
#else
#define GLOBAL extern
#define INIT(x, y)
#endif

GLOBAL int INIT(x, 0);
GLOBAL int somefunc(int a, int b);
</pre>
With that, the code which defines x and somefunc does:
<pre>
#define DEFINE_MYHEADER_GLOBALS
#include ""the_above_header_file.h""
</pre>

while code that's merely using x and somefunc() does:
<pre>
#include ""the_above_header_file.h""
</pre>

So you get one header file that declares both instances of globals and function prototypes where they are needed, and the corresponding extern declarations.

So, what are your favorite C programming tricks along those lines?


",c,,,,,10/24/2011 18:24:42,not constructive,1,194,7,"What is your favorite C programming trick? For example, I recently came across this in the linux kernel:
<pre>
/* Force a compilation error if condition is true */
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
</pre>

So, in your code, if you have some structure which must be, say a multiple of 8 bytes in size, maybe because of some hardware constraints, you can do:
<pre>
BUILD_BUG_ON((sizeof(struct mystruct) % 8) != 0);
</pre>
and it won't compile unless the size of struct mystruct is a multiple of 8, and if it is a multiple of 8, no runtime code is generated at all.

Another trick I know is from the book ""Graphics Gems"" which allows a single header file to both declare and initialize variables in one module while in other modules using that module, merely declare them as externs.

<pre>
#ifdef DEFINE_MYHEADER_GLOBALS
#define GLOBAL
#define INIT(x, y) (x) = (y)
#else
#define GLOBAL extern
#define INIT(x, y)
#endif

GLOBAL int INIT(x, 0);
GLOBAL int somefunc(int a, int b);
</pre>
With that, the code which defines x and somefunc does:
<pre>
#define DEFINE_MYHEADER_GLOBALS
#include ""the_above_header_file.h""
</pre>

while code that's merely using x and somefunc() does:
<pre>
#include ""the_above_header_file.h""
</pre>

So you get one header file that declares both instances of globals and function prototypes where they are needed, and the corresponding extern declarations.

So, what are your favorite C programming tricks along those lines?


",1
344317,12/05/2008 16:02:35,1288,08/14/2008 12:14:17,14988,733,Where does gcc look for C and C++ header files?,"On a Unix system, where does gcc look for header files?

I spent a little time this morning looking for some system header files, so I thought this would be good information to have here.",c,c++,header,,,,open,0,34,10,"Where does gcc look for C and C++ header files? On a Unix system, where does gcc look for header files?

I spent a little time this morning looking for some system header files, so I thought this would be good information to have here.",3
4861388,02/01/2011 10:25:36,417552,08/11/2010 17:32:44,507,0,write a program to copy file in C,"I studied about 3 different ways to write a file copy program in the book ""windows system programming"". Those are :

    1. Using the Standard C library
    2. Using Windows
    3. Using a single Windows convenience function ""CopyFile"".


Now I want three more methods to write copy program apart from this. Can anybody provide me guidance?
(operating system : windows; IDE : visual studio)

 ",c,windows,copy,,,02/01/2011 15:23:48,not a real question,1,72,8,"write a program to copy file in C I studied about 3 different ways to write a file copy program in the book ""windows system programming"". Those are :

    1. Using the Standard C library
    2. Using Windows
    3. Using a single Windows convenience function ""CopyFile"".


Now I want three more methods to write copy program apart from this. Can anybody provide me guidance?
(operating system : windows; IDE : visual studio)

 ",3
5315289,03/15/2011 17:06:18,661049,03/15/2011 17:06:18,1,0,header files include conio.h???,why gcc does not include conio.h as a header file,c,,,,,03/15/2011 17:09:25,not a real question,1,10,4,header files include conio.h??? why gcc does not include conio.h as a header file,1
10740143,05/24/2012 15:04:07,1014237,10/26/2011 09:05:09,1427,96,Get current active Window title in C,"I want to write an X-Chat plugin where users will be able to perform a CTCP request to my client, whereby the plugin/X-Chat will respond with my current active window title.

This would be really cool for fellow IRC users to see what I'm up to to allow them to determine what I'm doing if I'm full screen (playing a game, watching a video etc).

Plugins for X-Chat are written in C, so I need a way of determining the current active Window title using Windows API calls from C. Can anyone advise on how this might be done?

Thanks.",c,windows,winapi,,,,open,0,97,7,"Get current active Window title in C I want to write an X-Chat plugin where users will be able to perform a CTCP request to my client, whereby the plugin/X-Chat will respond with my current active window title.

This would be really cool for fellow IRC users to see what I'm up to to allow them to determine what I'm doing if I'm full screen (playing a game, watching a video etc).

Plugins for X-Chat are written in C, so I need a way of determining the current active Window title using Windows API calls from C. Can anyone advise on how this might be done?

Thanks.",3
10316551,04/25/2012 13:19:41,1356252,04/25/2012 12:56:43,1,0,Translating from C to MIPS," I need this translated into MIPS Assembly (to work on Mars Assembler)

    void mm ( double x[][], double y[][], double z[][], int n)
    {
    int i,j;
    for (i=0; i !=n; i++)
    for (j=0; j !=n; j++)
    z[i][j] = 0.0;
    for (k=0; k !=n; k++)
    z[i][j] = z[i][j] + x[i][k] * y[k][j];

",c,,,,,04/25/2012 14:15:16,not a real question,1,76,5,"Translating from C to MIPS  I need this translated into MIPS Assembly (to work on Mars Assembler)

    void mm ( double x[][], double y[][], double z[][], int n)
    {
    int i,j;
    for (i=0; i !=n; i++)
    for (j=0; j !=n; j++)
    z[i][j] = 0.0;
    for (k=0; k !=n; k++)
    z[i][j] = z[i][j] + x[i][k] * y[k][j];

",1
2672986,04/20/2010 06:20:56,319591,04/18/2010 08:17:41,16,1,"C stack/scope, variable's lifetime after functions ends","    void someFunc()
    {
        int stackInt = 4;
    
        someOtherFunc(&stackInt);
    }

Is it the case that stackInt's address space could be reallocated after someFunc ends, making it unsafe to assume that the value passed to someOtherFunc represents the stackInt variable with value 4 that was passed to it? In other words, should I avoid passing stack variables around by address and expecting them to still be alive after the function they were initialised in has ended?",c,stack,,,,,open,0,101,7,"C stack/scope, variable's lifetime after functions ends     void someFunc()
    {
        int stackInt = 4;
    
        someOtherFunc(&stackInt);
    }

Is it the case that stackInt's address space could be reallocated after someFunc ends, making it unsafe to assume that the value passed to someOtherFunc represents the stackInt variable with value 4 that was passed to it? In other words, should I avoid passing stack variables around by address and expecting them to still be alive after the function they were initialised in has ended?",2
1215236,07/31/2009 22:43:20,44084,12/07/2008 12:12:53,8161,248,C#: Order of function evaluation (vs C),"Take the following C code (*K&R pg. 77*) : 

    push(pop() - pop()); /* WRONG */

The book says that since `-` and `/` are not commutative operators, the order in which the 2 `pop` functions are evaluated is necessary (obviously, to get the correct result)...and thus you have to put the result of the first function in a variable first and then proceed with the arithmetic, like such:

    op2 = pop();
    push(op2 - pop());

Apparently this is because the compiler can't guarantee in which order the functions are evaluated (...why?) 

----------

My question is, does C# do this same thing?  as in, do I have to worry about this sort of thing when working with C# ? and for that matter, any of the other higher level languages ?

",c,c#,function-evaluation,c-vs-c#,math,,open,0,137,7,"C#: Order of function evaluation (vs C) Take the following C code (*K&R pg. 77*) : 

    push(pop() - pop()); /* WRONG */

The book says that since `-` and `/` are not commutative operators, the order in which the 2 `pop` functions are evaluated is necessary (obviously, to get the correct result)...and thus you have to put the result of the first function in a variable first and then proceed with the arithmetic, like such:

    op2 = pop();
    push(op2 - pop());

Apparently this is because the compiler can't guarantee in which order the functions are evaluated (...why?) 

----------

My question is, does C# do this same thing?  as in, do I have to worry about this sort of thing when working with C# ? and for that matter, any of the other higher level languages ?

",5
6092317,05/23/2011 02:35:03,765298,05/23/2011 01:17:55,1,0,Using ncurses menu.h on Solaris 5.9 / C,"I have a problem with using curses menu.h on Solaris 5.9 - this code generates a segfault :
    
    item_sub = (ITEM**)calloc(5, sizeof(ITEM*));
    item_sub[0] = new_item(""[DODAJ]"", """");
    item_sub[1] = new_item(""[ZAPISZ]"", """");
    item_sub[2] = new_item(""[OTWORZ]"", """");
    item_sub[3] = new_item(""[SZUKAJ]"", """");
    item_sub[4] = NULL;
    menu_subK = new_menu((ITEM**)item_sub);
    set_menu_format(menu_subK, 1, 4);
    set_menu_win(menu_subK, wKontakt);
    set_menu_sub(menu_subK, derwin(wKontakt, 1, 39, LINES - 4, 1));
    set_menu_mark(menu_subK, """");
    menu_opts_off(menu_subK, O_NONCYCLIC);
    menu_opts_off(menu_subK, O_SHOWDESC);
    post_menu(menu_subK);

The error happens on `post_menu(menu_subK);`
Whole code is after `initscr();` and my compile command looks like that :

`gcc -pedantic organizerC.c kontaktyC.c wydarzeniaC.c dodatkiC.c -lmenu -lform -lncurses -o organizerC`

The error occurs also when I compile with `-lcurses`.

Everything works on my Ubuntu 10, but unfortunately it has to work on aforementioned Solaris 5.9, as this is a requirement for all my class projects.
I've tried google'ing about it but didn't get anywhere. I've checked contents of menu.h and it has `#include <curses.h>` but as I understood from my findings this should link to ncurses.h, right? I've also tried adding explicitly `#include <ncurses.h>`, `#include <ncurses/ncurses.h>` and other variations with `curses.h` with no luck...

Are there Solaris-specific functions I need to use? Or should I change my compile command? Any help and/or directions of research is appreciated.",c,solaris,ncurses,,,,open,0,239,8,"Using ncurses menu.h on Solaris 5.9 / C I have a problem with using curses menu.h on Solaris 5.9 - this code generates a segfault :
    
    item_sub = (ITEM**)calloc(5, sizeof(ITEM*));
    item_sub[0] = new_item(""[DODAJ]"", """");
    item_sub[1] = new_item(""[ZAPISZ]"", """");
    item_sub[2] = new_item(""[OTWORZ]"", """");
    item_sub[3] = new_item(""[SZUKAJ]"", """");
    item_sub[4] = NULL;
    menu_subK = new_menu((ITEM**)item_sub);
    set_menu_format(menu_subK, 1, 4);
    set_menu_win(menu_subK, wKontakt);
    set_menu_sub(menu_subK, derwin(wKontakt, 1, 39, LINES - 4, 1));
    set_menu_mark(menu_subK, """");
    menu_opts_off(menu_subK, O_NONCYCLIC);
    menu_opts_off(menu_subK, O_SHOWDESC);
    post_menu(menu_subK);

The error happens on `post_menu(menu_subK);`
Whole code is after `initscr();` and my compile command looks like that :

`gcc -pedantic organizerC.c kontaktyC.c wydarzeniaC.c dodatkiC.c -lmenu -lform -lncurses -o organizerC`

The error occurs also when I compile with `-lcurses`.

Everything works on my Ubuntu 10, but unfortunately it has to work on aforementioned Solaris 5.9, as this is a requirement for all my class projects.
I've tried google'ing about it but didn't get anywhere. I've checked contents of menu.h and it has `#include <curses.h>` but as I understood from my findings this should link to ncurses.h, right? I've also tried adding explicitly `#include <ncurses.h>`, `#include <ncurses/ncurses.h>` and other variations with `curses.h` with no luck...

Are there Solaris-specific functions I need to use? Or should I change my compile command? Any help and/or directions of research is appreciated.",3
8324540,11/30/2011 10:36:28,1073087,11/30/2011 10:06:25,1,0,want to know about informative website or material on ALGORITHMS related topics,"with the prob. & suggested solution?
such as: for various/graph network based problems, comparison advanced sorting algorithm, dynamic algorithm for various problems and optimised bs trees & their implementation for solving various problems..
",c,algorithm,search,dictionary,pseudocode,11/30/2011 14:46:19,not a real question,1,32,12,"want to know about informative website or material on ALGORITHMS related topics with the prob. & suggested solution?
such as: for various/graph network based problems, comparison advanced sorting algorithm, dynamic algorithm for various problems and optimised bs trees & their implementation for solving various problems..
",5
4216070,11/18/2010 14:55:35,512270,11/18/2010 14:55:35,1,0,Have more than one timer,I want to have more then two timers. Each timer has it's own precision. I have red that i can just have one timer. Is there any ways to have more than one?,c,,,,,11/18/2010 20:52:07,not a real question,1,33,5,Have more than one timer I want to have more then two timers. Each timer has it's own precision. I have red that i can just have one timer. Is there any ways to have more than one?,1
8915061,01/18/2012 18:05:40,621510,02/17/2011 13:57:37,128,0,Include Guards syntax in C,"Hello every one I want to ask a question about include guards in C programming.I know there purpose but in some codes I have seen ""1"" written after #define  like

    #ifndef MYFILE_H
    #define MYFILE_H 1

What is the purpose of this ""1"" ? Is it necessary ?
Thanks ",c,include,,,,,open,0,54,5,"Include Guards syntax in C Hello every one I want to ask a question about include guards in C programming.I know there purpose but in some codes I have seen ""1"" written after #define  like

    #ifndef MYFILE_H
    #define MYFILE_H 1

What is the purpose of this ""1"" ? Is it necessary ?
Thanks ",2
7772264,10/14/2011 18:57:08,499439,11/06/2010 20:17:28,522,4,Must read books for programming cryptography C applications?,"Which books are really MUST read for a person who attempts to create a critical parts of application(s) in security field, e.g. driver which are dealing with coding/decoding, firewall, kernel subsystem which rely on checking of rights/policies, a secure mail client, etc.

Are there any specific books covering applied C programming topics in field like this? Like how to design/write secure code, what are the common attacks your program must be resistant to and the like?   ",c,security,,,,10/15/2011 01:00:08,not constructive,1,78,8,"Must read books for programming cryptography C applications? Which books are really MUST read for a person who attempts to create a critical parts of application(s) in security field, e.g. driver which are dealing with coding/decoding, firewall, kernel subsystem which rely on checking of rights/policies, a secure mail client, etc.

Are there any specific books covering applied C programming topics in field like this? Like how to design/write secure code, what are the common attacks your program must be resistant to and the like?   ",2
9073044,01/31/2012 00:54:23,1044137,11/13/2011 12:09:20,329,0,Converting executable to code,I know this question may be weird. But I just want to know whether it is possible for any executable (.exe or a.out) to be converted back to source code ? Is there any tool ? If no then please ignore the question .  ,c,debugging,unix,operating-system,,01/31/2012 20:27:32,not constructive,1,46,4,Converting executable to code I know this question may be weird. But I just want to know whether it is possible for any executable (.exe or a.out) to be converted back to source code ? Is there any tool ? If no then please ignore the question .  ,4
10020475,04/04/2012 23:00:57,773578,05/27/2011 18:23:23,158,0,Correct naming convention for C library code,What is the correct way to name files and methods that are part of a C based code library/API?,c,source-code,standards,,,04/04/2012 23:17:43,not a real question,1,19,7,Correct naming convention for C library code What is the correct way to name files and methods that are part of a C based code library/API?,3
142261,09/26/2008 22:03:06,15721,09/17/2008 12:11:54,23,1,mangling __FILE__ and __LINE__ in code for quoting?,"Is there a way to get the C/C++ preprocessor or a template or such to mangle/hash the __FILE__ and __LINE__ and perhaps some other external input like a build-number into a single short number that can be quoted in logs or error messages?

(The intention would be to be able to reverse it (to a list of candidates if its lossy) when needed when a customer quotes it in a bug report.)",c,preprocessor,templates,,,,open,0,71,8,"mangling __FILE__ and __LINE__ in code for quoting? Is there a way to get the C/C++ preprocessor or a template or such to mangle/hash the __FILE__ and __LINE__ and perhaps some other external input like a build-number into a single short number that can be quoted in logs or error messages?

(The intention would be to be able to reverse it (to a list of candidates if its lossy) when needed when a customer quotes it in a bug report.)",3
6948149,08/04/2011 20:31:12,878821,08/04/2011 14:45:16,1,0,Remote shell in C,I have no idea why my previous question was closed for being too localized. What is so localized about making a remote shell? It allows managing of a remote computer through the command prompt using the winsock socket interface. Don't really know how to make that.,c,winsock,,,,08/04/2011 21:00:15,not constructive,1,46,4,Remote shell in C I have no idea why my previous question was closed for being too localized. What is so localized about making a remote shell? It allows managing of a remote computer through the command prompt using the winsock socket interface. Don't really know how to make that.,2
3193996,07/07/2010 10:51:48,65736,02/12/2009 20:22:29,2044,92,Emulating/faking filesystem for testing C code?,"I'm looking for the cross-platform way to test some features in my application which required access to the filesystem (to write and read binary data). In the real life my application running on Linux and store special data in `/usr/local/etc` directory. But main part of the application is cross-platform library and it should be tested both on Windows and Linux. Furthermore, I don't want for my tests to write/read data directly to `/usr/local/etc` because in that case it will break test isolation.

So I'm thinking about replacing real access to the filesystem with special emulator of filesystem. Thus every test which required access to the filesystem can create new instance of vistual filesystem object and I can run tests in isolation, and properly support testing on Windows.

I've tried to find some existing open/free implementation, but so far found none for C code. Any hints?",c,unit-testing,cross-platform,filesystems,,,open,0,143,6,"Emulating/faking filesystem for testing C code? I'm looking for the cross-platform way to test some features in my application which required access to the filesystem (to write and read binary data). In the real life my application running on Linux and store special data in `/usr/local/etc` directory. But main part of the application is cross-platform library and it should be tested both on Windows and Linux. Furthermore, I don't want for my tests to write/read data directly to `/usr/local/etc` because in that case it will break test isolation.

So I'm thinking about replacing real access to the filesystem with special emulator of filesystem. Thus every test which required access to the filesystem can create new instance of vistual filesystem object and I can run tests in isolation, and properly support testing on Windows.

I've tried to find some existing open/free implementation, but so far found none for C code. Any hints?",4
7493253,09/21/2011 00:12:19,939103,09/11/2011 11:28:06,1,0,how to generate obfuscated-code,"for example consider the following code:

calll far ptr 90b6h:79c35c2eh

shl dword ptr [ebp+0fh],1

db 67h

daa

push eax

push cs

How this code-block  is generated for example in C programming?
How can I deobfuscate that code?


I want some practical example or a good reference about that

Regards











",c,obfuscation,deobfuscation,,,09/21/2011 17:33:55,not a real question,1,40,4,"how to generate obfuscated-code for example consider the following code:

calll far ptr 90b6h:79c35c2eh

shl dword ptr [ebp+0fh],1

db 67h

daa

push eax

push cs

How this code-block  is generated for example in C programming?
How can I deobfuscate that code?


I want some practical example or a good reference about that

Regards











",3
9713254,03/15/2012 02:37:30,680441,03/28/2011 14:55:31,1045,25,C Structs in Arrays,"Assume I have an array which holds some struct defined as follows:

`static struct s x[10]`

Is each element in the array initialized or are they all empty slots?

In another words, what happens if I do:

    struct s {
       struct s *next;
    };
    
    struct s a;
    a->next = &z[0];
    z[0].next = &[z1];

Would `a`'s next point to `z[0]` and `z[0]`'s next point to `[z1]`?",c,arrays,pointers,struct,,,open,0,86,4,"C Structs in Arrays Assume I have an array which holds some struct defined as follows:

`static struct s x[10]`

Is each element in the array initialized or are they all empty slots?

In another words, what happens if I do:

    struct s {
       struct s *next;
    };
    
    struct s a;
    a->next = &z[0];
    z[0].next = &[z1];

Would `a`'s next point to `z[0]` and `z[0]`'s next point to `[z1]`?",4
6479661,06/25/2011 18:15:22,774469,05/28/2011 15:58:55,1,0,Running executable in C code,"I am writing in C (not C++) on a Mac. I want to be able to run a UNIX executable from C, something like this:

    #include <some-wacky-header.h>

    int main (int argc, char * argv[])
    {
        int r = some_wacky_executable_run(path_to_my_file_as_char_array);
        return 0;
    }

NOTE: I don't want to use the `system()` command to run the executable.",c,osx,run,,,06/27/2011 17:57:30,not a real question,1,80,5,"Running executable in C code I am writing in C (not C++) on a Mac. I want to be able to run a UNIX executable from C, something like this:

    #include <some-wacky-header.h>

    int main (int argc, char * argv[])
    {
        int r = some_wacky_executable_run(path_to_my_file_as_char_array);
        return 0;
    }

NOTE: I don't want to use the `system()` command to run the executable.",3
6555413,07/02/2011 06:12:09,825777,07/02/2011 05:03:49,1,0,new to using classes in C,"# include <stdio.h>

int main(void) {

int numStudents;
int i = 0 ;
int sum;

printf(""How many students are in your class? \n"");
scanf(""%d"", &numStudents);

int grade[numStudents];


while ( i < numStudents ){
      scanf(""%d"", &grade[i]);
      printf(""\n"");
      i++;
      }

average(int grade[numStudents]);
printf(""%d"", &sum);     
    
}


int average(int x[y]){
    int sum;
    
    for (a=0; a<=y ;a++){
    sum = sum + x[a];
    }
    
    sum = sum / y;
    return sum;
}
",c,,,,,07/02/2011 06:49:55,not a real question,1,108,6,"new to using classes in C # include <stdio.h>

int main(void) {

int numStudents;
int i = 0 ;
int sum;

printf(""How many students are in your class? \n"");
scanf(""%d"", &numStudents);

int grade[numStudents];


while ( i < numStudents ){
      scanf(""%d"", &grade[i]);
      printf(""\n"");
      i++;
      }

average(int grade[numStudents]);
printf(""%d"", &sum);     
    
}


int average(int x[y]){
    int sum;
    
    for (a=0; a<=y ;a++){
    sum = sum + x[a];
    }
    
    sum = sum / y;
    return sum;
}
",1
11385639,07/08/2012 18:38:32,1510398,02/05/2010 12:44:58,37,0,calculating elapsed time in vb.net,"    `main()
    {
    clock_t start, end;
    double elapsed;

    start = clock();

     /* some function */

    end = clock();

    elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
    }`

calculating elapsed time in vb.net. I have no idea of vb.net, i need the following c program in vb.net. please convert the following c program to vb.net  and i want the elapsed time to show no of days when the elapsed time exceeds 24 hours. Thank you so much",c,vb.net,,,,07/09/2012 00:33:25,not a real question,1,104,5,"calculating elapsed time in vb.net     `main()
    {
    clock_t start, end;
    double elapsed;

    start = clock();

     /* some function */

    end = clock();

    elapsed = ((double) (end - start)) / CLOCKS_PER_SEC;
    }`

calculating elapsed time in vb.net. I have no idea of vb.net, i need the following c program in vb.net. please convert the following c program to vb.net  and i want the elapsed time to show no of days when the elapsed time exceeds 24 hours. Thank you so much",2
8285337,11/27/2011 11:50:12,776720,05/30/2011 19:47:17,37,1,Compare 2 doubles but without all the digits on C,"I want to compare 2 double but without all the digits.
for example i have this double 1.548799778 and this 1.547990978 and I want to compare 1.xx from each. How can I ""round"" this double to 1.xx?? 
Thanks",c,compare,double,,,,open,0,37,10,"Compare 2 doubles but without all the digits on C I want to compare 2 double but without all the digits.
for example i have this double 1.548799778 and this 1.547990978 and I want to compare 1.xx from each. How can I ""round"" this double to 1.xx?? 
Thanks",3
6299323,06/09/2011 21:09:49,479989,10/19/2010 02:36:06,9634,319,Good introduction to <inttypes.h>,"I want to recommend the use of `<inttypes.h>` to someone doing `printf` with mixed 32/64 bit builds.  I tried to Google an introduction or tutorial page with a few examples and usage guidelines, but I couldn't find one.

Can someone recommend an introduction or tutorial for `<inttypes.h>`?",c,printf,c99,,,,open,0,47,4,"Good introduction to <inttypes.h> I want to recommend the use of `<inttypes.h>` to someone doing `printf` with mixed 32/64 bit builds.  I tried to Google an introduction or tutorial page with a few examples and usage guidelines, but I couldn't find one.

Can someone recommend an introduction or tutorial for `<inttypes.h>`?",3
3694131,09/12/2010 07:54:41,149482,08/03/2009 03:53:31,6172,239,Fastest integer type for common architectures,"The [`stdint.h`][1] header lacks an `int_fastest_t` and `uint_fastest_t` to correspond with the `{,u}int_fastX_t` types. For instances where the width of the integer type does not matter, how does one pick the integer type that allows processing the greatest quantity of bits with the least penalty to performance? For example, if one was searching for the first set bit in a buffer using a naive approach, a loop such as this might be considered:

    // return the bit offset of the first 1 bit
    size_t find_first_bit_set(void const *const buf)
    {
        uint_fastest_t const *p; // use the fastest type for comparison to zero
        for (; *p == 0; ++p); // inc p while no bits are set
        return p - buf + ffsX(*p) - 1; // return offset of first bit set
    }

Naturally, using `char` would result in more operations than `int`. But `long long` might result in more expensive operations than the overhead of using `int` on a 32 bit system and so on.

My current assumption is for the mainstream architectures, the use of `long` is the safest bet: It's 32 bit on 32 bit systems, and 64 bit on 64 bit systems.


  [1]: http://en.wikipedia.org/wiki/Stdint.h",c,architecture,integer,fastest,stdint,,open,0,228,6,"Fastest integer type for common architectures The [`stdint.h`][1] header lacks an `int_fastest_t` and `uint_fastest_t` to correspond with the `{,u}int_fastX_t` types. For instances where the width of the integer type does not matter, how does one pick the integer type that allows processing the greatest quantity of bits with the least penalty to performance? For example, if one was searching for the first set bit in a buffer using a naive approach, a loop such as this might be considered:

    // return the bit offset of the first 1 bit
    size_t find_first_bit_set(void const *const buf)
    {
        uint_fastest_t const *p; // use the fastest type for comparison to zero
        for (; *p == 0; ++p); // inc p while no bits are set
        return p - buf + ffsX(*p) - 1; // return offset of first bit set
    }

Naturally, using `char` would result in more operations than `int`. But `long long` might result in more expensive operations than the overhead of using `int` on a 32 bit system and so on.

My current assumption is for the mainstream architectures, the use of `long` is the safest bet: It's 32 bit on 32 bit systems, and 64 bit on 64 bit systems.


  [1]: http://en.wikipedia.org/wiki/Stdint.h",5
4409591,12/10/2010 14:11:24,526477,12/01/2010 11:47:29,796,48,2D array initialisation in C,"I know this is an old chestnut, but I want a small 2D array statically allocated in my code. I know the way to do this is:

    static int A[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } };

That's fine and I can access all the members of it. However I have several problems passing it to a function, e.g.:

    void print_matrix(int **a, int r, int c)
    {
        int x, y;
    
        for(x = 0; x < r; x++)
        {
            printf(""Row %02d = %#x = "", x, a[x]);
    
            for(y = 0; y < c; y++)
            {
                printf(""%s%d"", (0 == y) ? """" : "", "", a[x][y]);
            }
            printf(""\n"");
        }
    }

Firstly I can't simply pass `A` to the function, I need to cast it to (int **). Since `char *` is synonymous to `char []`, I was a little surprised at this. Secondly, it crashes and when I check in the debugger, within the sub-function, `a[0]` is reported as `1` and not a pointer to an array of integers.

I know there is compiler/C language arcane magic happening here. But it is all a little confusing. If I try to initialise as:

    static int *A[3] = { { 1, 2 }, { 3, 4 }, { 5, 6 } };

I get a ton of warnings. How does this differ to:

    static char *S[3] = { ""hello"". ""there"", ""stackoverflow"" };


-----

Apart from the question of arcane C magic, which somehow I have never learnt despite over a decade of C programming :(, I would like to know how to generate my array so I can successfully pass it as an `int **` without having to go through all the fag of for loops or copying the statically allocated array to a dynamically allocated one.

Would the following work?

    int *A0 = { 1, 2 };
    int *A1 = { 3, 4 };
    int *A2 = { 5, 6 };
    int **A = { A0, A1, A2 };

Is there a nicer way than this of doing it?


Thanks, all.

P.s. I know that in real life we would read values from a DB or file into dynamically allocated arrays and avoid all this stuff.

",c,multidimensional-array,,,,,open,0,497,5,"2D array initialisation in C I know this is an old chestnut, but I want a small 2D array statically allocated in my code. I know the way to do this is:

    static int A[3][2] = { { 1, 2 }, { 3, 4 }, { 5, 6 } };

That's fine and I can access all the members of it. However I have several problems passing it to a function, e.g.:

    void print_matrix(int **a, int r, int c)
    {
        int x, y;
    
        for(x = 0; x < r; x++)
        {
            printf(""Row %02d = %#x = "", x, a[x]);
    
            for(y = 0; y < c; y++)
            {
                printf(""%s%d"", (0 == y) ? """" : "", "", a[x][y]);
            }
            printf(""\n"");
        }
    }

Firstly I can't simply pass `A` to the function, I need to cast it to (int **). Since `char *` is synonymous to `char []`, I was a little surprised at this. Secondly, it crashes and when I check in the debugger, within the sub-function, `a[0]` is reported as `1` and not a pointer to an array of integers.

I know there is compiler/C language arcane magic happening here. But it is all a little confusing. If I try to initialise as:

    static int *A[3] = { { 1, 2 }, { 3, 4 }, { 5, 6 } };

I get a ton of warnings. How does this differ to:

    static char *S[3] = { ""hello"". ""there"", ""stackoverflow"" };


-----

Apart from the question of arcane C magic, which somehow I have never learnt despite over a decade of C programming :(, I would like to know how to generate my array so I can successfully pass it as an `int **` without having to go through all the fag of for loops or copying the statically allocated array to a dynamically allocated one.

Would the following work?

    int *A0 = { 1, 2 };
    int *A1 = { 3, 4 };
    int *A2 = { 5, 6 };
    int **A = { A0, A1, A2 };

Is there a nicer way than this of doing it?


Thanks, all.

P.s. I know that in real life we would read values from a DB or file into dynamically allocated arrays and avoid all this stuff.

",2
10357899,04/27/2012 21:09:58,479306,10/18/2010 12:51:45,1,0,gcc: Permission Denied on Debian linux using normal user account,I'm new to Linux and using gcc. I tried to run gcc in Debian under my normal user account and it says permission denied. How can I allow a normal user to run gcc? I shouldn't have to always use root to compile a program. Thanks.,c,gcc,,,,,open,0,46,10,gcc: Permission Denied on Debian linux using normal user account I'm new to Linux and using gcc. I tried to run gcc in Debian under my normal user account and it says permission denied. How can I allow a normal user to run gcc? I shouldn't have to always use root to compile a program. Thanks.,2
10524334,05/09/2012 21:27:00,1371050,05/02/2012 20:43:18,23,0,how to use strlwr() function/C,"I am taking words from file but how can i use strlwr if there s word like this ""AbcD"" i want t o take  like ""abcd""


    char word[20];
    
    fp1 = fopen(""unencrypted.txt"",""r+""); 
    do {
    g = fscanf(fp1,""%s"",word); ",c,char,word,,,05/09/2012 22:01:30,not a real question,1,55,5,"how to use strlwr() function/C I am taking words from file but how can i use strlwr if there s word like this ""AbcD"" i want t o take  like ""abcd""


    char word[20];
    
    fp1 = fopen(""unencrypted.txt"",""r+""); 
    do {
    g = fscanf(fp1,""%s"",word); ",3
8944760,01/20/2012 16:38:33,2799,08/25/2008 07:54:29,3730,133,Concise way to write decision tree with height 2 in C,"I have a decision tree of height 2:

    const BOOL isVerticalAnimationRequired = YES;
    const BOOL isArgumentEditorExpanded = YES;
    const BOOL isSelectionLeftToRight = YES;

    UITableViewRowAnimation argumentEditorAnimation;
    if (isVerticalAnimationRequired)
    {
        argumentEditorAnimation = (isArgumentEditorExpanded) ? UITableViewRowAnimationTop :     UITableViewRowAnimationBottom;
    }
    else
    {
        argumentEditorAnimation = (isSelectionLeftToRight) ? UITableViewRowAnimationLeft : UITableViewRowAnimationRight;
    }


My problem is that the code is verbose. Ideally I would like to declare and set `argumentEditorAnimation` in one statement. 

Are there any clever C style tips for handling situation like this?",c,coding-style,,,,,open,0,125,11,"Concise way to write decision tree with height 2 in C I have a decision tree of height 2:

    const BOOL isVerticalAnimationRequired = YES;
    const BOOL isArgumentEditorExpanded = YES;
    const BOOL isSelectionLeftToRight = YES;

    UITableViewRowAnimation argumentEditorAnimation;
    if (isVerticalAnimationRequired)
    {
        argumentEditorAnimation = (isArgumentEditorExpanded) ? UITableViewRowAnimationTop :     UITableViewRowAnimationBottom;
    }
    else
    {
        argumentEditorAnimation = (isSelectionLeftToRight) ? UITableViewRowAnimationLeft : UITableViewRowAnimationRight;
    }


My problem is that the code is verbose. Ideally I would like to declare and set `argumentEditorAnimation` in one statement. 

Are there any clever C style tips for handling situation like this?",2
7908105,10/26/2011 19:55:25,541686,12/14/2010 08:54:07,24369,714,C Code Re-Formatter?,"Is there a C code re-formatter out there that can perform transformations *across* newlines?

i.e. assuming it is given all my include directories, it should be able to re-format the code

    void
    WINAPI
    SetLastError(
      __in  DWORD dwErrCode
    );

into

    void WINAPI SetLastError(__in DWORD dwErrCode);

or reformat the code

    for (...;
         ...;
         ...)
    {
        ...;
    }

into

    for (...; ...; ...) { ...; }",c,source,formatter,,,,open,0,115,3,"C Code Re-Formatter? Is there a C code re-formatter out there that can perform transformations *across* newlines?

i.e. assuming it is given all my include directories, it should be able to re-format the code

    void
    WINAPI
    SetLastError(
      __in  DWORD dwErrCode
    );

into

    void WINAPI SetLastError(__in DWORD dwErrCode);

or reformat the code

    for (...;
         ...;
         ...)
    {
        ...;
    }

into

    for (...; ...; ...) { ...; }",3
1811384,11/28/2009 02:47:35,159995,08/20/2009 12:10:03,48,0,What is the best language for sockets programming?,I'd like to develop a software who communicates between clients. What is the best language to do that?,c,c++,erlang,python,haskell,05/21/2012 16:47:28,not constructive,1,18,8,What is the best language for sockets programming? I'd like to develop a software who communicates between clients. What is the best language to do that?,5
4076334,11/02/2010 09:26:44,148869,08/01/2009 06:52:54,187,14,Write a function which swap two int* in c and also write call to that function.,"A nice C interview question.  
**Write a function which swap two int* in c and also write call to that function?**",c,interview-questions,,,,11/02/2010 11:49:36,not a real question,1,22,16,"Write a function which swap two int* in c and also write call to that function. A nice C interview question.  
**Write a function which swap two int* in c and also write call to that function?**",2
9457197,02/26/2012 21:11:07,882445,08/07/2011 05:30:34,162,12,C Gameboy separate functions an main files,"I am working on a gameboy project for a class asignment. I was told, that we needed to have a separate ""functions"" file, and ""main"" file. I am going insane doing this. I have made a header file ""myLib.h"", and in it I include definitions, and prototypes of the functions that are in ""myLib.c"". In my main file, I call a function from ""myLib.c"", and it compiles, but will not work. I have added ""myLib.c"" to my make file. The files are below:

myLib.h

   

    typedef unsigned short u16;
    typedef unsigned char u8;
    typedef unsigned int u32;
    
    #define REG_DISPCTL *(unsigned short *)0x4000000
    #define MODE3 3
    #define BG2_ENABLE  (1<<10)
    #define SCANLINECOUNTER *(volatile u16 *)0x4000006
    
    #define COLOR(r, g, b) ((r) | (g)<<5 | (b)<<10)
    
    #define RED COLOR(31,0,0)
    #define GREEN COLOR(0,31,0)
    #define BLUE COLOR(0,0,31)
    #define MAGENTA COLOR(31, 0, 31)
    #define YELLOW COLOR(31, 31, 0)
    #define CYAN COLOR(0,31,31)
    #define WHITE COLOR(31,31,31)
    #define BLACK 0
    
    
    #define OFFSET(r, c, numcols)  ((r)*(numcols) + (c))
    
    
    extern unsigned short *videoBuffer;
    
    // Buttons
    
    #define BUTTON_A		(1<<0)
    #define BUTTON_B		(1<<1)
    #define BUTTON_SELECT           (1<<2)
    #define BUTTON_START            (1<<3)
    #define BUTTON_RIGHT            (1<<4)
    #define BUTTON_LEFT		(1<<5)
    #define BUTTON_UP		(1<<6)
    #define BUTTON_DOWN		(1<<7)
    #define BUTTON_R		(1<<8)
    #define BUTTON_L		(1<<9)
    
    #define BUTTONS *(unsigned int *)0x4000130
    
    #define KEY_DOWN_NOW(key)  (~(BUTTONS) & key)
    
    /* DMA */
    
    typedef struct
    {
    	const volatile void *src;
    	const volatile void *dst;
    	u32                  cnt;
    } DMA_CONTROLLER;
    
    #define DMA ((volatile DMA_CONTROLLER *) 0x040000B0)
    
    #define REG_DMA0SAD         *(const volatile u32*)0x40000B0  // source address
    #define REG_DMA0DAD         *(volatile u32*)0x40000B4  // destination address
    #define REG_DMA0CNT         *(volatile u32*)0x40000B8  // control register
    
    // DMA channel 1 register definitions
    #define REG_DMA1SAD         *(const volatile u32*)0x40000BC  // source address
    #define REG_DMA1DAD         *(volatile u32*)0x40000C0  // destination address
    #define REG_DMA1CNT         *(volatile u32*)0x40000C4  // control register
    
    // DMA channel 2 register definitions
    #define REG_DMA2SAD         *(const volatile u32*)0x40000C8  // source address
    #define REG_DMA2DAD         *(volatile u32*)0x40000CC  // destination address
    #define REG_DMA2CNT         *(volatile u32*)0x40000D0  // control register
    
    // DMA channel 3 register definitions
    #define REG_DMA3SAD         *(volatile u32*)0x40000D4   // source address
    #define REG_DMA3DAD         *(volatile u32*)0x40000D8  // destination address
    #define REG_DMA3CNT         *(volatile u32*)0x40000DC  // control register
    
    // Defines
    #define DMA_CHANNEL_0 0
    #define DMA_CHANNEL_1 1
    #define DMA_CHANNEL_2 2
    #define DMA_CHANNEL_3 3
    
    #define DMA_DESTINATION_INCREMENT (0 << 21)
    #define DMA_DESTINATION_DECREMENT (1 << 21)
    #define DMA_DESTINATION_FIXED (2 << 21)
    #define DMA_DESTINATION_RESET (3 << 21)
    
    #define DMA_SOURCE_INCREMENT (0 << 23)
    #define DMA_SOURCE_DECREMENT (1 << 23)
    #define DMA_SOURCE_FIXED (2 << 23)
    
    #define DMA_REPEAT (1 << 25)
    
    #define DMA_16 (0 << 26)
    #define DMA_32 (1 << 26)
    
    #define DMA_NOW (0 << 28)
    #define DMA_AT_VBLANK (1 << 28)
    #define DMA_AT_HBLANK (2 << 28)
    #define DMA_AT_REFRESH (3 << 28)
    
    #define DMA_IRQ (1 << 30)
    #define DMA_ON (1 << 31)
    
    
    
    
    
    
    // Prototypes
    void setPixel(int , int , u16 );
    void drawRect(int row, int col, int height, int width, u16 color);
    void waitForVblank();
    void fillScreen(u16 color);
    void delay(int);


myLib.c

    #include ""myLib.h""
    
    unsigned short *videoBuffer = (unsigned short *)0x6000000;
    void setPixel(int row, int col, u16 color)
    {
        videoBuffer[OFFSET(row, col, 240)] = color;
    }
    
    void drawRect(int row, int col, int height, int width, 
            volatile u16 color)
    {
        int r;
        
        for(r=0;r<height; r++)
        {
            
            REG_DMA3SAD = (u32)&color;
            REG_DMA3DAD = (u32)(&videoBuffer[OFFSET(row+r, col, 240)]);
            REG_DMA3CNT = width | DMA_SOURCE_FIXED | 
                      DMA_DESTINATION_INCREMENT | DMA_ON;
        
        }
    }
    
    void waitForVblank()
    {
        while(SCANLINECOUNTER > 160);
        while(SCANLINECOUNTER < 160);
        
    }
    
    void fillScreen(volatile u16 color)
    {
        REG_DMA3SAD = (u32)&color;
        REG_DMA3DAD = (u32)videoBuffer;
        REG_DMA3CNT = (160*240) | DMA_SOURCE_FIXED | 
                      DMA_DESTINATION_INCREMENT | DMA_ON;
    }
    void delay(int n)
    {
        int i;
        volatile int x;
        for(i=0; i<10000*n; i++)
        {
            x = x + 1;
        }
    }

main.c

    #include <stdio.h>
    #include <stdlib.h>
    #include ""myLib.h""
    
    int main() {
        int i = 0;
        int j = 0;
        for(i = 0; i < 160; i++){
            for(j = 0; j < 240; j++){
                {
                    setPixel(i, j, RED);
                }
            }
        }
        return (EXIT_SUCCESS);
    }

Makefile

    ########################################
    ## CS1372 Dual GBA/Console Makefile   ##
    ## Updated: 1/08/2010 - Drew Bratcher ##
    ########################################
    
    # Student instructions:
    # - Ensure that the paths are correct
    # - Edit the SOURCES line with a space-separated list of your .c files
    # - Keep updating SOURCES every time you add a new source file
    # - Select ""Release"" in NetBeans if this is a GBA project
    # - Select ""Debug"" in NetBeans if this is a console project
    # - Make sure the Linker Output in NetBeans is set to ""Program"" for all configurations
    
    
    # --- Project Settings (Change these for your proejct)
    # PRODUCT_NAME should match your Linker Output in NetBeans
    # SOURCES should be The .c files in your project
    PRODUCT_NAME       = Program
    
    ###### LIST ALL C Files in your project here
    SOURCES            = main.c myLib.c 
    
    ###### --- System Settings (Update these for your system)
    ###### Mac example paths
    DKPATH             = C:/CS1372-Tools/devkitARM/devkitARM/bin
    CCPATH             = C:/cygwin/bin
    VBASIM             = C:/CS1372-Tools/VisualBoyAdvance-1.7.2/VisualBoyAdvance.exe
    #DKPATH             = C:/devkitARM/bin
    #CCPATH             = C:/cygwin/bin
    #VBASIM             = C:/
    
    
    
    FIND               = find
    COPY               = cp -r
    
    # --- File Names
    ELF_NAME           = $(PRODUCT_NAME).elf
    ROM_NAME           = $(PRODUCT_NAME).gba
    BIN_NAME           = $(PRODUCT_NAME)
    
    # --- Debug and Release Selection
    # Don't change this or it'll break your Makefile
    # If you need to override the selection, uncomment one:
    #CONF               = Debug
    #CONF               = Release
    ifeq ($(CONF),Debug)
    DEBUG              = yes
    endif
    
    ifndef DEBUG
    # ============ RELEASE MODE
    # --- GBA Settings
    MODEL              = -mthumb-interwork -mthumb
    SPECS              = -specs=gba.specs
    
    # --- Archiver
    AS                 = $(DKPATH)/arm-eabi-as
    ASFLAGS            = -mthumb-interwork
    
    # --- Compiler
    CC                 = $(DKPATH)/arm-eabi-gcc
    CFLAGS             = $(MODEL) -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -D_ROM=$(ROM_NAME) -D_VBA=$(VBASIM)
    CC_WRAP            = $(CCPATH)/gcc
    CFLAGS_WRAP        = -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -D_ROM='""$(ROM_NAME)""' -D_VBA='""$(VBASIM)""'
    
    # --- Linker
    LD                 = $(DKPATH)/arm-eabi-gcc
    LDFLAGS            = $(SPECS) $(MODEL) -lm
    
    # --- Object/Executable Packager
    OBJCOPY            = $(DKPATH)/arm-eabi-objcopy
    OBJCOPYFLAGS       = -O binary
    
    # --- ROM Fixer
    GBAFIX             = $(DKPATH)/gbafix
    
    # --- Delete
    RM                 = rm -f
    
    OBJECTS = $(filter-out gba_wrapper%,$(SOURCES:.c=.o))
    
    # --- Main build target
    all : build $(BIN_NAME)
    
    run : build
    	$(VBASIM) $(ROM_NAME)
    
    build : UNZIP $(ROM_NAME)
    
    $(BIN_NAME) : gba_wrapper.c
    	$(CC_WRAP) $(CFLAGS_WRAP) -o $@ $^
    
    # --- Build .elf file into .gba ROM file
    $(ROM_NAME) : $(ELF_NAME)
    	$(OBJCOPY) $(OBJCOPYFLAGS) $(ELF_NAME) $(ROM_NAME)
    	$(GBAFIX) $(ROM_NAME)
    
    # --- Build .o files into .elf file
    $(ELF_NAME) : $(OBJECTS)
    	$(LD) $(OBJECTS) $(LDFLAGS) -o $@
    
    # -- Build .c files into .o files
    $(OBJECTS) : %.o : %.c
    	$(CC) $(CFLAGS) -c $< -o $@
    
    # ============ RELEASE MODE
    else
    # ============ DEBUG MODE
    # --- Compiler
    CC                 = $(CCPATH)/gcc
    CFLAGS             = -D_DEBUG -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -ggdb
    
    all : build
    
    run : build
    	./$(BIN_NAME)
    
    clean :
    
    build : UNZIP $(BIN_NAME)
    
    $(BIN_NAME) : $(SOURCES)
    	$(CC) -o $(BIN_NAME) $(CFLAGS) $(SOURCES)
    
    # ============ DEBUG MODE
    endif
    
    # ============ Common
    UNZIP :
    	-@$(FIND) . -iname ""*.zip"" -exec unzip -n {} \; -exec echo ""This project must be rebuilt"" \; -exec rm {} \;
    
    clean:
    	$(RM) $(ROM_NAME)
    	$(RM) $(ELF_NAME)
    	$(RM) $(BIN_NAME)
    	$(RM) *.o
    # ============ Common

",c,homework,makefile,gameboy,,03/01/2012 04:33:04,too localized,1,2890,7,"C Gameboy separate functions an main files I am working on a gameboy project for a class asignment. I was told, that we needed to have a separate ""functions"" file, and ""main"" file. I am going insane doing this. I have made a header file ""myLib.h"", and in it I include definitions, and prototypes of the functions that are in ""myLib.c"". In my main file, I call a function from ""myLib.c"", and it compiles, but will not work. I have added ""myLib.c"" to my make file. The files are below:

myLib.h

   

    typedef unsigned short u16;
    typedef unsigned char u8;
    typedef unsigned int u32;
    
    #define REG_DISPCTL *(unsigned short *)0x4000000
    #define MODE3 3
    #define BG2_ENABLE  (1<<10)
    #define SCANLINECOUNTER *(volatile u16 *)0x4000006
    
    #define COLOR(r, g, b) ((r) | (g)<<5 | (b)<<10)
    
    #define RED COLOR(31,0,0)
    #define GREEN COLOR(0,31,0)
    #define BLUE COLOR(0,0,31)
    #define MAGENTA COLOR(31, 0, 31)
    #define YELLOW COLOR(31, 31, 0)
    #define CYAN COLOR(0,31,31)
    #define WHITE COLOR(31,31,31)
    #define BLACK 0
    
    
    #define OFFSET(r, c, numcols)  ((r)*(numcols) + (c))
    
    
    extern unsigned short *videoBuffer;
    
    // Buttons
    
    #define BUTTON_A		(1<<0)
    #define BUTTON_B		(1<<1)
    #define BUTTON_SELECT           (1<<2)
    #define BUTTON_START            (1<<3)
    #define BUTTON_RIGHT            (1<<4)
    #define BUTTON_LEFT		(1<<5)
    #define BUTTON_UP		(1<<6)
    #define BUTTON_DOWN		(1<<7)
    #define BUTTON_R		(1<<8)
    #define BUTTON_L		(1<<9)
    
    #define BUTTONS *(unsigned int *)0x4000130
    
    #define KEY_DOWN_NOW(key)  (~(BUTTONS) & key)
    
    /* DMA */
    
    typedef struct
    {
    	const volatile void *src;
    	const volatile void *dst;
    	u32                  cnt;
    } DMA_CONTROLLER;
    
    #define DMA ((volatile DMA_CONTROLLER *) 0x040000B0)
    
    #define REG_DMA0SAD         *(const volatile u32*)0x40000B0  // source address
    #define REG_DMA0DAD         *(volatile u32*)0x40000B4  // destination address
    #define REG_DMA0CNT         *(volatile u32*)0x40000B8  // control register
    
    // DMA channel 1 register definitions
    #define REG_DMA1SAD         *(const volatile u32*)0x40000BC  // source address
    #define REG_DMA1DAD         *(volatile u32*)0x40000C0  // destination address
    #define REG_DMA1CNT         *(volatile u32*)0x40000C4  // control register
    
    // DMA channel 2 register definitions
    #define REG_DMA2SAD         *(const volatile u32*)0x40000C8  // source address
    #define REG_DMA2DAD         *(volatile u32*)0x40000CC  // destination address
    #define REG_DMA2CNT         *(volatile u32*)0x40000D0  // control register
    
    // DMA channel 3 register definitions
    #define REG_DMA3SAD         *(volatile u32*)0x40000D4   // source address
    #define REG_DMA3DAD         *(volatile u32*)0x40000D8  // destination address
    #define REG_DMA3CNT         *(volatile u32*)0x40000DC  // control register
    
    // Defines
    #define DMA_CHANNEL_0 0
    #define DMA_CHANNEL_1 1
    #define DMA_CHANNEL_2 2
    #define DMA_CHANNEL_3 3
    
    #define DMA_DESTINATION_INCREMENT (0 << 21)
    #define DMA_DESTINATION_DECREMENT (1 << 21)
    #define DMA_DESTINATION_FIXED (2 << 21)
    #define DMA_DESTINATION_RESET (3 << 21)
    
    #define DMA_SOURCE_INCREMENT (0 << 23)
    #define DMA_SOURCE_DECREMENT (1 << 23)
    #define DMA_SOURCE_FIXED (2 << 23)
    
    #define DMA_REPEAT (1 << 25)
    
    #define DMA_16 (0 << 26)
    #define DMA_32 (1 << 26)
    
    #define DMA_NOW (0 << 28)
    #define DMA_AT_VBLANK (1 << 28)
    #define DMA_AT_HBLANK (2 << 28)
    #define DMA_AT_REFRESH (3 << 28)
    
    #define DMA_IRQ (1 << 30)
    #define DMA_ON (1 << 31)
    
    
    
    
    
    
    // Prototypes
    void setPixel(int , int , u16 );
    void drawRect(int row, int col, int height, int width, u16 color);
    void waitForVblank();
    void fillScreen(u16 color);
    void delay(int);


myLib.c

    #include ""myLib.h""
    
    unsigned short *videoBuffer = (unsigned short *)0x6000000;
    void setPixel(int row, int col, u16 color)
    {
        videoBuffer[OFFSET(row, col, 240)] = color;
    }
    
    void drawRect(int row, int col, int height, int width, 
            volatile u16 color)
    {
        int r;
        
        for(r=0;r<height; r++)
        {
            
            REG_DMA3SAD = (u32)&color;
            REG_DMA3DAD = (u32)(&videoBuffer[OFFSET(row+r, col, 240)]);
            REG_DMA3CNT = width | DMA_SOURCE_FIXED | 
                      DMA_DESTINATION_INCREMENT | DMA_ON;
        
        }
    }
    
    void waitForVblank()
    {
        while(SCANLINECOUNTER > 160);
        while(SCANLINECOUNTER < 160);
        
    }
    
    void fillScreen(volatile u16 color)
    {
        REG_DMA3SAD = (u32)&color;
        REG_DMA3DAD = (u32)videoBuffer;
        REG_DMA3CNT = (160*240) | DMA_SOURCE_FIXED | 
                      DMA_DESTINATION_INCREMENT | DMA_ON;
    }
    void delay(int n)
    {
        int i;
        volatile int x;
        for(i=0; i<10000*n; i++)
        {
            x = x + 1;
        }
    }

main.c

    #include <stdio.h>
    #include <stdlib.h>
    #include ""myLib.h""
    
    int main() {
        int i = 0;
        int j = 0;
        for(i = 0; i < 160; i++){
            for(j = 0; j < 240; j++){
                {
                    setPixel(i, j, RED);
                }
            }
        }
        return (EXIT_SUCCESS);
    }

Makefile

    ########################################
    ## CS1372 Dual GBA/Console Makefile   ##
    ## Updated: 1/08/2010 - Drew Bratcher ##
    ########################################
    
    # Student instructions:
    # - Ensure that the paths are correct
    # - Edit the SOURCES line with a space-separated list of your .c files
    # - Keep updating SOURCES every time you add a new source file
    # - Select ""Release"" in NetBeans if this is a GBA project
    # - Select ""Debug"" in NetBeans if this is a console project
    # - Make sure the Linker Output in NetBeans is set to ""Program"" for all configurations
    
    
    # --- Project Settings (Change these for your proejct)
    # PRODUCT_NAME should match your Linker Output in NetBeans
    # SOURCES should be The .c files in your project
    PRODUCT_NAME       = Program
    
    ###### LIST ALL C Files in your project here
    SOURCES            = main.c myLib.c 
    
    ###### --- System Settings (Update these for your system)
    ###### Mac example paths
    DKPATH             = C:/CS1372-Tools/devkitARM/devkitARM/bin
    CCPATH             = C:/cygwin/bin
    VBASIM             = C:/CS1372-Tools/VisualBoyAdvance-1.7.2/VisualBoyAdvance.exe
    #DKPATH             = C:/devkitARM/bin
    #CCPATH             = C:/cygwin/bin
    #VBASIM             = C:/
    
    
    
    FIND               = find
    COPY               = cp -r
    
    # --- File Names
    ELF_NAME           = $(PRODUCT_NAME).elf
    ROM_NAME           = $(PRODUCT_NAME).gba
    BIN_NAME           = $(PRODUCT_NAME)
    
    # --- Debug and Release Selection
    # Don't change this or it'll break your Makefile
    # If you need to override the selection, uncomment one:
    #CONF               = Debug
    #CONF               = Release
    ifeq ($(CONF),Debug)
    DEBUG              = yes
    endif
    
    ifndef DEBUG
    # ============ RELEASE MODE
    # --- GBA Settings
    MODEL              = -mthumb-interwork -mthumb
    SPECS              = -specs=gba.specs
    
    # --- Archiver
    AS                 = $(DKPATH)/arm-eabi-as
    ASFLAGS            = -mthumb-interwork
    
    # --- Compiler
    CC                 = $(DKPATH)/arm-eabi-gcc
    CFLAGS             = $(MODEL) -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -D_ROM=$(ROM_NAME) -D_VBA=$(VBASIM)
    CC_WRAP            = $(CCPATH)/gcc
    CFLAGS_WRAP        = -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -D_ROM='""$(ROM_NAME)""' -D_VBA='""$(VBASIM)""'
    
    # --- Linker
    LD                 = $(DKPATH)/arm-eabi-gcc
    LDFLAGS            = $(SPECS) $(MODEL) -lm
    
    # --- Object/Executable Packager
    OBJCOPY            = $(DKPATH)/arm-eabi-objcopy
    OBJCOPYFLAGS       = -O binary
    
    # --- ROM Fixer
    GBAFIX             = $(DKPATH)/gbafix
    
    # --- Delete
    RM                 = rm -f
    
    OBJECTS = $(filter-out gba_wrapper%,$(SOURCES:.c=.o))
    
    # --- Main build target
    all : build $(BIN_NAME)
    
    run : build
    	$(VBASIM) $(ROM_NAME)
    
    build : UNZIP $(ROM_NAME)
    
    $(BIN_NAME) : gba_wrapper.c
    	$(CC_WRAP) $(CFLAGS_WRAP) -o $@ $^
    
    # --- Build .elf file into .gba ROM file
    $(ROM_NAME) : $(ELF_NAME)
    	$(OBJCOPY) $(OBJCOPYFLAGS) $(ELF_NAME) $(ROM_NAME)
    	$(GBAFIX) $(ROM_NAME)
    
    # --- Build .o files into .elf file
    $(ELF_NAME) : $(OBJECTS)
    	$(LD) $(OBJECTS) $(LDFLAGS) -o $@
    
    # -- Build .c files into .o files
    $(OBJECTS) : %.o : %.c
    	$(CC) $(CFLAGS) -c $< -o $@
    
    # ============ RELEASE MODE
    else
    # ============ DEBUG MODE
    # --- Compiler
    CC                 = $(CCPATH)/gcc
    CFLAGS             = -D_DEBUG -O2 -Wall -pedantic -Wextra -Werror -ansi -std=c99 -ggdb
    
    all : build
    
    run : build
    	./$(BIN_NAME)
    
    clean :
    
    build : UNZIP $(BIN_NAME)
    
    $(BIN_NAME) : $(SOURCES)
    	$(CC) -o $(BIN_NAME) $(CFLAGS) $(SOURCES)
    
    # ============ DEBUG MODE
    endif
    
    # ============ Common
    UNZIP :
    	-@$(FIND) . -iname ""*.zip"" -exec unzip -n {} \; -exec echo ""This project must be rebuilt"" \; -exec rm {} \;
    
    clean:
    	$(RM) $(ROM_NAME)
    	$(RM) $(ELF_NAME)
    	$(RM) $(BIN_NAME)
    	$(RM) *.o
    # ============ Common

",4
1864352,12/08/2009 03:18:54,149482,08/03/2009 03:53:31,969,54,void has unknown size in Visual C++,"In Visual Studio C++ version 9 (and probably other versions too), the following code:

 int a = sizeof(void);
 void const *b = static_cast<void const *>(""hello world"");
 b += 6;

Generates [these][1] [errors][2]:

    error C2070: 'void': illegal sizeof operand
    error C2036: 'const void *' : unknown size

This code works under GCC, which treats [`sizeof(void)` as `1`][3].

Is there some way around this limitation, as casting explicitly to `char *` for purposes of pointer arithmetic adds to the confusion (`void *` is well recognised and used as a typeless pointer to raw memory).

  [1]: http://msdn.microsoft.com/en-us/library/9adz64y0.aspx
  [2]: http://msdn.microsoft.com/en-us/library/1kay26wa%28VS.80%29.aspx
  [3]: http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Pointer-Arith.html#Pointer-Arith",c,gcc,visual-studio,void-pointers,pointer-arithmetic,02/20/2012 20:43:19,not constructive,1,104,7,"void has unknown size in Visual C++ In Visual Studio C++ version 9 (and probably other versions too), the following code:

 int a = sizeof(void);
 void const *b = static_cast<void const *>(""hello world"");
 b += 6;

Generates [these][1] [errors][2]:

    error C2070: 'void': illegal sizeof operand
    error C2036: 'const void *' : unknown size

This code works under GCC, which treats [`sizeof(void)` as `1`][3].

Is there some way around this limitation, as casting explicitly to `char *` for purposes of pointer arithmetic adds to the confusion (`void *` is well recognised and used as a typeless pointer to raw memory).

  [1]: http://msdn.microsoft.com/en-us/library/9adz64y0.aspx
  [2]: http://msdn.microsoft.com/en-us/library/1kay26wa%28VS.80%29.aspx
  [3]: http://gcc.gnu.org/onlinedocs/gcc-4.4.2/gcc/Pointer-Arith.html#Pointer-Arith",5
10989753,06/12/2012 02:09:16,1450181,06/12/2012 01:58:06,1,0,What does x->y -= 2 in c do?,What does x->y -= 2 do in C? I'm new to C.                                                    ,c,,,,,06/12/2012 02:11:40,not a real question,1,64,8,What does x->y -= 2 in c do? What does x->y -= 2 do in C? I'm new to C.                                                    ,1
9737630,03/16/2012 12:54:11,1116001,12/26/2011 07:27:08,16,0,C fopen won't open file when run in eclipse,"I have problem with using fopen to open file for read in eclipse. The file I'm trying to open is in the same directory as all program files, it has all permissions granted. But the file can't be found by the program. 

When I run it from shell it returns segmentation fault for existing file .I guess it succeeds in opening it , cause for non-existing file it returns that file not found. I figure it encounters error further in the program.

The question is could it be that eclipse searches in other directory than one with the executable file? How can I find it out? How can I fix it? ",c,eclipse,fopen,,,03/21/2012 22:48:49,not a real question,1,111,9,"C fopen won't open file when run in eclipse I have problem with using fopen to open file for read in eclipse. The file I'm trying to open is in the same directory as all program files, it has all permissions granted. But the file can't be found by the program. 

When I run it from shell it returns segmentation fault for existing file .I guess it succeeds in opening it , cause for non-existing file it returns that file not found. I figure it encounters error further in the program.

The question is could it be that eclipse searches in other directory than one with the executable file? How can I find it out? How can I fix it? ",3
3881866,10/07/2010 12:59:29,469102,10/07/2010 12:59:29,1,0,please help me !!!,Firstly i must say that.my english is not very strong.please forgive me. i have got a question about my project.how do you search .txt files in c drivers with C programming language.are there easy codes. ,c,,,,,10/07/2010 13:03:29,not a real question,1,36,4,please help me !!! Firstly i must say that.my english is not very strong.please forgive me. i have got a question about my project.how do you search .txt files in c drivers with C programming language.are there easy codes. ,1
8085595,11/10/2011 20:05:24,1040476,11/10/2011 19:50:23,1,0,Trouble understanding this C code,"at our university, we never learned C but in this class, we are required to use it without any prior knowledge of this language. Some of the code (int sign = fp & 0x8000) and (int shift = (fp>>11) & 0xF) do not make any sense to me. Could you tell me what some of these lines do? Thank you.

The following code implements a simple floating point number/integer system, allowing for extended-range integers nonetheless stored in a short (two machine bytes format.

Your job is to modify the code so that it supports both a hidden bit (implicit given a non-zero exponent) and gradual underflow (when the exponent is zero). The remaining questions all suppose that you have completed the code upgrade.

what are the smallest two positive values you can present?
what are the maximum in magnitude (positive and negative) you can represent?
what does the machine word 0xFFFE represent under FP?
what does the machine word 0x0002 represent under FP?
express the FP product of 0xF11F (x) 0x1FF1 in mini-FP format.
express the FP product of 0x1234 (x) 0x4321 as an (inf. precision) integer
reproduce your program code and machine runs in what you email. A working body of code
appears below, which must be extended slightly to support what is required above. 

    /*
     * minifp.c - floating point stored in 16-bit machine integers
     *
     * our fp fit into the unsigned machine word as follows:
     *
     * sgn(1)+Exp(4)+Frac(11)   +-----------------------+-----------------------+
     *       			        |sg e3 e2 e1 e0 fT f9 f8|f7 f6 f5 f4 f3 f2 f1 f0|
     *      			        +-----------+-----------+-----------+-----------+
     *
     * to convert from mini-fp to machine-int (fp2int), the eleven bits f=[FT..F0]
     * are shifted to the left by from from 0..15 positions as defined by the 4-bit
     * exponent e=[e3:e2:e1:e0] to form an unsigned machine integer of up to 27
     * bits. Finally, this valiue is conditionally negated iff 'sg' != 0.
     * the result conveniently fits within a 32-bit signed machine int: a C 'int'.
     * A 32-bit result (+ - * /) is returned to FP format after machine evaluation.
     * Should our result exceed 27 bits of precision, we must substitute the max
     * possible integer represented by our format. Underflow is not treated (not
     * presently applicable); neither gradual underflow nor the hidden bit is
     * supported.
     *
     *   gcc minifp.c -o test
     *
     *   gcc -DLIB -c -O2 minifp.c
     *
     * TO UPGRADE
     *  (1) write the companion function 'int2fp' and verify its 'invers-icity'. 
     *
     *  (2) replace fT with a ""hidden"" bit, thus extending the exponent to 5 bits
     *	(a) left shifts of up to 32 are now possible, use 'long long' machine
     *	    types to find signed results as a 64-bit integer
     *      (b) support gradual underflow when the exponent is zero (no hidden bit)
     */

    /*
     * PRINTING
     */

    cr() { putchar('\n'); }

    /* output 'v' in 'radix' as 'len' digits, in 'groups' (zero -> no grouping) */

    pbase(v, radix, len, groups)
        {
        if (len > 1) pbase(v/radix, radix, len-1, groups);
        putchar('0'+(v%radix));
        if (!(len%(groups?groups:1000))) putchar(' ');
        }

    /* binary output: 16 and 32-bit versions, nybble groupings */

    b16(v) { pbase(v, 2, 16, 4); }
    b32(v) { pbase(v, 2, 32, 4); }

    /*
     * CONVERSION
     */

    int fp2int(unsigned short fp)
        {
        int sign = fp & 0x8000;
        int shift = (fp>>11) & 0xF;
        int frac = fp & 0x7FF;
        int v = frac << shift; 
        if (sign) v = -v;
        return v;
        }

    int2fp(unsigned long x)
        {
        int sgn, lonebit;
        sgn = x < 0;
        if (sgn) x = -x;
        lonebit = (x<<1) & (~x);
    //  b32(lonebit);		// print it to study it
        }


    /*
     * FP LIBRARY
     */


    unsigned short fpadd(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) + fp2int(b)); }

    unsigned short fpsub(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) - fp2int(b)); }

    unsigned short fpmul(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) * fp2int(b)); }

    unsigned short fpdiv(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) / fp2int(b)); }



    #ifndef LIB

    /*
     * TESTING
     */

    unsigned short testvec[] = { 0, 100, 200, 5000, 10101 };

    tstfp2int()
        {
        int i, v;

        for (i=0; i<sizeof(testvec)/sizeof(short); i++)
    	    {
	    v = testvec[i];
	    b16(v); cr();
	    b32(fp2int(v)); cr();
	    b16(int2fp(fp2int(v))); cr();
	    cr();
	    }
        }


    main()
        {
        tstfp2int();
        }
    #endif
",c,,,,,11/10/2011 20:53:50,too localized,1,1205,5,"Trouble understanding this C code at our university, we never learned C but in this class, we are required to use it without any prior knowledge of this language. Some of the code (int sign = fp & 0x8000) and (int shift = (fp>>11) & 0xF) do not make any sense to me. Could you tell me what some of these lines do? Thank you.

The following code implements a simple floating point number/integer system, allowing for extended-range integers nonetheless stored in a short (two machine bytes format.

Your job is to modify the code so that it supports both a hidden bit (implicit given a non-zero exponent) and gradual underflow (when the exponent is zero). The remaining questions all suppose that you have completed the code upgrade.

what are the smallest two positive values you can present?
what are the maximum in magnitude (positive and negative) you can represent?
what does the machine word 0xFFFE represent under FP?
what does the machine word 0x0002 represent under FP?
express the FP product of 0xF11F (x) 0x1FF1 in mini-FP format.
express the FP product of 0x1234 (x) 0x4321 as an (inf. precision) integer
reproduce your program code and machine runs in what you email. A working body of code
appears below, which must be extended slightly to support what is required above. 

    /*
     * minifp.c - floating point stored in 16-bit machine integers
     *
     * our fp fit into the unsigned machine word as follows:
     *
     * sgn(1)+Exp(4)+Frac(11)   +-----------------------+-----------------------+
     *       			        |sg e3 e2 e1 e0 fT f9 f8|f7 f6 f5 f4 f3 f2 f1 f0|
     *      			        +-----------+-----------+-----------+-----------+
     *
     * to convert from mini-fp to machine-int (fp2int), the eleven bits f=[FT..F0]
     * are shifted to the left by from from 0..15 positions as defined by the 4-bit
     * exponent e=[e3:e2:e1:e0] to form an unsigned machine integer of up to 27
     * bits. Finally, this valiue is conditionally negated iff 'sg' != 0.
     * the result conveniently fits within a 32-bit signed machine int: a C 'int'.
     * A 32-bit result (+ - * /) is returned to FP format after machine evaluation.
     * Should our result exceed 27 bits of precision, we must substitute the max
     * possible integer represented by our format. Underflow is not treated (not
     * presently applicable); neither gradual underflow nor the hidden bit is
     * supported.
     *
     *   gcc minifp.c -o test
     *
     *   gcc -DLIB -c -O2 minifp.c
     *
     * TO UPGRADE
     *  (1) write the companion function 'int2fp' and verify its 'invers-icity'. 
     *
     *  (2) replace fT with a ""hidden"" bit, thus extending the exponent to 5 bits
     *	(a) left shifts of up to 32 are now possible, use 'long long' machine
     *	    types to find signed results as a 64-bit integer
     *      (b) support gradual underflow when the exponent is zero (no hidden bit)
     */

    /*
     * PRINTING
     */

    cr() { putchar('\n'); }

    /* output 'v' in 'radix' as 'len' digits, in 'groups' (zero -> no grouping) */

    pbase(v, radix, len, groups)
        {
        if (len > 1) pbase(v/radix, radix, len-1, groups);
        putchar('0'+(v%radix));
        if (!(len%(groups?groups:1000))) putchar(' ');
        }

    /* binary output: 16 and 32-bit versions, nybble groupings */

    b16(v) { pbase(v, 2, 16, 4); }
    b32(v) { pbase(v, 2, 32, 4); }

    /*
     * CONVERSION
     */

    int fp2int(unsigned short fp)
        {
        int sign = fp & 0x8000;
        int shift = (fp>>11) & 0xF;
        int frac = fp & 0x7FF;
        int v = frac << shift; 
        if (sign) v = -v;
        return v;
        }

    int2fp(unsigned long x)
        {
        int sgn, lonebit;
        sgn = x < 0;
        if (sgn) x = -x;
        lonebit = (x<<1) & (~x);
    //  b32(lonebit);		// print it to study it
        }


    /*
     * FP LIBRARY
     */


    unsigned short fpadd(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) + fp2int(b)); }

    unsigned short fpsub(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) - fp2int(b)); }

    unsigned short fpmul(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) * fp2int(b)); }

    unsigned short fpdiv(unsigned short a, unsigned short b)
        { return int2fp(fp2int(a) / fp2int(b)); }



    #ifndef LIB

    /*
     * TESTING
     */

    unsigned short testvec[] = { 0, 100, 200, 5000, 10101 };

    tstfp2int()
        {
        int i, v;

        for (i=0; i<sizeof(testvec)/sizeof(short); i++)
    	    {
	    v = testvec[i];
	    b16(v); cr();
	    b32(fp2int(v)); cr();
	    b16(int2fp(fp2int(v))); cr();
	    cr();
	    }
        }


    main()
        {
        tstfp2int();
        }
    #endif
",1
1394169,09/08/2009 13:55:09,153660,08/10/2009 11:08:04,3,0,Converting hex string stored as chars to decimal in C,"I'm given a string hex_txt containing a 4 digit hex number in the way outlined in the code, split up in two array entries. I need to convert it to decimal. The following is the way I'm doing it.

    unsigned char hex_txt[] = ""\xAB\xCD"";
    unsigned char hex_num[5];
    unsigned int dec_num;
    
    sprintf(hex_num, ""%.2x%.2x"", (int)hex_txt[0], (int)hex_txt[1]);
    printf(""%s\n"", hex_num);
    sscanf(hex_num, ""%x"", &dec_num);
    printf(""%d\n"", dec_num);

Is there a faster, or more efficient way of doing this? This is my current ad hoc solution, but I'd like to know if there's a proper way to do it.",c,hex,decimal,sscanf,,,open,0,116,10,"Converting hex string stored as chars to decimal in C I'm given a string hex_txt containing a 4 digit hex number in the way outlined in the code, split up in two array entries. I need to convert it to decimal. The following is the way I'm doing it.

    unsigned char hex_txt[] = ""\xAB\xCD"";
    unsigned char hex_num[5];
    unsigned int dec_num;
    
    sprintf(hex_num, ""%.2x%.2x"", (int)hex_txt[0], (int)hex_txt[1]);
    printf(""%s\n"", hex_num);
    sscanf(hex_num, ""%x"", &dec_num);
    printf(""%d\n"", dec_num);

Is there a faster, or more efficient way of doing this? This is my current ad hoc solution, but I'd like to know if there's a proper way to do it.",4
8639481,12/26/2011 22:14:30,532862,12/06/2010 21:02:36,14,0,1 server many clients,"I had implemented a server/client Tcp socket in C language, and I want to improve it to one to many relationship  as one server can accept many clients .. 
could you please tell me how to do that in a simple explanation  ",c,client-server,,,,12/27/2011 03:19:58,not a real question,1,45,4,"1 server many clients I had implemented a server/client Tcp socket in C language, and I want to improve it to one to many relationship  as one server can accept many clients .. 
could you please tell me how to do that in a simple explanation  ",2
9221874,02/10/2012 02:18:34,916315,08/28/2011 10:27:26,26,1,return to libc only working while running via gdb,"I am trying to run a classic return-to-lib execution to spawn a shell.

The vulnerable executable runs properly while running inside gdb, i.e. successfully spawns a shell.

However, if I execute it directly, it gives this error:

    sh: Syntax error: "";"" unexpected

Any ideas what I'm missing?? ASLR and stack-protection has been disabled. There are no errors/warnings during compilation of my attacker and vulnerable programs.

Thanks in advance,
Roy",c,linux,gcc,gdb,libc,02/12/2012 18:49:56,too localized,1,67,9,"return to libc only working while running via gdb I am trying to run a classic return-to-lib execution to spawn a shell.

The vulnerable executable runs properly while running inside gdb, i.e. successfully spawns a shell.

However, if I execute it directly, it gives this error:

    sh: Syntax error: "";"" unexpected

Any ideas what I'm missing?? ASLR and stack-protection has been disabled. There are no errors/warnings during compilation of my attacker and vulnerable programs.

Thanks in advance,
Roy",5
6128638,05/25/2011 17:49:31,771626,05/25/2011 17:49:31,1,0,"C error, need help","I have this final work project that I've been doing the past days, and i am freaking out because the deadline is here and i cant find what is wrong with my code, everything i do gives me ""Segmentation Fault<Core dumped> "" error, however when i compile it doesn't give me any error.
Here's the link to the code bellow:
http://pastebin.com/tqWc6Dd0
And here's the code itself:(however i recommend using the link, and ignore the comments, portuguese gibberish).


#include<stdio.h>
#include<string.h>

typedef struct{
	char nomenavio;
	int codigonavio;
	char tiponavio;
	int tonelagemnavio;
	int anonavio;
	char paisnavio;
	char armadornavio;
}NAVIO;

typedef struct{
	int numportos;
	int milhas;
	int tonelagemtotal;
	int consumototal;
}TOTAL;


///////////////////////////////////////////////////////////&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE MENUS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




int menuprincipal(){
	int controlo=0;
	printf(""\n Ola, escolha a opcao desejada:\n\t1-ADICIONAR NOVO NAVIO\n\t2-CARREGAR FICHEIROS\n\t3-LISTAR\n"");
	scanf(""%d"", &controlo);
	return(controlo);
}



int menulista(){
	int controlomenu;
	printf(""\n LISTAGEM DOS NAVIOS!\n Escolha a opcao que pretende\n \t1-LISTAGEM TOTAL DOS NAVIOS\n\t2-LISTAGEM DOS NAVIOS A PARTIR DE UMA CHAVE\n\t3-LISTAGEM A PARTIR DE UM NOME\n"");
	scanf(""%d"", &controlomenu);
	return(controlomenu);
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE LISTAGEM DOS NAVIOS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void listarnavios(FILE*lista, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		printf(""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);	
	}while(!feof(lista));
}






void anonavios(FILE*lista, int criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(criterio==lstNavio->anonavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}





void armadornavios(FILE*lista, char criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(criterio==lstNavio->armadornavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}		





void tonelagemnavios(FILE*lista, int criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(criterio>=lstNavio->tonelagemnavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}




		
void tiponavios(FILE*lista, char criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(criterio==lstNavio->tiponavio){
			printf(""%c %d %c %d %d %c %c"",lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio,lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}




			
void nomepornavio(FILE*lista, char nomedonavio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(nomedonavio==lstNavio->nomenavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE ADICIONAR REGISTOS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void adicionareg(FILE *lista, FILE *total, NAVIO *lstNavio, TOTAL *lstTotal){
	printf(""\n e depois vim aqui parar!"");
	int tempor;
	tempor=0;
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(tempor<lstNavio->codigonavio){
			tempor=lstNavio->codigonavio;
		}
	}while(!feof(lista));
	tempor++;
	printf(""\nAdicionar registo do navio:"");
	
	printf(""\nInsira o nome do navio"");
	scanf(""%c"",lstNavio->nomenavio);
	
	printf(""\nInsira o tipo do navio"");
	scanf(""%c"",lstNavio->tiponavio);
	
	printf(""\nInsira a tonelagem do navio"");
	scanf(""%d"",&lstNavio->tonelagemnavio);
	
	printf(""\nInsira o ano do navio"");
	scanf(""%d"",&lstNavio->anonavio);
	
	printf(""\nInsira o armador"");
	scanf(""%c"",lstNavio->armadornavio);	
	
	printf(""\nO novo navio vai ter o codigo %d"", tempor);
	
	fprintf(lista,""\n%c %d %c %d %d %c %c"", lstNavio->nomenavio, tempor, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
	
	lstTotal->numportos=0;
	lstTotal->milhas=0;
	lstTotal->tonelagemtotal=0;
	lstTotal->consumototal=0;
	
	fprintf(total, ""\n%d %d %d %d %d"", tempor, lstTotal->numportos, lstTotal->milhas, lstTotal->tonelagemtotal, lstTotal->consumototal);

}
	
	




void carregarnovos(FILE*lista, FILE*total, FILE*novalista, NAVIO*lstNavio, TOTAL*lstTotal){
	int tempor;
	tempor=0;
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(tempor<lstNavio->codigonavio){
			tempor=lstNavio->codigonavio;
		}
	}while(!feof(lista));
	tempor++;
	
	
	lstTotal->numportos=0;
	lstTotal->milhas=0;
	lstTotal->tonelagemtotal=0;
	lstTotal->consumototal=0;
	
	
	do{
		fscanf(novalista,""%c %c %d %d %c %c\n"",lstNavio->nomenavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		fprintf(lista, ""\n%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		fprintf(total, ""\n%d %d %d %d %d"", tempor, lstTotal->numportos, lstTotal->milhas, lstTotal->tonelagemtotal, lstTotal->consumototal);
		tempor++;
		
	}while(!feof(novalista));
	
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCAO MAIN/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


main(){
	
	
	NAVIO *lstNavio[1];
	TOTAL *lstTotal[1];
	
	
	FILE *lista;
	FILE *novalista;
	FILE *total;
	
	int ctrlmenuprincipal, ctrlmenulista;
	int ctrlchave;
	
	char criteriochar[20], nomedonavio[30];
	int criterioint;
	
	char nomenovalista[30];
	
	
	
	ctrlmenuprincipal=menuprincipal();

	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//OPCAO 1 do menu principal, permite ao utilizador inserir um novo registo na lista principal.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if(ctrlmenuprincipal==1){
		lista=fopen(""navios.txt"", ""a+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		total=fopen(""naviosRef.txt"", ""a"");
		if(total==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		adicionareg(lista, total, *lstNavio, *lstTotal);
		fclose(lista);
		fclose(total);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
//OPCAO 2 do menu principal, adicionar a lista principal, os registos que estao na lista novosNavios.txt"".////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	if(ctrlmenuprincipal==2){
		printf(""\nInsira o nome da lista com os novos navios:"");
		scanf(""%c"", nomenovalista);
		lista=fopen(""navios.txt"", ""a+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		total=fopen(""naviosRef.txt"", ""a"");
		if(total==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		novalista=fopen(""novosNavios.txt"", ""r+"");
		if(novalista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}	
		carregarnovos(lista, total, novalista, *lstNavio, *lstTotal);
		fclose(lista);
		fclose(total);
		fclose(novalista);
	}	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//OPCAO 3 do menu principal, listagem de navios, inicia outro menu, que permite ao utilizador escolher o tipo de listagem desejada.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if(ctrlmenuprincipal==3){
		ctrlmenulista=menulista();
		lista=fopen(""navios.txt"", ""r+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		printf(""sera que chego aqui?"");
		if(ctrlmenulista==1){
			printf(""bugabuga"");
			listarnavios(lista, *lstNavio);
		}
		if(ctrlmenulista==2){
			printf(""\nInsira a chave desejada\n\t1-Armador\n\t2-Ano\n\t3-Tipo\n\t4-Tonelagem\n"");
			scanf(""%d"", &ctrlchave);
			printf(""%d"", ctrlchave); 
			if(ctrlchave==1){
				printf(""\nInsira o nome do Armador:"");scanf(""%c\n"",criteriochar);
				armadornavios(lista, *criteriochar, *lstNavio);
			}
			if(ctrlchave==2){
				printf(""\nInsira o Ano:"");scanf(""%d\n"",criterioint);
				anonavios(lista, criterioint, *lstNavio);
			}
			if(ctrlchave==3){
				printf(""\nInsira o tipo da embarcao:"");scanf(""%c\n"",criteriochar);
				tiponavios(lista, *criteriochar, *lstNavio);
			}
			if(ctrlchave==4){
				printf(""\nInsira a tonelagem:"");scanf(""%d\n"",criterioint);
				tonelagemnavios(lista, criterioint, *lstNavio);
			}
		}
		if(ctrlmenulista==3){
			printf(""\nInsira o nome do navio:"");
			scanf(""%c\n"", nomedonavio);
			nomepornavio(lista, *nomedonavio, *lstNavio);
		}
		fclose(lista);	
	}
}

Thanks for your time.",c,,,,,05/25/2011 17:52:02,not a real question,1,572,4,"C error, need help I have this final work project that I've been doing the past days, and i am freaking out because the deadline is here and i cant find what is wrong with my code, everything i do gives me ""Segmentation Fault<Core dumped> "" error, however when i compile it doesn't give me any error.
Here's the link to the code bellow:
http://pastebin.com/tqWc6Dd0
And here's the code itself:(however i recommend using the link, and ignore the comments, portuguese gibberish).


#include<stdio.h>
#include<string.h>

typedef struct{
	char nomenavio;
	int codigonavio;
	char tiponavio;
	int tonelagemnavio;
	int anonavio;
	char paisnavio;
	char armadornavio;
}NAVIO;

typedef struct{
	int numportos;
	int milhas;
	int tonelagemtotal;
	int consumototal;
}TOTAL;


///////////////////////////////////////////////////////////&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE MENUS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




int menuprincipal(){
	int controlo=0;
	printf(""\n Ola, escolha a opcao desejada:\n\t1-ADICIONAR NOVO NAVIO\n\t2-CARREGAR FICHEIROS\n\t3-LISTAR\n"");
	scanf(""%d"", &controlo);
	return(controlo);
}



int menulista(){
	int controlomenu;
	printf(""\n LISTAGEM DOS NAVIOS!\n Escolha a opcao que pretende\n \t1-LISTAGEM TOTAL DOS NAVIOS\n\t2-LISTAGEM DOS NAVIOS A PARTIR DE UMA CHAVE\n\t3-LISTAGEM A PARTIR DE UM NOME\n"");
	scanf(""%d"", &controlomenu);
	return(controlomenu);
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE LISTAGEM DOS NAVIOS/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void listarnavios(FILE*lista, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		printf(""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);	
	}while(!feof(lista));
}






void anonavios(FILE*lista, int criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(criterio==lstNavio->anonavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}





void armadornavios(FILE*lista, char criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(criterio==lstNavio->armadornavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}		





void tonelagemnavios(FILE*lista, int criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(criterio>=lstNavio->tonelagemnavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}




		
void tiponavios(FILE*lista, char criterio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(criterio==lstNavio->tiponavio){
			printf(""%c %d %c %d %d %c %c"",lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio,lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}




			
void nomepornavio(FILE*lista, char nomedonavio, NAVIO*lstNavio){
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(nomedonavio==lstNavio->nomenavio){
			printf(""%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->codigonavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		}	
	}while(!feof(lista));
}





////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCOES DE ADICIONAR REGISTOS//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void adicionareg(FILE *lista, FILE *total, NAVIO *lstNavio, TOTAL *lstTotal){
	printf(""\n e depois vim aqui parar!"");
	int tempor;
	tempor=0;
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, &lstNavio->armadornavio);
		if(tempor<lstNavio->codigonavio){
			tempor=lstNavio->codigonavio;
		}
	}while(!feof(lista));
	tempor++;
	printf(""\nAdicionar registo do navio:"");
	
	printf(""\nInsira o nome do navio"");
	scanf(""%c"",lstNavio->nomenavio);
	
	printf(""\nInsira o tipo do navio"");
	scanf(""%c"",lstNavio->tiponavio);
	
	printf(""\nInsira a tonelagem do navio"");
	scanf(""%d"",&lstNavio->tonelagemnavio);
	
	printf(""\nInsira o ano do navio"");
	scanf(""%d"",&lstNavio->anonavio);
	
	printf(""\nInsira o armador"");
	scanf(""%c"",lstNavio->armadornavio);	
	
	printf(""\nO novo navio vai ter o codigo %d"", tempor);
	
	fprintf(lista,""\n%c %d %c %d %d %c %c"", lstNavio->nomenavio, tempor, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
	
	lstTotal->numportos=0;
	lstTotal->milhas=0;
	lstTotal->tonelagemtotal=0;
	lstTotal->consumototal=0;
	
	fprintf(total, ""\n%d %d %d %d %d"", tempor, lstTotal->numportos, lstTotal->milhas, lstTotal->tonelagemtotal, lstTotal->consumototal);

}
	
	




void carregarnovos(FILE*lista, FILE*total, FILE*novalista, NAVIO*lstNavio, TOTAL*lstTotal){
	int tempor;
	tempor=0;
	do{
		fscanf(lista,""%c %d %c %d %d %c %c\n"", lstNavio->nomenavio, &lstNavio->codigonavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		if(tempor<lstNavio->codigonavio){
			tempor=lstNavio->codigonavio;
		}
	}while(!feof(lista));
	tempor++;
	
	
	lstTotal->numportos=0;
	lstTotal->milhas=0;
	lstTotal->tonelagemtotal=0;
	lstTotal->consumototal=0;
	
	
	do{
		fscanf(novalista,""%c %c %d %d %c %c\n"",lstNavio->nomenavio, lstNavio->tiponavio, &lstNavio->tonelagemnavio, &lstNavio->anonavio, lstNavio->armadornavio);
		fprintf(lista, ""\n%c %d %c %d %d %c %c"", lstNavio->nomenavio, lstNavio->tiponavio, lstNavio->tonelagemnavio, lstNavio->anonavio, lstNavio->armadornavio);
		fprintf(total, ""\n%d %d %d %d %d"", tempor, lstTotal->numportos, lstTotal->milhas, lstTotal->tonelagemtotal, lstTotal->consumototal);
		tempor++;
		
	}while(!feof(novalista));
	
}






////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//FUNCAO MAIN/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


main(){
	
	
	NAVIO *lstNavio[1];
	TOTAL *lstTotal[1];
	
	
	FILE *lista;
	FILE *novalista;
	FILE *total;
	
	int ctrlmenuprincipal, ctrlmenulista;
	int ctrlchave;
	
	char criteriochar[20], nomedonavio[30];
	int criterioint;
	
	char nomenovalista[30];
	
	
	
	ctrlmenuprincipal=menuprincipal();

	
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//OPCAO 1 do menu principal, permite ao utilizador inserir um novo registo na lista principal.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if(ctrlmenuprincipal==1){
		lista=fopen(""navios.txt"", ""a+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		total=fopen(""naviosRef.txt"", ""a"");
		if(total==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		adicionareg(lista, total, *lstNavio, *lstTotal);
		fclose(lista);
		fclose(total);
	}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
//OPCAO 2 do menu principal, adicionar a lista principal, os registos que estao na lista novosNavios.txt"".////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	

	if(ctrlmenuprincipal==2){
		printf(""\nInsira o nome da lista com os novos navios:"");
		scanf(""%c"", nomenovalista);
		lista=fopen(""navios.txt"", ""a+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		total=fopen(""naviosRef.txt"", ""a"");
		if(total==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		novalista=fopen(""novosNavios.txt"", ""r+"");
		if(novalista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}	
		carregarnovos(lista, total, novalista, *lstNavio, *lstTotal);
		fclose(lista);
		fclose(total);
		fclose(novalista);
	}	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//OPCAO 3 do menu principal, listagem de navios, inicia outro menu, que permite ao utilizador escolher o tipo de listagem desejada.////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	if(ctrlmenuprincipal==3){
		ctrlmenulista=menulista();
		lista=fopen(""navios.txt"", ""r+"");
		if(lista==NULL){
			printf(""Erro na abertura do ficheiro"");
			exit(1);
		}
		printf(""sera que chego aqui?"");
		if(ctrlmenulista==1){
			printf(""bugabuga"");
			listarnavios(lista, *lstNavio);
		}
		if(ctrlmenulista==2){
			printf(""\nInsira a chave desejada\n\t1-Armador\n\t2-Ano\n\t3-Tipo\n\t4-Tonelagem\n"");
			scanf(""%d"", &ctrlchave);
			printf(""%d"", ctrlchave); 
			if(ctrlchave==1){
				printf(""\nInsira o nome do Armador:"");scanf(""%c\n"",criteriochar);
				armadornavios(lista, *criteriochar, *lstNavio);
			}
			if(ctrlchave==2){
				printf(""\nInsira o Ano:"");scanf(""%d\n"",criterioint);
				anonavios(lista, criterioint, *lstNavio);
			}
			if(ctrlchave==3){
				printf(""\nInsira o tipo da embarcao:"");scanf(""%c\n"",criteriochar);
				tiponavios(lista, *criteriochar, *lstNavio);
			}
			if(ctrlchave==4){
				printf(""\nInsira a tonelagem:"");scanf(""%d\n"",criterioint);
				tonelagemnavios(lista, criterioint, *lstNavio);
			}
		}
		if(ctrlmenulista==3){
			printf(""\nInsira o nome do navio:"");
			scanf(""%c\n"", nomedonavio);
			nomepornavio(lista, *nomedonavio, *lstNavio);
		}
		fclose(lista);	
	}
}

Thanks for your time.",1
9425740,02/24/2012 05:13:50,1089679,12/09/2011 12:08:53,311,2,Guide me in this Confusion ( file Verification with CRC16 in C),"here i have confusion in output of CRC16.

Here first i used only one function which using `char readChar` and counts CRC16 of any type of file but in `.tar or .tar.gz` files i got some problem regarding `EOF` and in my previous question some one suggested me use `int` instead of `char` in `declartion of readChar`.

So After this i got solution of `EOF` in while loop and its read proper bytes.

Than After here i put two methods for calculating CRC16.
In first one i used `int readChar` and in second one i used `char readChar.`
So i got different out for same file this problem i am getting in `.tar and .tar.gz` files only. In simple `.txt` files this both methods gives same result.

Here i put my both program's code and output

**int datatype program**


    #include <stdio.h>
    #include <string.h>
    #include <sys/time.h>
    int CRC16_(const char* filePath);
    int CRC16_(const char* filePath) {
    
    	unsigned int filesize;
    	unsigned int j;
    
    	//Declare variable to store CRC result.
    	unsigned short result;
    	//Declare loop variables.
    	int intOuterLoopIndex, intInnerLoopIndex, nLen;
    
    	result = 0xffff; //initialize result variable to perform CRC checksum calculation.
    	//Create file pointer to open and read file.
    	FILE *readFile;
    
    	//Use to read character from file.
    	int readChar;
    
    	//open a file for Reading
    	readFile = fopen(filePath, ""rb"");
    
    	//Checking file is able to open or exists.
    	if (!readFile) {
    		fputs(""Unable to open file %s"", stderr);
    	}
    	printf(""\nSize of File is %u"", filesize);
    
    	/*
    	 Here reading file and store into variable.
    	 */
    	int chCnt = 0;
    	while ((readChar = getc(readFile)) != EOF) {
    		result ^= (short) (readChar);
    		for (intInnerLoopIndex = 0; intInnerLoopIndex < 8; intInnerLoopIndex++) {
    			if ((result & 0x0001) == 0x0001) {
    				result = result >> 1; //Perform bit shifting.
    				result = result ^ 0xa001; //Perform XOR operation on result.
    			} else {
    				result = result >> 1; //Perform bit shifting.
    			}
    		}
    		chCnt++;
    	}
    	printf(""\nCRC data length in file: %d"", chCnt);
    	//This is final CRC value for provided message.
    	return (result);
    }
    
    int main() {
    	int crc, i;
    	float elapsed = 0;
    	struct timeval td_start, td_end;
    	if (gettimeofday(&td_start, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    	crc = CRC16_(""/home/test/main/CRC16/fileworking.tar"");
    	if (gettimeofday(&td_end, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    	elapsed = 1000000.0 * (td_end.tv_sec - td_start.tv_sec);
    	elapsed += (td_end.tv_usec - td_start.tv_usec);
    	printf(""\nTime elapsed is %g microseconds"", elapsed);
    	printf(""\n Calculated CRC is: %x : \n"", crc);
    
    	return 0;
    }

char datatype program :

    #include <stdio.h>
    #include <string.h>
    #include <sys/time.h>
    #include <sys/stat.h>
    
    int CRC16_(const char* filePath);
    
    
    int CRC16_(const char* filePath) {
    
    	unsigned int filesize;
    	unsigned int j;
    
    	//Declare variable to store CRC result.
    	unsigned short result;
    	//Declare loop variables.
    	int intOuterLoopIndex, intInnerLoopIndex, nLen;
    	result = 0xffff; //initialize result variable to perform CRC checksum calculation.
    
    	//Create file pointer to open and read file.
    	FILE *readFile;
    
    	//Use to read character from file.
    	char readChar;
    
    	//open a file for Reading
    	readFile = fopen(filePath, ""rb"");
    
    	//Checking file is able to open or exists.
    	if (!readFile) {
    		fputs(""Unable to open file %s"", stderr);
    	}
    	fseek(readFile, 0, SEEK_END); // seek to end of file
    	filesize = ftell(readFile); // get current file pointer
    	fseek(readFile, 0, SEEK_SET); // seek back to beginning of file
    	// proceed with allocating memory and reading the file
    
    	printf(""\nSize of File is %u"", filesize);
    
    	/*
    	 Here reading file and store into variable.
    	 */
    	int chCnt = 0;
    
    	for (j = 0; j < filesize; j++) {
    		readChar = getc(readFile);
    		//printf(""charcater is %c\n and int is %d"",readChar,readChar);
    
    		result ^= (short) (readChar);
    		for (intInnerLoopIndex = 0; intInnerLoopIndex < 8; intInnerLoopIndex++) {
    			if ((result & 0x0001) == 0x0001) {
    				result = result >> 1; //Perform bit shifting.
    				result = result ^ 0xa001; //Perform XOR operation on result.
    			} else {
    				result = result >> 1; //Perform bit shifting.
    			}
    		}
    
    		//content[chCnt] = readChar;
    		chCnt++;
    	}
    	printf(""\nCRC data length in file: %d"", chCnt);
    	//This is final CRC value for provided message.
    	return (result);
    }
    
    int main() {
    	int crc, i;
    
    	float elapsed = 0;
    	struct timeval td_start, td_end;
    
    	if (gettimeofday(&td_start, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    
    	crc = CRC16_(""/home/test/main/CRC16/fileworking.tar"");
    
    	if (gettimeofday(&td_end, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    
    	elapsed = 1000000.0 * (td_end.tv_sec - td_start.tv_sec);
    	elapsed += (td_end.tv_usec - td_start.tv_usec);
    	printf(""\nTime elapsed is %g microseconds"", elapsed);
    
    	printf(""\n Calculated CRC is: %x : \n"", crc);
    
    	return 0;
    }


Here in both case same number of bytes read and same number of loop repeated. only change is char and int datatype of readChar.

So whats problem in this datatype. its not do problem in simple any large txt file.

So can any one tell me the proper solution of this which is correct method for calculating CRC16 for any type of file.

OutPut : 

    ./int
    Size of File is 401213440
    CRC data length in file: 401213440
    Time elapsed is 2.77867e+07 microseconds
     Calculated CRC is: ef57 : 
     ./char
     Size of File is 401213440
    CRC data length in file: 401213440
    Time elapsed is 2.82405e+07 microseconds
     Calculated CRC is: 4bc :

Please Help to figure out this problem

",c,embedded,crc,,,,open,0,1363,12,"Guide me in this Confusion ( file Verification with CRC16 in C) here i have confusion in output of CRC16.

Here first i used only one function which using `char readChar` and counts CRC16 of any type of file but in `.tar or .tar.gz` files i got some problem regarding `EOF` and in my previous question some one suggested me use `int` instead of `char` in `declartion of readChar`.

So After this i got solution of `EOF` in while loop and its read proper bytes.

Than After here i put two methods for calculating CRC16.
In first one i used `int readChar` and in second one i used `char readChar.`
So i got different out for same file this problem i am getting in `.tar and .tar.gz` files only. In simple `.txt` files this both methods gives same result.

Here i put my both program's code and output

**int datatype program**


    #include <stdio.h>
    #include <string.h>
    #include <sys/time.h>
    int CRC16_(const char* filePath);
    int CRC16_(const char* filePath) {
    
    	unsigned int filesize;
    	unsigned int j;
    
    	//Declare variable to store CRC result.
    	unsigned short result;
    	//Declare loop variables.
    	int intOuterLoopIndex, intInnerLoopIndex, nLen;
    
    	result = 0xffff; //initialize result variable to perform CRC checksum calculation.
    	//Create file pointer to open and read file.
    	FILE *readFile;
    
    	//Use to read character from file.
    	int readChar;
    
    	//open a file for Reading
    	readFile = fopen(filePath, ""rb"");
    
    	//Checking file is able to open or exists.
    	if (!readFile) {
    		fputs(""Unable to open file %s"", stderr);
    	}
    	printf(""\nSize of File is %u"", filesize);
    
    	/*
    	 Here reading file and store into variable.
    	 */
    	int chCnt = 0;
    	while ((readChar = getc(readFile)) != EOF) {
    		result ^= (short) (readChar);
    		for (intInnerLoopIndex = 0; intInnerLoopIndex < 8; intInnerLoopIndex++) {
    			if ((result & 0x0001) == 0x0001) {
    				result = result >> 1; //Perform bit shifting.
    				result = result ^ 0xa001; //Perform XOR operation on result.
    			} else {
    				result = result >> 1; //Perform bit shifting.
    			}
    		}
    		chCnt++;
    	}
    	printf(""\nCRC data length in file: %d"", chCnt);
    	//This is final CRC value for provided message.
    	return (result);
    }
    
    int main() {
    	int crc, i;
    	float elapsed = 0;
    	struct timeval td_start, td_end;
    	if (gettimeofday(&td_start, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    	crc = CRC16_(""/home/test/main/CRC16/fileworking.tar"");
    	if (gettimeofday(&td_end, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    	elapsed = 1000000.0 * (td_end.tv_sec - td_start.tv_sec);
    	elapsed += (td_end.tv_usec - td_start.tv_usec);
    	printf(""\nTime elapsed is %g microseconds"", elapsed);
    	printf(""\n Calculated CRC is: %x : \n"", crc);
    
    	return 0;
    }

char datatype program :

    #include <stdio.h>
    #include <string.h>
    #include <sys/time.h>
    #include <sys/stat.h>
    
    int CRC16_(const char* filePath);
    
    
    int CRC16_(const char* filePath) {
    
    	unsigned int filesize;
    	unsigned int j;
    
    	//Declare variable to store CRC result.
    	unsigned short result;
    	//Declare loop variables.
    	int intOuterLoopIndex, intInnerLoopIndex, nLen;
    	result = 0xffff; //initialize result variable to perform CRC checksum calculation.
    
    	//Create file pointer to open and read file.
    	FILE *readFile;
    
    	//Use to read character from file.
    	char readChar;
    
    	//open a file for Reading
    	readFile = fopen(filePath, ""rb"");
    
    	//Checking file is able to open or exists.
    	if (!readFile) {
    		fputs(""Unable to open file %s"", stderr);
    	}
    	fseek(readFile, 0, SEEK_END); // seek to end of file
    	filesize = ftell(readFile); // get current file pointer
    	fseek(readFile, 0, SEEK_SET); // seek back to beginning of file
    	// proceed with allocating memory and reading the file
    
    	printf(""\nSize of File is %u"", filesize);
    
    	/*
    	 Here reading file and store into variable.
    	 */
    	int chCnt = 0;
    
    	for (j = 0; j < filesize; j++) {
    		readChar = getc(readFile);
    		//printf(""charcater is %c\n and int is %d"",readChar,readChar);
    
    		result ^= (short) (readChar);
    		for (intInnerLoopIndex = 0; intInnerLoopIndex < 8; intInnerLoopIndex++) {
    			if ((result & 0x0001) == 0x0001) {
    				result = result >> 1; //Perform bit shifting.
    				result = result ^ 0xa001; //Perform XOR operation on result.
    			} else {
    				result = result >> 1; //Perform bit shifting.
    			}
    		}
    
    		//content[chCnt] = readChar;
    		chCnt++;
    	}
    	printf(""\nCRC data length in file: %d"", chCnt);
    	//This is final CRC value for provided message.
    	return (result);
    }
    
    int main() {
    	int crc, i;
    
    	float elapsed = 0;
    	struct timeval td_start, td_end;
    
    	if (gettimeofday(&td_start, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    
    	crc = CRC16_(""/home/test/main/CRC16/fileworking.tar"");
    
    	if (gettimeofday(&td_end, NULL)) {
    		printf(""time failed\n"");
    		exit(1);
    	}
    
    	elapsed = 1000000.0 * (td_end.tv_sec - td_start.tv_sec);
    	elapsed += (td_end.tv_usec - td_start.tv_usec);
    	printf(""\nTime elapsed is %g microseconds"", elapsed);
    
    	printf(""\n Calculated CRC is: %x : \n"", crc);
    
    	return 0;
    }


Here in both case same number of bytes read and same number of loop repeated. only change is char and int datatype of readChar.

So whats problem in this datatype. its not do problem in simple any large txt file.

So can any one tell me the proper solution of this which is correct method for calculating CRC16 for any type of file.

OutPut : 

    ./int
    Size of File is 401213440
    CRC data length in file: 401213440
    Time elapsed is 2.77867e+07 microseconds
     Calculated CRC is: ef57 : 
     ./char
     Size of File is 401213440
    CRC data length in file: 401213440
    Time elapsed is 2.82405e+07 microseconds
     Calculated CRC is: 4bc :

Please Help to figure out this problem

",3
11602680,07/22/2012 18:00:37,986437,10/09/2011 14:31:13,47,0,whats the sense of this code?,"
void f(int **m, int w, int h )  
{       
int i,j;
  
    for(i=0;i < w ; i++)  
    {    
      for(j=0;j<h;j++)
      {
         printf(""%5d"", m[i][j]); //  *( *(m + i) + j ) ??
      }

	printf(""\n"");
    }
    return;
}

this code is tryng to print a 2d matrix
but I've a seg fault.
",c,,,,,07/22/2012 20:09:33,not constructive,1,96,6,"whats the sense of this code? 
void f(int **m, int w, int h )  
{       
int i,j;
  
    for(i=0;i < w ; i++)  
    {    
      for(j=0;j<h;j++)
      {
         printf(""%5d"", m[i][j]); //  *( *(m + i) + j ) ??
      }

	printf(""\n"");
    }
    return;
}

this code is tryng to print a 2d matrix
but I've a seg fault.
",1
8890154,01/17/2012 05:34:14,115781,06/02/2009 05:09:30,1759,7,Looking for fast sorted integer array intersection/union algorithms implemented in C,"I am looking for C programs that implement fast sorted integer array intersection/union algorithms. the fast the better, thanks~",c,algorithm,union,intersection,,01/17/2012 12:13:15,not a real question,1,19,11,"Looking for fast sorted integer array intersection/union algorithms implemented in C I am looking for C programs that implement fast sorted integer array intersection/union algorithms. the fast the better, thanks~",4
8372636,12/04/2011 01:51:42,1079629,12/04/2011 01:49:35,1,0,Create matrix of strings in C,"I was thinking about this:

    typedef char *string;
    
    string matrix[100][100];
    
    void init(string input[][]);


but it's not working. Anyone has any ideas how to do this?",c,string,matrix,,,12/04/2011 06:41:50,not a real question,1,41,6,"Create matrix of strings in C I was thinking about this:

    typedef char *string;
    
    string matrix[100][100];
    
    void init(string input[][]);


but it's not working. Anyone has any ideas how to do this?",3
9747749,03/17/2012 06:12:57,115781,06/02/2009 05:09:30,2204,7,How to reduce overhead in my C program?,"I am using C on linux, and my program is both of high CPU-density an I/O-density. Using time command shows that my program having much overhead:

    real	1m4.639s
    user	0m53.929s
    sys	        0m9.747s

Is that possible to find out what costs 'sys	0m9.747s' and reduce it?

=================================================

Excuse me if this question isn't easy to answer without the code, but my code is too long to be posted here. So any tips or clues will also do. Thank you",c,linux,optimization,,,03/18/2012 12:41:15,not a real question,1,88,8,"How to reduce overhead in my C program? I am using C on linux, and my program is both of high CPU-density an I/O-density. Using time command shows that my program having much overhead:

    real	1m4.639s
    user	0m53.929s
    sys	        0m9.747s

Is that possible to find out what costs 'sys	0m9.747s' and reduce it?

=================================================

Excuse me if this question isn't easy to answer without the code, but my code is too long to be posted here. So any tips or clues will also do. Thank you",3
7244982,08/30/2011 14:38:54,919875,08/30/2011 14:10:48,1,0,Find out the error in following block of code,"Find out the error in following block of code.

If (x = 100)

    Cout << x is 100;
",c,,,,,08/30/2011 14:41:51,not a real question,1,20,9,"Find out the error in following block of code Find out the error in following block of code.

If (x = 100)

    Cout << x is 100;
",1
10368305,04/28/2012 23:01:47,405030,07/28/2010 20:58:05,737,15,How to test POSIX compatibility?,"I am writing a C program with POSIX API and using Linux.
I compiled and ran it on a friend's Mac OSX PC and there was a small error, but I did not use Linux specific features.

I will use some specific features that Linux adds to the API. I will also use specific POSIX extensions for Mac Os X and FreeBSD.  
I will use conditional compilation to choose the code. If the OS is none of those, I will use generic POSIX code.

I do not own Darwin/Mac OSX and FreeBSD, Linux is the only OS that I have in my PC. I cannot download and install FreeBSD, because it is more than 500 MB.  
I want to know a way to test if the program will compile and behave as expected on other POSIX systems.  
I wonder if there is a POSIX simulator and compiler to do tests.  
The tests are simple, they do not use GUI and drivers, they are only command line.

I will need to do 3 tests: FreeBSD, Mac OSX/Darwin and Generic POSIX, but I do not have the tools.

",c,linux,testing,posix,compatibility,,open,0,186,5,"How to test POSIX compatibility? I am writing a C program with POSIX API and using Linux.
I compiled and ran it on a friend's Mac OSX PC and there was a small error, but I did not use Linux specific features.

I will use some specific features that Linux adds to the API. I will also use specific POSIX extensions for Mac Os X and FreeBSD.  
I will use conditional compilation to choose the code. If the OS is none of those, I will use generic POSIX code.

I do not own Darwin/Mac OSX and FreeBSD, Linux is the only OS that I have in my PC. I cannot download and install FreeBSD, because it is more than 500 MB.  
I want to know a way to test if the program will compile and behave as expected on other POSIX systems.  
I wonder if there is a POSIX simulator and compiler to do tests.  
The tests are simple, they do not use GUI and drivers, they are only command line.

I will need to do 3 tests: FreeBSD, Mac OSX/Darwin and Generic POSIX, but I do not have the tools.

",5
7102508,08/18/2011 04:46:49,894432,08/15/2011 02:40:22,1,0,what code can be used to fill a two-dimensional array?,"This is what I have started, please help me improve my code,

    #include<stdio.h>
    int main() {
      char input[3][3];
      int x,y;
      printf(""Enter arbitrary list of integers:"");
      scanf(""%s"",input);   (is this the right way to use scanf in strings??)
  
      for (x=0;x<3;x++){
          for (y=0;y<3;y++)
              input[x][y]=______;   (what can i use to fill the array using the string entered by the user (e.g numbers entered are 123456789)?)
      }
   
    Thanks!! ",c,arrays,string,multidimensional-array,for-loop,08/18/2011 08:47:21,not a real question,1,134,10,"what code can be used to fill a two-dimensional array? This is what I have started, please help me improve my code,

    #include<stdio.h>
    int main() {
      char input[3][3];
      int x,y;
      printf(""Enter arbitrary list of integers:"");
      scanf(""%s"",input);   (is this the right way to use scanf in strings??)
  
      for (x=0;x<3;x++){
          for (y=0;y<3;y++)
              input[x][y]=______;   (what can i use to fill the array using the string entered by the user (e.g numbers entered are 123456789)?)
      }
   
    Thanks!! ",5
5162641,03/02/2011 02:02:41,640425,03/02/2011 02:02:41,1,0,Pathagorean Theorem Program in C,"    #include <stdio.h>
    
    float function (float x, float y);
    float function2 (float x, float z);
    float function3 (float y, float z);
    
    float main()
    
    {
    	float x;
    	float y;
    	float z; 
    	
    	{
    	
    	printf(""Please insert length of adjacent side"");
    	scanf(""%f"", &x); 
    	
    	printf(""Please insert length of opposite side"");
    	scanf(""%f"", &y); 
    	
    	printf(""Please insert length of the hypotenuse"");
    	scanf(""%f"", &z);
    	
    
    	}
    	
    	{
    	
    	if (z = 0){
    		printf(""The length of the hypotenuse is %f"",  function (x, y));}
    	
    	else if (y = 0){ 
    		printf(""The length of the opposite side is %f"",  function2(x, z));} 
    	
    	else if (x=0){
    		printf(""The length of the adjacent side is %f"",  function3(y, z));} 
    		
    	}
    	
    }
    
    
    float function(float x, float y) {
    	
    	return(sqrt(((x*x)+(y*y))));
    	
    }
    
    float function2(float x, float z) {
    	
    	return(sqrt(((z*z)-(x*x))));
    	
    }
    
    float function3(float y, float z){
    	
    	return(sqrt(((z*z)-(y*y))));
    	
    }


This is the code that I have to figure out the missing side of a right triangle. The input for the side that you do not know is 0. When I run the program it asks me for all the sides but then it does not go on and give me the answer...Could anyone please explain this?
Thanks

",c,triangle,,,,,open,0,394,5,"Pathagorean Theorem Program in C     #include <stdio.h>
    
    float function (float x, float y);
    float function2 (float x, float z);
    float function3 (float y, float z);
    
    float main()
    
    {
    	float x;
    	float y;
    	float z; 
    	
    	{
    	
    	printf(""Please insert length of adjacent side"");
    	scanf(""%f"", &x); 
    	
    	printf(""Please insert length of opposite side"");
    	scanf(""%f"", &y); 
    	
    	printf(""Please insert length of the hypotenuse"");
    	scanf(""%f"", &z);
    	
    
    	}
    	
    	{
    	
    	if (z = 0){
    		printf(""The length of the hypotenuse is %f"",  function (x, y));}
    	
    	else if (y = 0){ 
    		printf(""The length of the opposite side is %f"",  function2(x, z));} 
    	
    	else if (x=0){
    		printf(""The length of the adjacent side is %f"",  function3(y, z));} 
    		
    	}
    	
    }
    
    
    float function(float x, float y) {
    	
    	return(sqrt(((x*x)+(y*y))));
    	
    }
    
    float function2(float x, float z) {
    	
    	return(sqrt(((z*z)-(x*x))));
    	
    }
    
    float function3(float y, float z){
    	
    	return(sqrt(((z*z)-(y*y))));
    	
    }


This is the code that I have to figure out the missing side of a right triangle. The input for the side that you do not know is 0. When I run the program it asks me for all the sides but then it does not go on and give me the answer...Could anyone please explain this?
Thanks

",2
2048854,01/12/2010 12:25:22,248865,01/12/2010 12:18:08,1,0,C interview question,"A friend of mine was asked the following question a Yahoo interview:

*Given a string of the form ""abbccc"" print ""a1b2c3"". Write a function that takes a string and return a string. Take care of all special cases.*

How would you experts code it?

Thanks a lot",c,,,,,12/01/2011 18:07:41,not constructive,1,44,3,"C interview question A friend of mine was asked the following question a Yahoo interview:

*Given a string of the form ""abbccc"" print ""a1b2c3"". Write a function that takes a string and return a string. Take care of all special cases.*

How would you experts code it?

Thanks a lot",1
4107102,11/05/2010 14:59:33,318747,04/16/2010 17:33:16,493,3,Is this busy waiting?,"Is this loop busy waiting, I would think the wait call takes care of that. If it is, how can it be fixed to not busy wait?

    id = fork();
    for (i = 0; i < 20; i++)
    {
        switch (id)
        {
                 case 0:
                    /* do stuff with child */
                    exit(0);
                 default:
                 {
                     if (children>=3) {
                         int s;
                         wait(&s);
                         children--;
                     }
                     children++;
                     id = fork();
                 }
        }
    }

",c,,,,,,open,0,355,4,"Is this busy waiting? Is this loop busy waiting, I would think the wait call takes care of that. If it is, how can it be fixed to not busy wait?

    id = fork();
    for (i = 0; i < 20; i++)
    {
        switch (id)
        {
                 case 0:
                    /* do stuff with child */
                    exit(0);
                 default:
                 {
                     if (children>=3) {
                         int s;
                         wait(&s);
                         children--;
                     }
                     children++;
                     id = fork();
                 }
        }
    }

",1
11660725,07/26/2012 00:32:12,1386923,05/10/2012 11:17:14,30,0,Define boolean type absent in ANSI C ISO/IEC-9899:1990 in Visual Studio 2012 RC,"    typedef char bool;

doesn't work. Reason I assume is that bool is one of the reserved keywords in Microsoft Visual C/C++. Since I need boolean type of literal name as exact ""bool"" (That means, type names other than bool, such as 

    boolean
    BOOLEAN
    BOOL
    Bool
    ...

**are not allowed**), is there a compiling option perhaps I can use to override the keyword ""bool"" which is **NOT** in ANSI C(ISO/IEC-9899:1990) Microsoft Visual C/C++ complies with?

NB: THIS IS NOT ABOUT C++ or VISUAL C++ AT ALL. IT'S ABOUT PROGRAMMING IN ANSI C 90 WITH MSVC COMPILER IN COMPATIBLE MODE.

Thanks in advance.",c,visual-studio,visual-c++,,,,open,0,117,13,"Define boolean type absent in ANSI C ISO/IEC-9899:1990 in Visual Studio 2012 RC     typedef char bool;

doesn't work. Reason I assume is that bool is one of the reserved keywords in Microsoft Visual C/C++. Since I need boolean type of literal name as exact ""bool"" (That means, type names other than bool, such as 

    boolean
    BOOLEAN
    BOOL
    Bool
    ...

**are not allowed**), is there a compiling option perhaps I can use to override the keyword ""bool"" which is **NOT** in ANSI C(ISO/IEC-9899:1990) Microsoft Visual C/C++ complies with?

NB: THIS IS NOT ABOUT C++ or VISUAL C++ AT ALL. IT'S ABOUT PROGRAMMING IN ANSI C 90 WITH MSVC COMPILER IN COMPATIBLE MODE.

Thanks in advance.",3
9839871,03/23/2012 13:15:42,1288243,03/23/2012 12:33:22,1,0,I am getting Segmentation fault 49 in c ARM7,"I am getting Segmentation fault 49 in c ARM7 which is developed in ARM5. In netbeans it working fine but in 92pos it gets error.

Below is the code I am using.


>writting into the file>>>>

    #include<header.h>

    void filewriting(void) {
    int length;

    int i = 0;
    char temp[20];
    fp_temp_prod = fopen(""rawproduct.txt"", ""w"");


    strcpy(temp, ""THUMBSUP^TU200^12^Y\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);

    strcpy(temp, ""COKE^ko100^12^Y\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp2 = %s"", temp);

    strcpy(temp, ""KINLEY^KI900^12^N\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);

    strcpy(temp, ""SPRITE^SP500^12^N\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);
    
    fseek(fp_temp_prod, 0L, SEEK_END);
    length = ftell(fp_temp_prod);
    printf(""\nlength == %dBytes\n"", length);
   
    fclose(fp_temp_prod);
    list_recordes();
    }

>read from the same file>>>>

    void list_recordes() {

    char raw[60];
    char temp[500];
    int lp_count;
    int x = 0, i, tempi = 0;

    fp_temp_prod = fopen(""rawproduct.txt"", ""r"");
    printf(""LR55555555555555555555555555\n"");
    sprintf(raw, ""NULL"");    
    while (i < 50) {
        temp[i] = '\0';
        i++;
    }
    printf(""i = %d"", i);
    while (fgets(raw, 60, fp_temp_prod) != '\0') {
        for (lp_count = 0; lp_count < 60; lp_count++) {
            if (raw[lp_count] != '\n') {
                if (raw[lp_count] != '^') {
                    temp[tempi] = raw[lp_count];
                    tempi++;
                } else {
                    if (x == 0) {
                        strcpy(rawprod[stokcount].name, temp);
                        printf(""product name = %s\n"", &rawprod[stokcount].name);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 1;
                        tempi = 0;
                    } else if (x == 1) {
                        strcpy(rawprod[stokcount].code, temp);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 2;
                        tempi = 0;
                        printf(""product code = %s\n"", &rawprod[stokcount].code);
                    } else if (x == 2) {
                        rawprod[stokcount].price = atoi(temp);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 3;
                        tempi = 0;
                        printf(""product price = %s\n"",&temp);
                    }
                }
            } else {
                strcpy(rawprod[stokcount].scheme, temp);
                i = 0;
                while (temp[i] != '\0') {
                    temp[i] = '\0';
                    i++;
                }
                x = 4;
                tempi = 0;
                printf(""product scheme = %s\n"", &rawprod[stokcount].scheme);
                break;
            }
        }
        x = 0;
        stokcount++;
        sprintf(raw, ""NULL"");
    printf(""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"");
    //printf(""\n%s"", raw);
    }
    fclose(fp_temp_prod);
    printf(""END\n"");
    }
",c,,,,,03/23/2012 13:18:19,not a real question,1,1495,9,"I am getting Segmentation fault 49 in c ARM7 I am getting Segmentation fault 49 in c ARM7 which is developed in ARM5. In netbeans it working fine but in 92pos it gets error.

Below is the code I am using.


>writting into the file>>>>

    #include<header.h>

    void filewriting(void) {
    int length;

    int i = 0;
    char temp[20];
    fp_temp_prod = fopen(""rawproduct.txt"", ""w"");


    strcpy(temp, ""THUMBSUP^TU200^12^Y\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);

    strcpy(temp, ""COKE^ko100^12^Y\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp2 = %s"", temp);

    strcpy(temp, ""KINLEY^KI900^12^N\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);

    strcpy(temp, ""SPRITE^SP500^12^N\n"");
    fputs(temp, fp_temp_prod);
    printf(""\ntemp1 = %s"", temp);
    
    fseek(fp_temp_prod, 0L, SEEK_END);
    length = ftell(fp_temp_prod);
    printf(""\nlength == %dBytes\n"", length);
   
    fclose(fp_temp_prod);
    list_recordes();
    }

>read from the same file>>>>

    void list_recordes() {

    char raw[60];
    char temp[500];
    int lp_count;
    int x = 0, i, tempi = 0;

    fp_temp_prod = fopen(""rawproduct.txt"", ""r"");
    printf(""LR55555555555555555555555555\n"");
    sprintf(raw, ""NULL"");    
    while (i < 50) {
        temp[i] = '\0';
        i++;
    }
    printf(""i = %d"", i);
    while (fgets(raw, 60, fp_temp_prod) != '\0') {
        for (lp_count = 0; lp_count < 60; lp_count++) {
            if (raw[lp_count] != '\n') {
                if (raw[lp_count] != '^') {
                    temp[tempi] = raw[lp_count];
                    tempi++;
                } else {
                    if (x == 0) {
                        strcpy(rawprod[stokcount].name, temp);
                        printf(""product name = %s\n"", &rawprod[stokcount].name);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 1;
                        tempi = 0;
                    } else if (x == 1) {
                        strcpy(rawprod[stokcount].code, temp);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 2;
                        tempi = 0;
                        printf(""product code = %s\n"", &rawprod[stokcount].code);
                    } else if (x == 2) {
                        rawprod[stokcount].price = atoi(temp);
                        i = 0;
                        while (temp[i] != '\0') {
                            temp[i] = '\0';
                            i++;
                        }
                        x = 3;
                        tempi = 0;
                        printf(""product price = %s\n"",&temp);
                    }
                }
            } else {
                strcpy(rawprod[stokcount].scheme, temp);
                i = 0;
                while (temp[i] != '\0') {
                    temp[i] = '\0';
                    i++;
                }
                x = 4;
                tempi = 0;
                printf(""product scheme = %s\n"", &rawprod[stokcount].scheme);
                break;
            }
        }
        x = 0;
        stokcount++;
        sprintf(raw, ""NULL"");
    printf(""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n"");
    //printf(""\n%s"", raw);
    }
    fclose(fp_temp_prod);
    printf(""END\n"");
    }
",1
4993295,02/14/2011 14:26:37,616339,02/14/2011 14:16:48,1,0,what a simple main could be for those functions??(a list of tables problem),"stack.h:
#ifndef __STACK_H_INCLUDED__
#define __STACK_H_INCLUDED__


	typedef struct snode{
		int data[maxsize];
		int top;
		struct snode *next;
		}anode;

	typedef struct sstack{
		anode *start;
		}sstack;

void MakeEmpty(struct hstack s)void MakeEmpty(struct hstack s);

int IsEmpty(hstack s);

int TopNode(hstack s);

void Push(hstack s,int x);

void Pop(hstack s);



#endif

stack.c:

include stdio.h
include stdlib.h


	void MakeEmpty( sstack *s){
		s->start = NULL;
		}

	int IsEmpty( sstack s){
		if((s->start)==NULL)
		return TRUE;
		return FALSE;
		}
	
	int TopNode( sstack s){
		if (!IsEmpty(s)){
		anode *a = s->start;
		return (a->data[a->(top 1)]);
				}
		else
		printf(""error"");
		
		return -1;
				}
		
	void Push( sstack *s,int x){
		anode *a=s->start;
		if (IsEmpty || a->top == maxsize ) {
		anode *k = (anode*)malloc(sizeof(anode));
		k->top = 0;
		k->next = a;
		s->start = m;
		}
		n=s->start;
		n->block[n->top] = x;
		n->top = n->top +1;
		}

	void Pop( hstack s){
		
		n=s->start;
		x= n->block[n->top-1];
		n->top = n->top -1;
		if (n->top==0){
		s->start= n->next;
		free(n);
		return x;
		}
		else{
		printf(""error "");
		return -1;
		}
		}
",c,list,struct,stack,node,02/14/2011 14:51:07,not a real question,1,87,13,"what a simple main could be for those functions??(a list of tables problem) stack.h:
#ifndef __STACK_H_INCLUDED__
#define __STACK_H_INCLUDED__


	typedef struct snode{
		int data[maxsize];
		int top;
		struct snode *next;
		}anode;

	typedef struct sstack{
		anode *start;
		}sstack;

void MakeEmpty(struct hstack s)void MakeEmpty(struct hstack s);

int IsEmpty(hstack s);

int TopNode(hstack s);

void Push(hstack s,int x);

void Pop(hstack s);



#endif

stack.c:

include stdio.h
include stdlib.h


	void MakeEmpty( sstack *s){
		s->start = NULL;
		}

	int IsEmpty( sstack s){
		if((s->start)==NULL)
		return TRUE;
		return FALSE;
		}
	
	int TopNode( sstack s){
		if (!IsEmpty(s)){
		anode *a = s->start;
		return (a->data[a->(top 1)]);
				}
		else
		printf(""error"");
		
		return -1;
				}
		
	void Push( sstack *s,int x){
		anode *a=s->start;
		if (IsEmpty || a->top == maxsize ) {
		anode *k = (anode*)malloc(sizeof(anode));
		k->top = 0;
		k->next = a;
		s->start = m;
		}
		n=s->start;
		n->block[n->top] = x;
		n->top = n->top +1;
		}

	void Pop( hstack s){
		
		n=s->start;
		x= n->block[n->top-1];
		n->top = n->top -1;
		if (n->top==0){
		s->start= n->next;
		free(n);
		return x;
		}
		else{
		printf(""error "");
		return -1;
		}
		}
",5
4149437,11/10/2010 21:49:12,257906,01/24/2010 17:55:10,253,0,Create a Binary Tree from a Stack?,"I'm tasked with creating a program that takes something like:
`((X+3)*(X+4))` into a Binary Tree, along with some other features. So far, i have taken in the input, and parsed it into two stacks, one containing the operands, the other the operators. 

I defined the stacks simply for now (so they only have a nextnode and `char value`.
However, i seem to have problems adding values from the stacks into my tree (so probably a problem in defining the tree). 

My stack is defined as such:

    typedef struct node
    {
        char value;
        struct node * nextnode;
    } node;

My tree is defined:

    typedef struct tree
    {
        node * thisNode;
        struct tree *right, *left;
    } tree;

I'm not sure about the node* part, perhaps it should be something different.

I've been considering the simple case of 2+3 for starters. In this case, the root of the tree should be +, with left being 2 and right being 3. 

     +
    /\
    2 3

my question is how to add something thats on a stack to my tree?
I have tried using

    root->thisNode = operatorTop;

where operatorTop is the top of the operator stack (defined as `node * operatorTop`)
but even that simple line seems to segfault.

Thanks for your help.
",c,tree,structures,,,,open,0,258,7,"Create a Binary Tree from a Stack? I'm tasked with creating a program that takes something like:
`((X+3)*(X+4))` into a Binary Tree, along with some other features. So far, i have taken in the input, and parsed it into two stacks, one containing the operands, the other the operators. 

I defined the stacks simply for now (so they only have a nextnode and `char value`.
However, i seem to have problems adding values from the stacks into my tree (so probably a problem in defining the tree). 

My stack is defined as such:

    typedef struct node
    {
        char value;
        struct node * nextnode;
    } node;

My tree is defined:

    typedef struct tree
    {
        node * thisNode;
        struct tree *right, *left;
    } tree;

I'm not sure about the node* part, perhaps it should be something different.

I've been considering the simple case of 2+3 for starters. In this case, the root of the tree should be +, with left being 2 and right being 3. 

     +
    /\
    2 3

my question is how to add something thats on a stack to my tree?
I have tried using

    root->thisNode = operatorTop;

where operatorTop is the top of the operator stack (defined as `node * operatorTop`)
but even that simple line seems to segfault.

Thanks for your help.
",3
10161271,04/15/2012 10:39:35,1334390,04/15/2012 10:36:51,1,0,C program-help in array alphabetical sorting(VIBGYOR order),"I am having trouble coding for the following question. Hope someone can atleast help with the logic.

Thanks.

Arrange the given 'n' names in VIBGYOR Alphabetical order as shown below.
E.g. 
Input: bindu, vishnu, govind, othello, shyam, yadu, raghu, mary, indu, veena
Output: veena, vishnu, indu, bindu, govind, yadu, othello, raghu, mary, shyam
",c,,,,,04/15/2012 11:27:31,not a real question,1,49,7,"C program-help in array alphabetical sorting(VIBGYOR order) I am having trouble coding for the following question. Hope someone can atleast help with the logic.

Thanks.

Arrange the given 'n' names in VIBGYOR Alphabetical order as shown below.
E.g. 
Input: bindu, vishnu, govind, othello, shyam, yadu, raghu, mary, indu, veena
Output: veena, vishnu, indu, bindu, govind, yadu, othello, raghu, mary, shyam
",1
6324294,06/12/2011 19:59:01,505873,11/12/2010 14:47:02,168,7,Writing My Own Debugger,Are there any good books or online resources dealing with writing your own debugger? I can't seem to find any.,c,assembly,books,debugging,,10/03/2011 16:31:14,not constructive,1,20,4,Writing My Own Debugger Are there any good books or online resources dealing with writing your own debugger? I can't seem to find any.,4
11071922,06/17/2012 14:11:36,401432,07/25/2010 08:40:36,534,4,Self-Avoiding Walk using backtracking recursion,"Given : lattice mn<br>
I'm require to enumerate all path that have no more than one intersection and that ends at the upper right corner using backtracking and recursion !? any suggestions .? 
<br> 
[Self-Avoiding Walk][1]


  [1]: http://mathworld.wolfram.com/Self-AvoidingWalk.html",c,homework,recursion,backtracking,,06/18/2012 14:34:24,not constructive,1,38,5,"Self-Avoiding Walk using backtracking recursion Given : lattice mn<br>
I'm require to enumerate all path that have no more than one intersection and that ends at the upper right corner using backtracking and recursion !? any suggestions .? 
<br> 
[Self-Avoiding Walk][1]


  [1]: http://mathworld.wolfram.com/Self-AvoidingWalk.html",4
6808944,07/24/2011 18:54:43,358892,06/04/2010 21:52:48,421,8,regexec and regcomp more efficient than doing strncmp myself?,"I have a string like this:
    
    I am down in the town seeing a crown=""larry"" with a cherry=""red""
    
I want to write a program that asks user what she wants. If she requests the string that should have ""larry"" as crown and ""red"" cherry, I need to return the string.

Okay, I am over simplifying the problem here. There can be many such strings and I need to parse through them and return all that matches. 

Question: doing regexec and regcomp is more efficient or breaking down the string and doing strncmp?

PS: It seems that regexec would need to do some sort of comparison internally and those would have been designed to be much efficient. ",c,regex,performance,c-strings,,,open,0,125,9,"regexec and regcomp more efficient than doing strncmp myself? I have a string like this:
    
    I am down in the town seeing a crown=""larry"" with a cherry=""red""
    
I want to write a program that asks user what she wants. If she requests the string that should have ""larry"" as crown and ""red"" cherry, I need to return the string.

Okay, I am over simplifying the problem here. There can be many such strings and I need to parse through them and return all that matches. 

Question: doing regexec and regcomp is more efficient or breaking down the string and doing strncmp?

PS: It seems that regexec would need to do some sort of comparison internally and those would have been designed to be much efficient. ",4
6732622,07/18/2011 12:06:26,406001,07/29/2010 17:45:19,102,2,Is it possible for a particular thread in a process to create multiple jobs?,"Is it possible to create multiple jobs with in a single thread? I am really wondered by looking into one of the product logs. Same thread called a function with different parameter approximately at the same time.

Please correct me if understanding is wrong. or is there any other method which actually does this in a single thread.",c,multithreading,pthreads,,,07/18/2011 12:41:24,not a real question,1,57,14,"Is it possible for a particular thread in a process to create multiple jobs? Is it possible to create multiple jobs with in a single thread? I am really wondered by looking into one of the product logs. Same thread called a function with different parameter approximately at the same time.

Please correct me if understanding is wrong. or is there any other method which actually does this in a single thread.",3
7036296,08/12/2011 06:19:17,473396,10/12/2010 13:33:24,17,0,Does C language supports inheritance?,"Suppose we have a header file ""add.h"" with ""add(int,int)"" function , ""subtract.h"" header file with ""subtract(int,int)"" function .Suppose we have a header file ""calc.h"" as follows-:
<br/><br/>
--------------add.h-------------<br/>
int add(int a,int b)<br/>
{<br/>
     return (a+b);<br/>
}<br/>
-------------sub.h--------------<br/>
int sub(int a,int b)<br/>
{<br/>
     return (a-b);<br/>
}<br/>
-------------calc.h-------------<br/>
#include ""add.h""<br/>
#include ""sub.h""<br/>
------------program.c-----------<br/>
#include ""calc.h""<br/>
#include stdio.h<br/>
#include conio.h<br/**>

void main()<br/>
{<br/>
    printf (""%d"",add(1,2));<br/>
    printf (""%d"",sub(3,1));<br/> 
}<br/>

Can't we say that it is the form of inheritance where calc.h is inhering from add.h and sub.h and program.c is inheriting from calc.h?
I know this may be silly doubt to ask but I want to clarify my doubt?
Furthur Please tell me why should one prefer  Object Oriented Prog. rather than procedural programming?
",c,,,,,08/12/2011 10:03:03,not constructive,1,114,5,"Does C language supports inheritance? Suppose we have a header file ""add.h"" with ""add(int,int)"" function , ""subtract.h"" header file with ""subtract(int,int)"" function .Suppose we have a header file ""calc.h"" as follows-:
<br/><br/>
--------------add.h-------------<br/>
int add(int a,int b)<br/>
{<br/>
     return (a+b);<br/>
}<br/>
-------------sub.h--------------<br/>
int sub(int a,int b)<br/>
{<br/>
     return (a-b);<br/>
}<br/>
-------------calc.h-------------<br/>
#include ""add.h""<br/>
#include ""sub.h""<br/>
------------program.c-----------<br/>
#include ""calc.h""<br/>
#include stdio.h<br/>
#include conio.h<br/**>

void main()<br/>
{<br/>
    printf (""%d"",add(1,2));<br/>
    printf (""%d"",sub(3,1));<br/> 
}<br/>

Can't we say that it is the form of inheritance where calc.h is inhering from add.h and sub.h and program.c is inheriting from calc.h?
I know this may be silly doubt to ask but I want to clarify my doubt?
Furthur Please tell me why should one prefer  Object Oriented Prog. rather than procedural programming?
",1
10335404,04/26/2012 14:21:34,1187786,02/03/2012 15:01:35,1,0,Bubble sort not working properly,"    do
    {
        swap=false;
        for(int i=0; i<256; i++)
        {
	    if(pd[i]<pd[i+1])
	    {
	        int temp=pd[i];
                pd[i]=pd[i+1];
                pd[i+1]=temp;
	        swap=true;
            }
        }
    }
    while(swap);

It only returns top two results properly and the rest as 0. I am sorting floats. Please help me!",c,,,,,04/30/2012 15:31:16,too localized,1,139,5,"Bubble sort not working properly     do
    {
        swap=false;
        for(int i=0; i<256; i++)
        {
	    if(pd[i]<pd[i+1])
	    {
	        int temp=pd[i];
                pd[i]=pd[i+1];
                pd[i+1]=temp;
	        swap=true;
            }
        }
    }
    while(swap);

It only returns top two results properly and the rest as 0. I am sorting floats. Please help me!",1
11321458,07/04/2012 01:45:24,1256027,03/08/2012 01:01:44,23,3,(x < 8) returns false when x = -3 (double),"Code reads as follows:


    if (chan->sampcnt < 8)
    {
    	*data = 0;
    	return;
    }

chan contains a pointer to a valid structure.  In the debugger, the value listed for chan->sampcnt is -3.  Somehow it does not resolve the conditional as false and execute the code in the if statement's scope.  This is only the case very rarely, but it constitutes a major bug.  

sampcnt's default value, -3, is run through this conditional many times.  It almost always resolves correctly, but when it doesn't things get ugly fast.  What the heck is happening?  I am at a loss for words.  I have never encountered anything like this before.  Thanks in advance.


",c,if-statement,double,,,07/04/2012 03:23:33,not constructive,1,133,10,"(x < 8) returns false when x = -3 (double) Code reads as follows:


    if (chan->sampcnt < 8)
    {
    	*data = 0;
    	return;
    }

chan contains a pointer to a valid structure.  In the debugger, the value listed for chan->sampcnt is -3.  Somehow it does not resolve the conditional as false and execute the code in the if statement's scope.  This is only the case very rarely, but it constitutes a major bug.  

sampcnt's default value, -3, is run through this conditional many times.  It almost always resolves correctly, but when it doesn't things get ugly fast.  What the heck is happening?  I am at a loss for words.  I have never encountered anything like this before.  Thanks in advance.


",3
1514257,10/03/2009 16:52:55,181695,09/30/2009 09:36:41,79,2,'\n' causing display problem in stdout and stdin,"c for keyboard capture. Following code finds when an arrow key/ esc is pressed. At the same time I want to read whole words that user inputs and these should be shown on stdout as well.

    char pp = 0;
    char p = 0;
    while( (i = read(0, &c, 1)) == 1) {
    if (pp == 033 && p == 0133 && (c &= 255) == 0102) /* DOWN */ break;
    if (c == 0177) /* ASCII DELETE */ break;
    printf( ""%o, %o, %o\t%s\n\r"", pp, p, c, &c);
    pp = p;
    p = c; 
    }

But this code does not work if I remove '\n'. I want stdout should behave as a normal shell.",c,console,unix,stdin,stdout,,open,0,141,8,"'\n' causing display problem in stdout and stdin c for keyboard capture. Following code finds when an arrow key/ esc is pressed. At the same time I want to read whole words that user inputs and these should be shown on stdout as well.

    char pp = 0;
    char p = 0;
    while( (i = read(0, &c, 1)) == 1) {
    if (pp == 033 && p == 0133 && (c &= 255) == 0102) /* DOWN */ break;
    if (c == 0177) /* ASCII DELETE */ break;
    printf( ""%o, %o, %o\t%s\n\r"", pp, p, c, &c);
    pp = p;
    p = c; 
    }

But this code does not work if I remove '\n'. I want stdout should behave as a normal shell.",5
10686629,05/21/2012 13:55:19,1408020,05/21/2012 13:45:03,1,0,Malloc could not allocate memory,"I am getting this strange problem with my code. Malloc is returning a null pointer here.. I have 3 GB memmory on my ram and it could not allocate a few bytes. Why is it happening??
Someone please help..

Here is my code






    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>

    struct htree{
       unsigned char ch;
       unsigned long int freq;
       struct htree *left, *right, *parent;
       };
       
    struct code_list{
       unsigned char ch;
       char *code;
       };


       
    typedef struct htree node;
    typedef struct code_list * dict;

    dict codes;

    int readfile(char *filename, long int *char_count)
    {
     int types = 0;
     FILE *fp = fopen(filename,""rb"");
     unsigned char byteread;
     fread(&byteread,1,1,fp);
     int count=0;
     while(!feof(fp))
     {
                     
                     if (char_count[byteread] == 0)
                     {
                     types++;
                     }
                     char_count[byteread]++;
                     fread(&byteread,1,1,fp);
                     
     }
     fclose(fp);
     return types-1;
    }
    node * genhuffnode()
    {
     node *t = (node *)malloc(sizeof(struct htree));
     t -> ch = '\0';
     t -> freq = 0;
     t -> left = NULL;
     t -> right = NULL;
     t -> parent = NULL;
     return t;
    }
     
    node * genhufftree(long int *char_count, int max_index)
    {
     node **stack;
     node *temp;
     stack = (node **) calloc(max_index,sizeof(node *));
     int i,j=0;
     for(i=0;i<256;i++)
     {
                       if(char_count[i]>0)
                       {
                       stack[j] = (node *)malloc(sizeof(node));
                       stack[j] -> ch = i;
                       stack[j] -> freq = char_count[i];
                       stack[j] -> left = NULL;
                       stack[j] -> right = NULL;
                       stack[j] -> parent = NULL;
                       j++;
                       }
     }

     for(i=0;i<=max_index;i++)
     for(j=i+1;j<=max_index;j++)
     if(stack[j] -> freq > stack[i] -> freq)
     {
                     temp = stack[j];
                     stack[j] = stack[i];
                     stack[i] = temp;
     }
     while(i>0)
     {
               temp = genhuffnode();
               temp -> freq = stack[i] -> freq + stack[i-1] -> freq;
               temp -> left = stack[i-1];
               temp -> right = stack[i];
               stack[i-1] -> parent = temp;
               stack[i] -> parent = temp;

               for(j=i-2;j>0;j--)
               {
                                  if(temp->freq > stack[j-1]->freq)
                                  stack[j+1] = stack[j];
                                  else break;
               }
               stack[j] = temp;
               i--;
     }
     return stack[0];
    }

    void generatedict(node *root, char *s)
    {
     if(root == NULL)
     return;
     char *new_code;
     
     static int index = 0;

     int len = strlen(s)+1;
     
     if(root->left == NULL && root->right == NULL)
     {
                   
                   codes[index].ch = root->ch;
                   codes[index].code = (char *) malloc(len*sizeof(char));
                   strcpy(codes[index].code,s);
                   index++;
     }
     else
     {

                   new_code = (char *)(malloc(len+1));
                   if(new_code == NULL)
                   {
                   printf(""Coudnt allocate memory\n"");
                   getchar();
                   exit(1);
                   }
                   else 
                   {
                   strcpy(new_code,s);
                   new_code[len] = '\0';
                   new_code[len-1] = '0';
                   generatedict(root->left,new_code);
                   new_code[len-1] = '1';
                   generatedict(root->right,new_code);
                   }
     }
     
     free(root);
     return;
    }
 
    void writedict(int total_entries)
    {
     FILE *fp = fopen(""dictionary"",""wb"");
     fwrite(codes,sizeof(struct code_list) * total_entries, sizeof(struct code_list) *         total_entries, fp);
     fclose(fp);
    }                  

    main()
    {
      
      long int char_count[256];
      int max_index;
      max_index = readfile(""2.jpg"",char_count);
      node *root_node;
      root_node = genhufftree(char_count, max_index);
      codes = (struct code_list *)calloc(256,sizeof(struct code_list));         
      generatedict(root_node,"""");
      writedict(max_index+1);

      getchar();
    }
                                          
    Note : please keep any file named ""2.jpg"" in the same folder as the  executable",c,memory-management,malloc,,,05/21/2012 20:51:19,too localized,1,1980,5,"Malloc could not allocate memory I am getting this strange problem with my code. Malloc is returning a null pointer here.. I have 3 GB memmory on my ram and it could not allocate a few bytes. Why is it happening??
Someone please help..

Here is my code






    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>

    struct htree{
       unsigned char ch;
       unsigned long int freq;
       struct htree *left, *right, *parent;
       };
       
    struct code_list{
       unsigned char ch;
       char *code;
       };


       
    typedef struct htree node;
    typedef struct code_list * dict;

    dict codes;

    int readfile(char *filename, long int *char_count)
    {
     int types = 0;
     FILE *fp = fopen(filename,""rb"");
     unsigned char byteread;
     fread(&byteread,1,1,fp);
     int count=0;
     while(!feof(fp))
     {
                     
                     if (char_count[byteread] == 0)
                     {
                     types++;
                     }
                     char_count[byteread]++;
                     fread(&byteread,1,1,fp);
                     
     }
     fclose(fp);
     return types-1;
    }
    node * genhuffnode()
    {
     node *t = (node *)malloc(sizeof(struct htree));
     t -> ch = '\0';
     t -> freq = 0;
     t -> left = NULL;
     t -> right = NULL;
     t -> parent = NULL;
     return t;
    }
     
    node * genhufftree(long int *char_count, int max_index)
    {
     node **stack;
     node *temp;
     stack = (node **) calloc(max_index,sizeof(node *));
     int i,j=0;
     for(i=0;i<256;i++)
     {
                       if(char_count[i]>0)
                       {
                       stack[j] = (node *)malloc(sizeof(node));
                       stack[j] -> ch = i;
                       stack[j] -> freq = char_count[i];
                       stack[j] -> left = NULL;
                       stack[j] -> right = NULL;
                       stack[j] -> parent = NULL;
                       j++;
                       }
     }

     for(i=0;i<=max_index;i++)
     for(j=i+1;j<=max_index;j++)
     if(stack[j] -> freq > stack[i] -> freq)
     {
                     temp = stack[j];
                     stack[j] = stack[i];
                     stack[i] = temp;
     }
     while(i>0)
     {
               temp = genhuffnode();
               temp -> freq = stack[i] -> freq + stack[i-1] -> freq;
               temp -> left = stack[i-1];
               temp -> right = stack[i];
               stack[i-1] -> parent = temp;
               stack[i] -> parent = temp;

               for(j=i-2;j>0;j--)
               {
                                  if(temp->freq > stack[j-1]->freq)
                                  stack[j+1] = stack[j];
                                  else break;
               }
               stack[j] = temp;
               i--;
     }
     return stack[0];
    }

    void generatedict(node *root, char *s)
    {
     if(root == NULL)
     return;
     char *new_code;
     
     static int index = 0;

     int len = strlen(s)+1;
     
     if(root->left == NULL && root->right == NULL)
     {
                   
                   codes[index].ch = root->ch;
                   codes[index].code = (char *) malloc(len*sizeof(char));
                   strcpy(codes[index].code,s);
                   index++;
     }
     else
     {

                   new_code = (char *)(malloc(len+1));
                   if(new_code == NULL)
                   {
                   printf(""Coudnt allocate memory\n"");
                   getchar();
                   exit(1);
                   }
                   else 
                   {
                   strcpy(new_code,s);
                   new_code[len] = '\0';
                   new_code[len-1] = '0';
                   generatedict(root->left,new_code);
                   new_code[len-1] = '1';
                   generatedict(root->right,new_code);
                   }
     }
     
     free(root);
     return;
    }
 
    void writedict(int total_entries)
    {
     FILE *fp = fopen(""dictionary"",""wb"");
     fwrite(codes,sizeof(struct code_list) * total_entries, sizeof(struct code_list) *         total_entries, fp);
     fclose(fp);
    }                  

    main()
    {
      
      long int char_count[256];
      int max_index;
      max_index = readfile(""2.jpg"",char_count);
      node *root_node;
      root_node = genhufftree(char_count, max_index);
      codes = (struct code_list *)calloc(256,sizeof(struct code_list));         
      generatedict(root_node,"""");
      writedict(max_index+1);

      getchar();
    }
                                          
    Note : please keep any file named ""2.jpg"" in the same folder as the  executable",3
9094572,02/01/2012 10:51:36,1089679,12/09/2011 12:08:53,171,0,This variable declaration can creates memory issue,"here i have one function which is call many times in one application this application is running continuously.

Here i am take one character array size of 1024.
here i am declaring `char input[1024];`

so which is best way 

    1)    char input[1024];
    2)    char input[1024] = NULL;

this thing will not create any memory issue after so many times if we used this function.`char input[1024];`

i think may be after using input we have to make NULL ?
or in declaration we have to declare this thing as `char input[1024] = NULL;` so when it will be called next time so that time first input make null than its taking any memory.
  
    #include <string.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <fcntl.h>
    
    void do() {
    	
            char input[1024];
    
    	strcat(input,""ussp-push 04:18:0F:B1:48:B5@9"");
    	strcat(input,""> dev/null&"");
    
    	if(system(input)  != 0)
    	{
    		printf(""\nFailed command\n"");
    	}
    	else
    	{
    			printf(""\nSuccesss command\n"");
    	}
    
    }",c,,,,,,open,0,231,7,"This variable declaration can creates memory issue here i have one function which is call many times in one application this application is running continuously.

Here i am take one character array size of 1024.
here i am declaring `char input[1024];`

so which is best way 

    1)    char input[1024];
    2)    char input[1024] = NULL;

this thing will not create any memory issue after so many times if we used this function.`char input[1024];`

i think may be after using input we have to make NULL ?
or in declaration we have to declare this thing as `char input[1024] = NULL;` so when it will be called next time so that time first input make null than its taking any memory.
  
    #include <string.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <fcntl.h>
    
    void do() {
    	
            char input[1024];
    
    	strcat(input,""ussp-push 04:18:0F:B1:48:B5@9"");
    	strcat(input,""> dev/null&"");
    
    	if(system(input)  != 0)
    	{
    		printf(""\nFailed command\n"");
    	}
    	else
    	{
    			printf(""\nSuccesss command\n"");
    	}
    
    }",1
10244464,04/20/2012 10:26:37,1229893,02/24/2012 04:06:13,108,0,Why does strcpy take it's arguments in reverse order,"Almost every other program or function designed to copy one object into another uses the basic convention

copy(source, destination)

Even common logic would lead one to the conclusion that you are copying something FROM here to THERE. Why does strcpy use the exact opposite convention? It only serves to confuse people attempting to use the function. Surely the author of strcpy thought of this while he was writing the function? Or does the strcpy function predate this now-ubiquitous usage convention?

",c,syntax,cstring,c-strings,,04/20/2012 10:32:22,not constructive,1,78,9,"Why does strcpy take it's arguments in reverse order Almost every other program or function designed to copy one object into another uses the basic convention

copy(source, destination)

Even common logic would lead one to the conclusion that you are copying something FROM here to THERE. Why does strcpy use the exact opposite convention? It only serves to confuse people attempting to use the function. Surely the author of strcpy thought of this while he was writing the function? Or does the strcpy function predate this now-ubiquitous usage convention?

",4
8226844,11/22/2011 12:30:20,1059654,11/22/2011 11:24:25,1,0,C: Using two-dimensional arrays with function pointers,"I need to use a number of functions pointers with an additional boolean flag.
I've tried the following, but it will not compile.
Can anyone help?

    int handler1(int mix) {
        ...
        return 0;
    }
    int handler2(int mix) {
        ...
        return 0;
    }
    int handler3(int mix) {
        ...
        return 0;
    }

    typedef int (*my_handler)(int mix);

    typedef struct {
        my_handler handler,
        bool mix_handler,
    } handle_pair;

    static handler_pair handlers[] = {
        { handler1, FALSE },
        { handler2, TRUE },
        { handler3, FALSE },
        { NULL, FALSE },
    };

",c,,,,,11/22/2011 13:46:01,too localized,1,200,7,"C: Using two-dimensional arrays with function pointers I need to use a number of functions pointers with an additional boolean flag.
I've tried the following, but it will not compile.
Can anyone help?

    int handler1(int mix) {
        ...
        return 0;
    }
    int handler2(int mix) {
        ...
        return 0;
    }
    int handler3(int mix) {
        ...
        return 0;
    }

    typedef int (*my_handler)(int mix);

    typedef struct {
        my_handler handler,
        bool mix_handler,
    } handle_pair;

    static handler_pair handlers[] = {
        { handler1, FALSE },
        { handler2, TRUE },
        { handler3, FALSE },
        { NULL, FALSE },
    };

",1
7792504,10/17/2011 10:35:31,775964,05/30/2011 08:47:06,853,63,In embedded application why c is most poppular?,"see ,

still yet i have seen that most of the **embedded application** are written in c. 
Most of the libraries are written in c. 
Device-driver are written in c. 

So i want to ask you is there any logical reason behind this?  

(My apologies if this post sounds silly/stupid. I thought I'd ask here. Ignoring these core bits never made anyone a better programmer.)",c,linux,embedded,,,10/17/2011 10:41:02,not constructive,1,65,8,"In embedded application why c is most poppular? see ,

still yet i have seen that most of the **embedded application** are written in c. 
Most of the libraries are written in c. 
Device-driver are written in c. 

So i want to ask you is there any logical reason behind this?  

(My apologies if this post sounds silly/stupid. I thought I'd ask here. Ignoring these core bits never made anyone a better programmer.)",3
4221077,11/19/2010 00:26:29,507033,11/13/2010 23:11:36,29,2,FindWindowEx class/title help,"I'm programming in C, and I'm remotely clicking a button programically. I've done it in simple, various simple form applications.. but I've ran across a problem.

    HWND WINAPI FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow);

I've tried using Spy++ (My old 6.0 edition) and the much-more-friendly WinID tool.

An example would be this; I'm attempting to find the required class and 'window' inside of calc.exe. In Windows 7, the class of these buttons is just ""Button"". Alright, but when you look for the title, it's """" (NULL). How would I get past this? I've got the ID of the button, but how would I use the ID instead of the ""window"" title?",c,button,click,,,,open,0,114,3,"FindWindowEx class/title help I'm programming in C, and I'm remotely clicking a button programically. I've done it in simple, various simple form applications.. but I've ran across a problem.

    HWND WINAPI FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow);

I've tried using Spy++ (My old 6.0 edition) and the much-more-friendly WinID tool.

An example would be this; I'm attempting to find the required class and 'window' inside of calc.exe. In Windows 7, the class of these buttons is just ""Button"". Alright, but when you look for the title, it's """" (NULL). How would I get past this? I've got the ID of the button, but how would I use the ID instead of the ""window"" title?",3
8001433,11/03/2011 20:28:00,1028472,11/03/2011 20:06:08,1,0,add custom parameters to imagemagick by patching sources,"i need to modify the behavior of the coder ""caption"" to fit my needs. Therefore i need to add a new parameter called ""maxpointsize"" which requires an integervalue. 

The source can be downloaded here: [imagemagick 6.7.3-3 source][1].

There seems to be an easy way to access the parameters, see **coders/caption.c** lines 138 or 141:

    caption=ConstantString(GetImageProperty(image,""caption""));
    gravity=GetImageOption(image_info,""gravity"");

but i cant put the puzzles together. i have tried this

    int maxsize = (int) GetImageProperty(image,""maxpointsize"");

but a make gives me this warning

    warning: cast from pointer to integer of different size

can anyone see, what iam missing?

thankyou

  [1]: ftp://ftp.imagemagick.org/pub/ImageMagick/ImageMagick-6.7.3-3.tar.gz",c,parameters,imagemagick,patch,,,open,0,105,8,"add custom parameters to imagemagick by patching sources i need to modify the behavior of the coder ""caption"" to fit my needs. Therefore i need to add a new parameter called ""maxpointsize"" which requires an integervalue. 

The source can be downloaded here: [imagemagick 6.7.3-3 source][1].

There seems to be an easy way to access the parameters, see **coders/caption.c** lines 138 or 141:

    caption=ConstantString(GetImageProperty(image,""caption""));
    gravity=GetImageOption(image_info,""gravity"");

but i cant put the puzzles together. i have tried this

    int maxsize = (int) GetImageProperty(image,""maxpointsize"");

but a make gives me this warning

    warning: cast from pointer to integer of different size

can anyone see, what iam missing?

thankyou

  [1]: ftp://ftp.imagemagick.org/pub/ImageMagick/ImageMagick-6.7.3-3.tar.gz",4
9863723,03/25/2012 20:25:02,1250904,03/05/2012 22:08:48,9,0,pthread in c program,I am creating a pthread program. when I ran it in serial it works fine. But then when I create a multi thread version of it using pthread and join it to the main. The result varies. I don't think I have used any shared variables. Is there any other reason that could cause that?,c,multithreading,pthreads,,,03/25/2012 21:35:14,too localized,1,55,4,pthread in c program I am creating a pthread program. when I ran it in serial it works fine. But then when I create a multi thread version of it using pthread and join it to the main. The result varies. I don't think I have used any shared variables. Is there any other reason that could cause that?,3
10782636,05/28/2012 09:53:32,1421423,05/28/2012 09:46:43,1,0,Web server for embedded linux,"I have embedded linux board  with kernel 2.6.28, device has ethernet port.

looking for webserver installation on this board. I found boa, lighttpd server can be installed. but i dont know which one is better. can any one suggest any better web server for embedded board.
",c,linux,embedded,,,05/28/2012 20:15:32,not constructive,1,46,5,"Web server for embedded linux I have embedded linux board  with kernel 2.6.28, device has ethernet port.

looking for webserver installation on this board. I found boa, lighttpd server can be installed. but i dont know which one is better. can any one suggest any better web server for embedded board.
",3
3551824,08/23/2010 21:24:56,111426,05/23/2009 06:10:12,1010,20,Safely storing and accessing EEPROM,"I've recently established the need to store infrequently-updated configuration variables in the EEPROM of a microcontroller. Adding state to the program immediately forces one to worry about

 * detection of uninitialized data in EEPROM (i.e. first boot),
 * converting or invalidating data from old firmware versions, and
 * addressing of multiple structures, each of which which may grow in firmware updates.

Extensive Googling has only turned up one article that addresses [keeping your EEPROM data valid through firmware updates](http://embeddedgurus.com/stack-overflow/2009/11/keeping-your-eeprom-data-valid-through-firmware-updates/). Has anyone used the approach discussed in that article? Is there a better alternative approach?",c,embedded,eeprom,,,,open,0,93,5,"Safely storing and accessing EEPROM I've recently established the need to store infrequently-updated configuration variables in the EEPROM of a microcontroller. Adding state to the program immediately forces one to worry about

 * detection of uninitialized data in EEPROM (i.e. first boot),
 * converting or invalidating data from old firmware versions, and
 * addressing of multiple structures, each of which which may grow in firmware updates.

Extensive Googling has only turned up one article that addresses [keeping your EEPROM data valid through firmware updates](http://embeddedgurus.com/stack-overflow/2009/11/keeping-your-eeprom-data-valid-through-firmware-updates/). Has anyone used the approach discussed in that article? Is there a better alternative approach?",3
1618433,10/24/2009 16:22:33,3886,08/31/2008 16:55:28,3333,190,Is there a standard way to convert a struct timeval into a struct timespec?,"`struct timeval` represents and instant in time with two members, `tv_sec` (seconds) and `tv_usec` (microseconds). In this representation, `tv_usec` is not by itself an absolute time it is a sub second offset off of `tv_sec`.

`struct timespec` works the same way except that instead of microseconds it's offset (`tv_nsec`) is stored in nanosecond units.

The question is: Is there a standard way to convert between these two?",c,unix,posix,timeval,timespec,,open,0,65,14,"Is there a standard way to convert a struct timeval into a struct timespec? `struct timeval` represents and instant in time with two members, `tv_sec` (seconds) and `tv_usec` (microseconds). In this representation, `tv_usec` is not by itself an absolute time it is a sub second offset off of `tv_sec`.

`struct timespec` works the same way except that instead of microseconds it's offset (`tv_nsec`) is stored in nanosecond units.

The question is: Is there a standard way to convert between these two?",5
9517582,03/01/2012 14:05:02,1240075,02/29/2012 11:11:04,8,0,Is there a preferable programming language for CGI apps?,"I know that I can write CGI in many languages, the most are C and Perl.
But why I have to write it in Perl or in C?
What's the difference and what's the (eventually) the best and safe solution?",c,perl,cgi,,,03/01/2012 18:39:55,not constructive,1,38,9,"Is there a preferable programming language for CGI apps? I know that I can write CGI in many languages, the most are C and Perl.
But why I have to write it in Perl or in C?
What's the difference and what's the (eventually) the best and safe solution?",3
8538280,12/16/2011 18:06:58,1080821,12/05/2011 03:07:14,1,0,"Which is the bestway to input without ""\n"" in C?","Which is the bestway to input without ""\n"" in C 
and some easyway.",c,,,,,12/16/2011 21:42:31,not a real question,1,13,10,"Which is the bestway to input without ""\n"" in C? Which is the bestway to input without ""\n"" in C 
and some easyway.",1
11354344,07/06/2012 00:25:26,1426143,05/30/2012 13:32:58,19,1,c fputs not writing,"I am trying to overwrite the file by putting a string. 
I am using Ubuntu and gcc for compilation. I used fputs to write a string.

When i checked the file after writing, it is empty.

below is the code:


     const char *home=""/home/"";
    
      const char *delm=""/"";
    
      const char *filename="".RMCU.conf"";
    
      const char *str=""INSTANCE:1"";
    
      const char *str1=""INSTANCE:0"";
    
      int result;
    
      char* path;
    
      path = malloc(strlen(home)+strlen(usr)+strlen(delm)+strlen(filename));
    
    
      strcpy(path, home);
    
      strcat(path, usr);
    
      strcat(path, delm);
    
      strcat(path, filename);
    
    
      close_file(); //fclose(fp); if open
    
     
    
      fp = fopen(path, ""w+"");
    
      result = fputs(str,fp);

			    
Any help is appreciated.

abhimoh",c,file,,,,07/06/2012 04:09:38,too localized,1,233,4,"c fputs not writing I am trying to overwrite the file by putting a string. 
I am using Ubuntu and gcc for compilation. I used fputs to write a string.

When i checked the file after writing, it is empty.

below is the code:


     const char *home=""/home/"";
    
      const char *delm=""/"";
    
      const char *filename="".RMCU.conf"";
    
      const char *str=""INSTANCE:1"";
    
      const char *str1=""INSTANCE:0"";
    
      int result;
    
      char* path;
    
      path = malloc(strlen(home)+strlen(usr)+strlen(delm)+strlen(filename));
    
    
      strcpy(path, home);
    
      strcat(path, usr);
    
      strcat(path, delm);
    
      strcat(path, filename);
    
    
      close_file(); //fclose(fp); if open
    
     
    
      fp = fopen(path, ""w+"");
    
      result = fputs(str,fp);

			    
Any help is appreciated.

abhimoh",2
1713129,11/11/2009 05:01:12,208409,11/11/2009 05:01:12,1,0,getting number of active threads,I'm developing a multi threaded Unix application in C. Is there a simple way to get the count of the number of simultaneously active threads? I don't want to have to write the code to keep track of the number of active thread if it already can be done for me by the library! :-),c,unix,multithreading,posix,,,open,0,55,5,getting number of active threads I'm developing a multi threaded Unix application in C. Is there a simple way to get the count of the number of simultaneously active threads? I don't want to have to write the code to keep track of the number of active thread if it already can be done for me by the library! :-),4
527700,02/09/2009 10:52:58,59730,01/28/2009 12:03:09,89,5,Which language to learn: C/C#/C++?,"Im looking to learn one of the above languages. I'm a PHP/HTML/CSS programmer and I would like to get into desktop applications. I need something pretty powerful and I would like to be able to create apps with Windows GUI's. 

What would stack overflow recommend? Is there any knowledge I should have before diving into these languages?

Thanks =)",c,c++,c#,,,07/25/2012 22:10:29,not constructive,1,58,5,"Which language to learn: C/C#/C++? Im looking to learn one of the above languages. I'm a PHP/HTML/CSS programmer and I would like to get into desktop applications. I need something pretty powerful and I would like to be able to create apps with Windows GUI's. 

What would stack overflow recommend? Is there any knowledge I should have before diving into these languages?

Thanks =)",3
7525125,09/23/2011 06:31:20,911372,08/25/2011 06:49:26,18,0,texas instrument ez430 chronos wireless protocol code,"I am working with texas instrument ez430 chronos. This device comes with an RF USB emulator to obtain acceleration measurement and data from the ez 430 chronos. The acceleration measured is then being displayed on a software in desktop, TI Chronos Control Centre.

I have a question and that is which part of the code is used to transmit ""acceleration measured - data"" wirelessly to the RF USB emulator?",c,texas-instruments,,,,02/05/2012 00:43:44,not a real question,1,68,7,"texas instrument ez430 chronos wireless protocol code I am working with texas instrument ez430 chronos. This device comes with an RF USB emulator to obtain acceleration measurement and data from the ez 430 chronos. The acceleration measured is then being displayed on a software in desktop, TI Chronos Control Centre.

I have a question and that is which part of the code is used to transmit ""acceleration measured - data"" wirelessly to the RF USB emulator?",2
4894057,02/04/2011 02:44:14,569183,01/09/2011 22:33:46,558,39,"C, logs, binary, and the number four. they don't mix.","#include `<stdio.h>`
#include `<math.h>`
<pre>
/* converts to binary using logs */
int main()
{
    long int decimalNUM = 0, binaryNUM = 0, exponentNUM = 0;
    printf(""Enter a number to be converted to binary.\t"");
    scanf(""%ld"", &decimalNUM);
    fflush(stdin);
    int origDEC = decimalNUM;
       while (decimalNUM > 0)
       {
          exponentNUM = (log(decimalNUM))/(log(2));
          binaryNUM += pow(10, exponentNUM);
          decimalNUM -= pow(2, exponentNUM);
       }
       printf(""\nBINARY FORM OF %ld is %ld"", origDEC, binaryNUM);
    getchar();
    return binaryNUM;
}
</pre>

if STDIN is 4 it returns 99 and it should not. on IDEONE it returns 100...??!!",c,binary,int,long-integer,unsigned,,open,0,151,10,"C, logs, binary, and the number four. they don't mix. #include `<stdio.h>`
#include `<math.h>`
<pre>
/* converts to binary using logs */
int main()
{
    long int decimalNUM = 0, binaryNUM = 0, exponentNUM = 0;
    printf(""Enter a number to be converted to binary.\t"");
    scanf(""%ld"", &decimalNUM);
    fflush(stdin);
    int origDEC = decimalNUM;
       while (decimalNUM > 0)
       {
          exponentNUM = (log(decimalNUM))/(log(2));
          binaryNUM += pow(10, exponentNUM);
          decimalNUM -= pow(2, exponentNUM);
       }
       printf(""\nBINARY FORM OF %ld is %ld"", origDEC, binaryNUM);
    getchar();
    return binaryNUM;
}
</pre>

if STDIN is 4 it returns 99 and it should not. on IDEONE it returns 100...??!!",5
11019437,06/13/2012 16:37:27,1454230,06/13/2012 16:29:14,1,0,how can i fix my linked list?,"i am trying to make a function that uses map() and takes a linked list and a function how do i make my code so it actually creates a linked list so i can test out if my map() function actually works.

    #include <stdio.h>
    #include <stdlib.h>
    
    int addone(int);
    int square(int);
    void map(list, int (*)(int));
    
    struct list {
      int x;
      struct list *next;
    };
    typedef struct list list;
    
    int main()
    {
    int (*any)(int) = square;
    //what i don't understand how to create the linked list initialize it
    struct list *list;
    list = malloc( sizeof(struct list) );
    list->next = 0;
    list->x=5;
    map(list,any);
    
    return 0;
    
    }
    
    int square(int n)
    {
    return n*n;
    }
    
    int addone(int n)
    {
    return n + 1;
    }
    
    void map(list *list,int (*func)(int))//accepts a linked list and a function
    {
     
    for(list *x=list; x != NULL; x=x->next)
    {
    printf(""%d\n"",func(&x));
    }
    }",c,linked-list,,,,06/14/2012 01:46:30,too localized,1,289,7,"how can i fix my linked list? i am trying to make a function that uses map() and takes a linked list and a function how do i make my code so it actually creates a linked list so i can test out if my map() function actually works.

    #include <stdio.h>
    #include <stdlib.h>
    
    int addone(int);
    int square(int);
    void map(list, int (*)(int));
    
    struct list {
      int x;
      struct list *next;
    };
    typedef struct list list;
    
    int main()
    {
    int (*any)(int) = square;
    //what i don't understand how to create the linked list initialize it
    struct list *list;
    list = malloc( sizeof(struct list) );
    list->next = 0;
    list->x=5;
    map(list,any);
    
    return 0;
    
    }
    
    int square(int n)
    {
    return n*n;
    }
    
    int addone(int n)
    {
    return n + 1;
    }
    
    void map(list *list,int (*func)(int))//accepts a linked list and a function
    {
     
    for(list *x=list; x != NULL; x=x->next)
    {
    printf(""%d\n"",func(&x));
    }
    }",2
8134030,11/15/2011 09:21:06,193703,10/21/2009 10:24:22,5,0,Read blockwise bytes from binary file in C,"I need to read a binary file byte for byte in blocks of 8 bytes. Then I need to check bytes 5 and byte 7 whether their value is zero. If it found a block with that criteria, printf should show me the entire 8 byte block.
Sounds pretty easy, but I didn't get it to work as I expected.

I tried something like that, but without success:

        unsigned char buffer[8];
        FILE *file;
	unsigned long fileLen;

	//Open file
	file = fopen(""tcpstream-noframe.raw"", ""rb"");
	if (!file)
	{
		fprintf(stderr, ""Unable to open file %s"", ""tcpstream-noframe.raw"");
		return 1;
	}
	
	for(int i=0; i++ ; i<9999) {
	fread(buffer, 8, 1, file);
	if(buffer[5] == 0 && buffer[7] == 0)
	    printf(""%X %X %X %X %X %X %X %X\n"",buffer[0], buffer[1], buffer[2],  buffer[3],buffer[4], buffer[5], buffer[6], buffer[7]);
	}

Any ideas? Thanks.",c,file,binary,,,11/15/2011 22:18:54,not a real question,1,133,8,"Read blockwise bytes from binary file in C I need to read a binary file byte for byte in blocks of 8 bytes. Then I need to check bytes 5 and byte 7 whether their value is zero. If it found a block with that criteria, printf should show me the entire 8 byte block.
Sounds pretty easy, but I didn't get it to work as I expected.

I tried something like that, but without success:

        unsigned char buffer[8];
        FILE *file;
	unsigned long fileLen;

	//Open file
	file = fopen(""tcpstream-noframe.raw"", ""rb"");
	if (!file)
	{
		fprintf(stderr, ""Unable to open file %s"", ""tcpstream-noframe.raw"");
		return 1;
	}
	
	for(int i=0; i++ ; i<9999) {
	fread(buffer, 8, 1, file);
	if(buffer[5] == 0 && buffer[7] == 0)
	    printf(""%X %X %X %X %X %X %X %X\n"",buffer[0], buffer[1], buffer[2],  buffer[3],buffer[4], buffer[5], buffer[6], buffer[7]);
	}

Any ideas? Thanks.",3
2239519,02/10/2010 19:01:07,52256,01/07/2009 00:39:19,576,17,Is there a way to specify how many characters of a string to print out using printf()?,"Is there a way to specify how many characters of a string to print out (similar to decimal places in ints)

    printf (""Here are the first 8 chars: %s\n"", ""A string that is more than 8 chars"");

Would like it to print: ""Here are the first 8 chars:A string""",c,c++,printf,,,,open,0,51,17,"Is there a way to specify how many characters of a string to print out using printf()? Is there a way to specify how many characters of a string to print out (similar to decimal places in ints)

    printf (""Here are the first 8 chars: %s\n"", ""A string that is more than 8 chars"");

Would like it to print: ""Here are the first 8 chars:A string""",3
10409125,05/02/2012 07:00:33,308251,04/03/2010 10:35:48,1359,114,Android read text file from asset folder using C (ndk),"I need to read text file from asset folder in android, by searching through internet I found that there is asset_manager api available from android 2.3 onwards. As I am targeting only tablet devices this is useful. But as I am not expert in C language I am not able to find any example on how to read/write files using file descriptor. I found many examples using FILE* (file pointers)

> My goal is to decrypt a js file from asset folder which is encrypted
> using C (for securing the code), as js code is visible if end user
> decompiled my apk. Because asset folder is inside zip file is it possible to do?",c,encryption,android-ndk,,,,open,0,113,10,"Android read text file from asset folder using C (ndk) I need to read text file from asset folder in android, by searching through internet I found that there is asset_manager api available from android 2.3 onwards. As I am targeting only tablet devices this is useful. But as I am not expert in C language I am not able to find any example on how to read/write files using file descriptor. I found many examples using FILE* (file pointers)

> My goal is to decrypt a js file from asset folder which is encrypted
> using C (for securing the code), as js code is visible if end user
> decompiled my apk. Because asset folder is inside zip file is it possible to do?",3
9192223,02/08/2012 11:13:45,901046,08/18/2011 16:50:23,123,7,"Remove GTK+ container children, repopulate it, then refresh","I'm into a problem with a GTK+ C application. I have a container that, when starting the application, contains a button. During the running an user interation must cause this widget to contain more of them.  
I need to write a function that removes all the ""old"" inner buttons, then adds all the ones from a list and finally refresh the view. This is the one I'm writing but some parts are missing (TODOs)

    void refresh_sequence_panel() 
    {
        GSList* iterator = NULL;
        GtkWidget* button;
	
        // TODO: Here the container must be empty

        // Now add all the buttons
        for (iterator = steps; iterator; iterator = iterator->next) {
           button = gtk_button_new_from_stock(GTK_STOCK_ADD);
	       gtk_widget_set_size_request(button, SEQ_BUTTON_W, SEQ_BUTTON_H);
           gtk_box_pack_start(GTK_BOX(sequence_panel), button, FALSE, FALSE, 5);
           handler_id = g_signal_connect(G_OBJECT(button), ""clicked"", G_CALLBACK(seq_popup), GTK_BOX(sequence_panel));
	    }

        // TODO: Now refresh the view, so I can see the changes...
    }

Hope that someone can help, thanks!",c,gtk,refresh,widgets,,,open,0,234,8,"Remove GTK+ container children, repopulate it, then refresh I'm into a problem with a GTK+ C application. I have a container that, when starting the application, contains a button. During the running an user interation must cause this widget to contain more of them.  
I need to write a function that removes all the ""old"" inner buttons, then adds all the ones from a list and finally refresh the view. This is the one I'm writing but some parts are missing (TODOs)

    void refresh_sequence_panel() 
    {
        GSList* iterator = NULL;
        GtkWidget* button;
	
        // TODO: Here the container must be empty

        // Now add all the buttons
        for (iterator = steps; iterator; iterator = iterator->next) {
           button = gtk_button_new_from_stock(GTK_STOCK_ADD);
	       gtk_widget_set_size_request(button, SEQ_BUTTON_W, SEQ_BUTTON_H);
           gtk_box_pack_start(GTK_BOX(sequence_panel), button, FALSE, FALSE, 5);
           handler_id = g_signal_connect(G_OBJECT(button), ""clicked"", G_CALLBACK(seq_popup), GTK_BOX(sequence_panel));
	    }

        // TODO: Now refresh the view, so I can see the changes...
    }

Hope that someone can help, thanks!",4
10696024,05/22/2012 05:12:31,1402541,05/18/2012 05:18:45,3,0,How does the array stored in memory?,"I have a simple program which initializes an array as:

int a[]={10,20,30,40,50};

char *p;

p=(char*)a;

Now I want to access the value at each byte through pointer 'p'. For that I need to know how does the array stored in memory(stack or heap)?
",c,,,,,05/31/2012 18:58:06,not a real question,1,39,7,"How does the array stored in memory? I have a simple program which initializes an array as:

int a[]={10,20,30,40,50};

char *p;

p=(char*)a;

Now I want to access the value at each byte through pointer 'p'. For that I need to know how does the array stored in memory(stack or heap)?
",1
