PostId,PostCreationDate,OwnerUserId,OwnerCreationDate,ReputationAtPostCreation,OwnerUndeletedAnswerCountAtPostTime,Title,BodyMarkdown,Tag1,Tag2,Tag3,Tag4,Tag5,PostClosedDate,OpenStatus,OpenStatusInt,BodyLength,TitleLength,TitleConcatWithBody,NumberOfTags
1398322,09/09/2009 08:30:50,80406,03/20/2009 10:00:02,1,0,Split ByteString on a ByteString (instead of a Word8 or Char),"I know I already have the Haskell Data.ByteStream.Lazy function to split a CSV on a single character, such as:

    Split :: Word8 -> ByteStream -> [ByteStream]

But I want to split on a multi-character ByteStream (like splitting on a String instead of a Char):

    Split :: ByteStream -> ByteStream -> [ByteStream]

I have multi-character separators in a csv-like text file that I need to parse, and the individual characters themselves appear in some of the fields, so choosing just one separator character and discarding the others would contaminate the data import.

I've had some ideas on how to do this, but they seem kind of hacky (e.g. take three Word8s, test if they're the separator combination, start a new field if they are, recurse further), and I imagine I would be reinventing a wheel anyway.  Is there a way to do this without rebuilding the function from scratch?",haskell,text,csv,string,,,open,0,152,11,"Split ByteString on a ByteString (instead of a Word8 or Char) I know I already have the Haskell Data.ByteStream.Lazy function to split a CSV on a single character, such as:

    Split :: Word8 -> ByteStream -> [ByteStream]

But I want to split on a multi-character ByteStream (like splitting on a String instead of a Char):

    Split :: ByteStream -> ByteStream -> [ByteStream]

I have multi-character separators in a csv-like text file that I need to parse, and the individual characters themselves appear in some of the fields, so choosing just one separator character and discarding the others would contaminate the data import.

I've had some ideas on how to do this, but they seem kind of hacky (e.g. take three Word8s, test if they're the separator combination, start a new field if they are, recurse further), and I imagine I would be reinventing a wheel anyway.  Is there a way to do this without rebuilding the function from scratch?",4
10345699,04/27/2012 06:20:07,845081,07/14/2011 17:17:41,301,0,what is [a] as a type in Haskell?,"This question is about type in Haskell programming language.

Whey I type 
:t []

I get the return as:

[]::[a]

What is [a]?



Thanks",haskell,types,,,,,open,0,19,8,"what is [a] as a type in Haskell? This question is about type in Haskell programming language.

Whey I type 
:t []

I get the return as:

[]::[a]

What is [a]?



Thanks",2
8682364,12/30/2011 17:53:48,1054808,11/19/2011 00:28:24,431,4,Ambiguous type variable `p0' in the constraints,"`enter code here`I get the error 

    Ambiguous type variable `p0' in the constraints:
          (Show p0) arising from a use of `print' at cwqr_0003.hs:31:6-10
          (Ord p0) arising from a use of `PSQ.lookup'

from the code below.

I have no idea how to analyze this. Could this be a problem in GHC or in one of the modules?
If I try putStr in place of print then I get an error related to the expected type being a string rather then maybe p0. When I try fromMaybe it gives me an error related to the default value `literal zero` that I send to fromMaybe

    import qualified Data.PSQueue as PSQ
    import Data.Maybe
    import Data.Label
    import Control.Category
    import Prelude hiding ((.))
    
    --some tested code omitted here 
    
    let r = PSQ.lookup test' q
    --putStr (show (r :: String)) 
    print (r) 

",haskell,,,,,,open,0,192,7,"Ambiguous type variable `p0' in the constraints `enter code here`I get the error 

    Ambiguous type variable `p0' in the constraints:
          (Show p0) arising from a use of `print' at cwqr_0003.hs:31:6-10
          (Ord p0) arising from a use of `PSQ.lookup'

from the code below.

I have no idea how to analyze this. Could this be a problem in GHC or in one of the modules?
If I try putStr in place of print then I get an error related to the expected type being a string rather then maybe p0. When I try fromMaybe it gives me an error related to the default value `literal zero` that I send to fromMaybe

    import qualified Data.PSQueue as PSQ
    import Data.Maybe
    import Data.Label
    import Control.Category
    import Prelude hiding ((.))
    
    --some tested code omitted here 
    
    let r = PSQ.lookup test' q
    --putStr (show (r :: String)) 
    print (r) 

",1
291780,11/14/2008 23:31:57,37840,11/14/2008 23:26:32,1,0,New to functional programming,"Hey, I'm really new to Haskell and have been using more classic programming languages my whole life.  I have no idea what is going on here.  I'm trying to make a very simple Viterbi algorithm implementation, but for only two states (honest and dishonest casino)

I have a problem where I want to address my array, but I don't think I'm getting types right.  That or I'm making a new array each time I try to address it - equally stupid.  Look at myArray, te infix, and dynamicProgram especially, PLEASE.  Pretty pretty please 
<pre> Code
<code>

import Array
import Char

trans :: Int -> Int -> Double -> Double -> Double
trans from x trans11 trans21 =
    if (from == 1) && (x == 1)
        then trans11
    else if (from == 1) && (x == 2) 
        then (1-trans11)
    else if (from == 2) && (x == 1) 
        then trans21
    else (1-trans21)

em :: Char -> [Double] -> Double
em c list = list!! a
    where a = digitToInt c

intToChar :: Int -> Char
intToChar n | n == 1 = '1'
            | n == 2 = '2'

casino :: Char -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> Double
casino seqchar 1 y em1 em2 t1 t2= 0.5 * (em seqchar em1)
casino seqchar 2 y em1 em2 t1 t2= 0.5 * (em seqchar em2)
casino seqchar x y em1 em2 t1 t2= maximum[ (1 @@ y-1)*(em seqchar em1)*(trans 1 x t1 t2),(2 @@ y-1)*(em seqchar em2)*(trans 2 x t1 t2) ]

dynamicProgram :: [Char] -> (Char -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> Double) -> [Double] -> [Double] -> Double -> Double -> (Array a b)
dynamicProgram string score list1 list2 trans11 trans21 = myArray 1 len
							    [score (string!!y) x y list1 list2 trans11 trans21 | x <-[1,len], y<-[1,2]]
    where
        len = length string

myArray :: Int -> Int -> [Double] -> Array a b
myArray startIndex endIndex values = listArray (startIndex,startIndex) (endIndex,endIndex) values

traceback :: [Char] -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> [Char]
traceback s 1 0 em1 em2 t1 t2 = []
traceback s 2 0 em1 em2 t1 t2 = []
traceback s x y em1 em2 t1 t2 | x@@y == (1 @@ y-1)*(em (s!!y) em1)*(trans 1 x t1 t2) = '1' : traceback s 1 (y-1) em1 em2 t1 t2
                            | x@@y == (2 @@ y-1)*(em (s!!y) em1)*(trans 2 x t1 t2) = '2' : traceback s 2 (y-1) em1 em2 t1 t2 

answer :: [Char] -> [Double] -> [Double] -> Double -> Double -> [Char]
answer string list1 list2 t1 t2 = reverse $ maxC : traceback string max end list1 list2 t1 t2 $ dynamicProgram casino string list1 list2 t1 t2
   where
      end = (length string) + 1
      max | maximum (1@@end) (2@@end) == 1@@end = 1
	  | maximum (1@@end) (2@@end) == 2@@end = 2
      maxC = intToChar max

infix 5 @@
(@@) i j = myArray ! (i, j)

main = do
    putStrLn ""What is the sequence to test?""
    seq <- getLine
    putStrLn ""This program works on any two state HMM with language [1,9] (depending on the |Pr| cardinality).""
    putStrLn ""Write in set [1,2,...] notation the first state emission probabilities.""
    st1 <- getLine
    putStrLn ""Write in set [1,2,...] notation the second state emission probabilities.""
    st2 <- getLine
    putStrLn ""What is the state 1 -> state 1 transmission probability?""
    trp1 <- getLine
    putStrLn ""I assume that the state 1 -> state 2 transmission probability is "" ++ (1-trp1)
    putStrLn ""What is the state 2 -> state 1 transmission probability?""
    trp2 <- getLine
    putStrLn ""I assume that the state 2 -> state 2 transmission probability is "" ++ (1-trp2)
    putStrLn ""I assume that the prob of starting in either state is 1/2.  Go!""
    answer seq st1 st2 trp1 trp2
</code></pre>",haskell,functional-programming,help,viterbi,,12/26/2011 15:48:45,not a real question,1,777,4,"New to functional programming Hey, I'm really new to Haskell and have been using more classic programming languages my whole life.  I have no idea what is going on here.  I'm trying to make a very simple Viterbi algorithm implementation, but for only two states (honest and dishonest casino)

I have a problem where I want to address my array, but I don't think I'm getting types right.  That or I'm making a new array each time I try to address it - equally stupid.  Look at myArray, te infix, and dynamicProgram especially, PLEASE.  Pretty pretty please 
<pre> Code
<code>

import Array
import Char

trans :: Int -> Int -> Double -> Double -> Double
trans from x trans11 trans21 =
    if (from == 1) && (x == 1)
        then trans11
    else if (from == 1) && (x == 2) 
        then (1-trans11)
    else if (from == 2) && (x == 1) 
        then trans21
    else (1-trans21)

em :: Char -> [Double] -> Double
em c list = list!! a
    where a = digitToInt c

intToChar :: Int -> Char
intToChar n | n == 1 = '1'
            | n == 2 = '2'

casino :: Char -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> Double
casino seqchar 1 y em1 em2 t1 t2= 0.5 * (em seqchar em1)
casino seqchar 2 y em1 em2 t1 t2= 0.5 * (em seqchar em2)
casino seqchar x y em1 em2 t1 t2= maximum[ (1 @@ y-1)*(em seqchar em1)*(trans 1 x t1 t2),(2 @@ y-1)*(em seqchar em2)*(trans 2 x t1 t2) ]

dynamicProgram :: [Char] -> (Char -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> Double) -> [Double] -> [Double] -> Double -> Double -> (Array a b)
dynamicProgram string score list1 list2 trans11 trans21 = myArray 1 len
							    [score (string!!y) x y list1 list2 trans11 trans21 | x <-[1,len], y<-[1,2]]
    where
        len = length string

myArray :: Int -> Int -> [Double] -> Array a b
myArray startIndex endIndex values = listArray (startIndex,startIndex) (endIndex,endIndex) values

traceback :: [Char] -> Int -> Int -> [Double] -> [Double] -> Double -> Double -> [Char]
traceback s 1 0 em1 em2 t1 t2 = []
traceback s 2 0 em1 em2 t1 t2 = []
traceback s x y em1 em2 t1 t2 | x@@y == (1 @@ y-1)*(em (s!!y) em1)*(trans 1 x t1 t2) = '1' : traceback s 1 (y-1) em1 em2 t1 t2
                            | x@@y == (2 @@ y-1)*(em (s!!y) em1)*(trans 2 x t1 t2) = '2' : traceback s 2 (y-1) em1 em2 t1 t2 

answer :: [Char] -> [Double] -> [Double] -> Double -> Double -> [Char]
answer string list1 list2 t1 t2 = reverse $ maxC : traceback string max end list1 list2 t1 t2 $ dynamicProgram casino string list1 list2 t1 t2
   where
      end = (length string) + 1
      max | maximum (1@@end) (2@@end) == 1@@end = 1
	  | maximum (1@@end) (2@@end) == 2@@end = 2
      maxC = intToChar max

infix 5 @@
(@@) i j = myArray ! (i, j)

main = do
    putStrLn ""What is the sequence to test?""
    seq <- getLine
    putStrLn ""This program works on any two state HMM with language [1,9] (depending on the |Pr| cardinality).""
    putStrLn ""Write in set [1,2,...] notation the first state emission probabilities.""
    st1 <- getLine
    putStrLn ""Write in set [1,2,...] notation the second state emission probabilities.""
    st2 <- getLine
    putStrLn ""What is the state 1 -> state 1 transmission probability?""
    trp1 <- getLine
    putStrLn ""I assume that the state 1 -> state 2 transmission probability is "" ++ (1-trp1)
    putStrLn ""What is the state 2 -> state 1 transmission probability?""
    trp2 <- getLine
    putStrLn ""I assume that the state 2 -> state 2 transmission probability is "" ++ (1-trp2)
    putStrLn ""I assume that the prob of starting in either state is 1/2.  Go!""
    answer seq st1 st2 trp1 trp2
</code></pre>",4
8269412,11/25/2011 12:52:01,633154,02/24/2011 21:33:39,24,1,Multiply list elements by two or every element by (itself - 1),"i need to write a function, which takes positive integers list. If list begins with 2, then every element must be multiplied by 2, in other cases every integer n is written n-1 times.

`two :: [Int] -> [Int]`

i.e:

`two [2,1] ==> [4,2]`

`two [3,2,4] ==> [3,3,2,4,4,4]`


    multiplyByTwo x = x*2
    two :: [Int] -> [Int]
    two [x] = if x == 2 then [x*2] else replicate (x-1) x
    two (x:xs) = 
    	if x == 2 
    		then multiplyByTwo x 
    		else [1..3]

I'm stuck now with writing that: if my first element of the list is 2, then recursively multiply every element by 2. I tried to do with extra function `multiplyByTwo` but it doesn't work.
The else statement is that i need to replicate every element of the list by (itself - 1)",haskell,,,,,,open,0,152,12,"Multiply list elements by two or every element by (itself - 1) i need to write a function, which takes positive integers list. If list begins with 2, then every element must be multiplied by 2, in other cases every integer n is written n-1 times.

`two :: [Int] -> [Int]`

i.e:

`two [2,1] ==> [4,2]`

`two [3,2,4] ==> [3,3,2,4,4,4]`


    multiplyByTwo x = x*2
    two :: [Int] -> [Int]
    two [x] = if x == 2 then [x*2] else replicate (x-1) x
    two (x:xs) = 
    	if x == 2 
    		then multiplyByTwo x 
    		else [1..3]

I'm stuck now with writing that: if my first element of the list is 2, then recursively multiply every element by 2. I tried to do with extra function `multiplyByTwo` but it doesn't work.
The else statement is that i need to replicate every element of the list by (itself - 1)",1
10073842,04/09/2012 13:22:50,597097,01/31/2011 15:51:25,87,3,What are the main benefits of using Haskell for web developing?,"I'm learning Haskell [for great good](http://urli.st/4n5/uki).

I'm pretty into OOP and the various type systems. I used Java to develop webapps (j2ee, spring, hybernate, struts 1.x), now I'm using regularly Python (pylons, django, sqlalchemy, pymongo) and Javascript. I had a huge improvement in my personal productivity: the lightweight approach, duck typing, awesome iterators, functions as first class citizens, simple syntax and configuration, fast tools like `pip` and `distribute` (and much more) helped me a lot.

But the first reason of my productivity boost is *the Python language itself*.

What are the main benefits of using Haskell for web developing?
For example, how its type inference can really improve my web app? So far, I noticed that when you decorate your function with its type-signature **you are adding a lot of semantics to your program**. I expect all this effort to **come back** in some way, to save many lines of code and to make them sound. I really like the sharp distinction between types and data, I'm starting to understand how they works, but I want something back :P

Don't get me wrong, I've just started studying Haskell so `Maybe` I'm missing some awesomness but I really want to understand its paradigm and when it's worth using it.
",haskell,,,,,04/10/2012 12:00:39,not constructive,1,203,11,"What are the main benefits of using Haskell for web developing? I'm learning Haskell [for great good](http://urli.st/4n5/uki).

I'm pretty into OOP and the various type systems. I used Java to develop webapps (j2ee, spring, hybernate, struts 1.x), now I'm using regularly Python (pylons, django, sqlalchemy, pymongo) and Javascript. I had a huge improvement in my personal productivity: the lightweight approach, duck typing, awesome iterators, functions as first class citizens, simple syntax and configuration, fast tools like `pip` and `distribute` (and much more) helped me a lot.

But the first reason of my productivity boost is *the Python language itself*.

What are the main benefits of using Haskell for web developing?
For example, how its type inference can really improve my web app? So far, I noticed that when you decorate your function with its type-signature **you are adding a lot of semantics to your program**. I expect all this effort to **come back** in some way, to save many lines of code and to make them sound. I really like the sharp distinction between types and data, I'm starting to understand how they works, but I want something back :P

Don't get me wrong, I've just started studying Haskell so `Maybe` I'm missing some awesomness but I really want to understand its paradigm and when it's worth using it.
",1
10945101,06/08/2012 08:01:11,805266,06/19/2011 11:25:13,3810,119,Densely packed tree of signals,"I collect realtime signals, compute derived signals and store both raw and derived data
in a circular buffer, so I hold only last million of samples. 

Sometimes I need to serialize current values for all signals. So I need something like:

    type D0 a = M.Map SignalType D1
    
    data D1 a = D1 
    	{ foo :: M.Map DoorType a
    	, bar :: D2 a
    	, baz :: a
    	}
    
    data D2 = D2 
    	{
    		quux :: a
    	,	zoo :: a
    	}
    
    data MyData = D0 SignalBuffer 
    
    data CurrentSignals = D0 SignalValue

`SignalBuffer` is a sequence of `SignalValue`. It can be an unboxed array of floats. Haskell can derive `Functor` instances for me, so I can use `fmap` to fetch last `SignalValue` from every `SignalBuffer` and pass the structure to `Aeson` to serialize.

How do I implement a circular buffer API for `SignalBuffer` so I can push new values to all the buffers when new ticks arrive? I'd like to conserve memory, so I think I have to use unboxed arrays. Is it advantageous to use mutable unboxed arrays (`STUArray`?) so array updates don't pile up in memory? Is it possible to use mutable arrays in this setting at all? I'm ready to change `MyData` and `CurrentSignals` to whatever does the job.

I know how to implement circular buffers, the question is how to elegantly apply the updates to `MyData`.

I'm thinking of something like

    type UpdateFunc a = MyData -> SignalValue -> Modifier SignalBuffer
    
    updateAllBuffers :: D0 UpdateFunc -> Modifier MyData

Some signals are ""convolutions"" of other signals (not real convolutions, but a similar kind of processing). To update a buffer for a signal I need to access buffers of other signals - that's why UpdateFunc accepts `MyData` and `SignalValue` and returns a buffer modification function.

`updateAllBuffers` then ""zips"" `D0 UpdateFunc` and `MyData` to get new `MyData`.

Of course I'm ready to use whatever `Modifier` fits my task - it can be a function, a monadic value etc.

",haskell,functor,mutable,unboxing,zipper,,open,0,388,5,"Densely packed tree of signals I collect realtime signals, compute derived signals and store both raw and derived data
in a circular buffer, so I hold only last million of samples. 

Sometimes I need to serialize current values for all signals. So I need something like:

    type D0 a = M.Map SignalType D1
    
    data D1 a = D1 
    	{ foo :: M.Map DoorType a
    	, bar :: D2 a
    	, baz :: a
    	}
    
    data D2 = D2 
    	{
    		quux :: a
    	,	zoo :: a
    	}
    
    data MyData = D0 SignalBuffer 
    
    data CurrentSignals = D0 SignalValue

`SignalBuffer` is a sequence of `SignalValue`. It can be an unboxed array of floats. Haskell can derive `Functor` instances for me, so I can use `fmap` to fetch last `SignalValue` from every `SignalBuffer` and pass the structure to `Aeson` to serialize.

How do I implement a circular buffer API for `SignalBuffer` so I can push new values to all the buffers when new ticks arrive? I'd like to conserve memory, so I think I have to use unboxed arrays. Is it advantageous to use mutable unboxed arrays (`STUArray`?) so array updates don't pile up in memory? Is it possible to use mutable arrays in this setting at all? I'm ready to change `MyData` and `CurrentSignals` to whatever does the job.

I know how to implement circular buffers, the question is how to elegantly apply the updates to `MyData`.

I'm thinking of something like

    type UpdateFunc a = MyData -> SignalValue -> Modifier SignalBuffer
    
    updateAllBuffers :: D0 UpdateFunc -> Modifier MyData

Some signals are ""convolutions"" of other signals (not real convolutions, but a similar kind of processing). To update a buffer for a signal I need to access buffers of other signals - that's why UpdateFunc accepts `MyData` and `SignalValue` and returns a buffer modification function.

`updateAllBuffers` then ""zips"" `D0 UpdateFunc` and `MyData` to get new `MyData`.

Of course I'm ready to use whatever `Modifier` fits my task - it can be a function, a monadic value etc.

",5
10693601,05/21/2012 22:41:48,596757,01/31/2011 11:26:32,957,18,Haskell semantics undefined value,"I am new to Haskell and to its semantics. I learned that not every function can be mapped to an object. For instance:

    square :: Int -> Int 
    square x = x*x

The value of square is mapped to the math object. However, for any non-terminating function, we map it to a special math value `⊥`. I want to know what will happen if I have to do calculation with this undefined value. For instance, I have a set of numbers `Z⊥ ={⊥, 1,0,-1}`. What will be the output if I multiply `⊥` with 1? Since, the type of `⊥` will be undefined, am I able to do multiplication with a well defined type? Since, `⊥` is in the domain of `Z⊥`, I guess I can do the multiplication. But, then it will have to return `⊥`! I would like to have some guidance regarding it!",haskell,undefined,semantic,,,,open,0,152,4,"Haskell semantics undefined value I am new to Haskell and to its semantics. I learned that not every function can be mapped to an object. For instance:

    square :: Int -> Int 
    square x = x*x

The value of square is mapped to the math object. However, for any non-terminating function, we map it to a special math value `⊥`. I want to know what will happen if I have to do calculation with this undefined value. For instance, I have a set of numbers `Z⊥ ={⊥, 1,0,-1}`. What will be the output if I multiply `⊥` with 1? Since, the type of `⊥` will be undefined, am I able to do multiplication with a well defined type? Since, `⊥` is in the domain of `Z⊥`, I guess I can do the multiplication. But, then it will have to return `⊥`! I would like to have some guidance regarding it!",3
5819649,04/28/2011 13:48:09,483876,10/22/2010 06:30:57,63,0,Splitting list into n-tuples,"How can I split a list into list of tuples/lists of specified length?
splitBy :: Int -> [a] -> [[a]]

splitBy 2 ""asdfgh"" should return [""as"", ""df"", ""gh""]",haskell,,,,,,open,0,26,4,"Splitting list into n-tuples How can I split a list into list of tuples/lists of specified length?
splitBy :: Int -> [a] -> [[a]]

splitBy 2 ""asdfgh"" should return [""as"", ""df"", ""gh""]",1
11732469,07/31/2012 02:56:51,525980,12/01/2010 02:10:33,3188,57,Haskell: URL encoding for post data,"I've been looking at [`Network.HTTP`][1], but can't find a way to create properly URL encoded key/value pairs.

How can I generate the post data required from `[(key, value)]` pair list for example? I imagine something like this already exists (perhaps hidden in the `Network.HTTP` package) but I can't find it, and I'd rather not re-invent the wheel.

  [1]: http://hackage.haskell.org/packages/archive/HTTP/4000.2.3/doc/html/Network-HTTP.html",haskell,post,url-encoding,,,,open,0,59,6,"Haskell: URL encoding for post data I've been looking at [`Network.HTTP`][1], but can't find a way to create properly URL encoded key/value pairs.

How can I generate the post data required from `[(key, value)]` pair list for example? I imagine something like this already exists (perhaps hidden in the `Network.HTTP` package) but I can't find it, and I'd rather not re-invent the wheel.

  [1]: http://hackage.haskell.org/packages/archive/HTTP/4000.2.3/doc/html/Network-HTTP.html",3
1496980,09/30/2009 09:18:16,150851,08/05/2009 07:46:24,101,6,Finding index of element in a list in Haskell,"I have a function which finds the maximum value of an exponentiation from a list

    prob99 = maximum $ map (\xs -> (head xs)^(head (tail xs))) numbers

What I need to find is the location of this maximum value in the resultant list. How would I go about this?",haskell,index,,,,,open,0,51,9,"Finding index of element in a list in Haskell I have a function which finds the maximum value of an exponentiation from a list

    prob99 = maximum $ map (\xs -> (head xs)^(head (tail xs))) numbers

What I need to find is the location of this maximum value in the resultant list. How would I go about this?",2
5525576,04/02/2011 20:11:32,671703,03/22/2011 17:39:07,46,0,Grandfather Paradox in Haskell,"I'm trying to write a renamer for a compiler that I'm writing in Haskell.

The renamer scans an AST looking for symbol DEFs, which it enters into a symbol table, and symbol USEs, which it resolves by looking in the symbol table.

In this language, uses can come before or after defs, so it would seem that a 2 pass strategy is required; one pass to find all the defs and build the symbol table, and a second to resolve all the uses.

However, since Haskell is lazy (like me), I figure I can tie-the-knot and pass the renamer the final symbol table before it is actually built.  This is fine as long as I promise to actually build it.  In an imperative programming language, this would be like sending a message back in time.  This does work in Haskell, but care must be taken to not introduce a temporal paradox.

Here's a terse example:

    module Main where

    import Control.Monad.Error
    import Control.Monad.RWS
    import Data.Maybe ( catMaybes )
    import qualified Data.Map as Map
    import Data.Map ( Map )

    type Symtab = Map String Int

    type RenameM = ErrorT String (RWS Symtab String Symtab)

    data Cmd = Def String Int
             | Use String

    renameM :: [Cmd] -> RenameM [(String, Int)]
    renameM = liftM catMaybes . mapM rename1M

    rename1M :: Cmd -> RenameM (Maybe (String, Int))
    rename1M (Def name value) = do
      modify $ \symtab -> Map.insert name value symtab
      return Nothing
    rename1M (Use name) = return . liftM ((,) name) . Map.lookup name =<< ask
    --rename1M (Use name) =
    --  maybe (return Nothing) (return . Just . (,) name) . Map.lookup name =<< ask
    --rename1M (Use name) =
    --  maybe (throwError $ ""Cannot locate "" ++ name) (return . Just . (,) name) . Map.lookup name =<< ask

    rename :: [Cmd] -> IO ()
    rename cmds = do
      let (result, symtab, log) = runRWS (runErrorT $ renameM cmds) symtab Map.empty
      print result

    main :: IO ()
    main = do
      rename [ Use ""foo""
             , Def ""bar"" 2
             , Use ""bar""
             , Def ""foo"" 1
             ]

This is the line where the knot is tied:

      let (result, symtab, log) = runRWS (runErrorT $ renameM cmds) symtab Map.empty

The running symbol table is stored in the `MonadState` of the `RWS`, and the final symbol table is stored in the `MonadReader`.

In the above example, I have 3 versions of `rename1M` for `Use`s (2 are commented out).  In this first form, it works fine.

If you comment out the first `rename1M Use`, and uncomment the second, the program does not terminate.  However, it is, in spirit, no different than the first form.  The difference is that it has two `return`s instead of one, so the `Maybe` returned from `Map.lookup` must be evaluated to see which path to take.

The third form is the one that I really want.  I want to throw an error if I can't find a symbol.  But this version also does not terminate.  Here, the temporal paradox is obvious; the decision about whether the the symbol will be in the table can affect whether it will be table...

So, my question is, is there an elegant way to do what the third version does (throw an error) without running into the paradox?  Send the errors on the `MonadWriter` without allowing the lookup to change the path? Two passes?",haskell,,,,,,open,0,715,4,"Grandfather Paradox in Haskell I'm trying to write a renamer for a compiler that I'm writing in Haskell.

The renamer scans an AST looking for symbol DEFs, which it enters into a symbol table, and symbol USEs, which it resolves by looking in the symbol table.

In this language, uses can come before or after defs, so it would seem that a 2 pass strategy is required; one pass to find all the defs and build the symbol table, and a second to resolve all the uses.

However, since Haskell is lazy (like me), I figure I can tie-the-knot and pass the renamer the final symbol table before it is actually built.  This is fine as long as I promise to actually build it.  In an imperative programming language, this would be like sending a message back in time.  This does work in Haskell, but care must be taken to not introduce a temporal paradox.

Here's a terse example:

    module Main where

    import Control.Monad.Error
    import Control.Monad.RWS
    import Data.Maybe ( catMaybes )
    import qualified Data.Map as Map
    import Data.Map ( Map )

    type Symtab = Map String Int

    type RenameM = ErrorT String (RWS Symtab String Symtab)

    data Cmd = Def String Int
             | Use String

    renameM :: [Cmd] -> RenameM [(String, Int)]
    renameM = liftM catMaybes . mapM rename1M

    rename1M :: Cmd -> RenameM (Maybe (String, Int))
    rename1M (Def name value) = do
      modify $ \symtab -> Map.insert name value symtab
      return Nothing
    rename1M (Use name) = return . liftM ((,) name) . Map.lookup name =<< ask
    --rename1M (Use name) =
    --  maybe (return Nothing) (return . Just . (,) name) . Map.lookup name =<< ask
    --rename1M (Use name) =
    --  maybe (throwError $ ""Cannot locate "" ++ name) (return . Just . (,) name) . Map.lookup name =<< ask

    rename :: [Cmd] -> IO ()
    rename cmds = do
      let (result, symtab, log) = runRWS (runErrorT $ renameM cmds) symtab Map.empty
      print result

    main :: IO ()
    main = do
      rename [ Use ""foo""
             , Def ""bar"" 2
             , Use ""bar""
             , Def ""foo"" 1
             ]

This is the line where the knot is tied:

      let (result, symtab, log) = runRWS (runErrorT $ renameM cmds) symtab Map.empty

The running symbol table is stored in the `MonadState` of the `RWS`, and the final symbol table is stored in the `MonadReader`.

In the above example, I have 3 versions of `rename1M` for `Use`s (2 are commented out).  In this first form, it works fine.

If you comment out the first `rename1M Use`, and uncomment the second, the program does not terminate.  However, it is, in spirit, no different than the first form.  The difference is that it has two `return`s instead of one, so the `Maybe` returned from `Map.lookup` must be evaluated to see which path to take.

The third form is the one that I really want.  I want to throw an error if I can't find a symbol.  But this version also does not terminate.  Here, the temporal paradox is obvious; the decision about whether the the symbol will be in the table can affect whether it will be table...

So, my question is, is there an elegant way to do what the third version does (throw an error) without running into the paradox?  Send the errors on the `MonadWriter` without allowing the lookup to change the path? Two passes?",1
9512152,03/01/2012 07:20:40,1246784,01/13/2012 06:58:13,67,0,printable version of haskell standart library,"Are there any non online documentation version of Haskell Standart library ? In other words, I am searching a book or downloadable tutorial about Haskell library?",haskell,,,,,,open,0,26,6,"printable version of haskell standart library Are there any non online documentation version of Haskell Standart library ? In other words, I am searching a book or downloadable tutorial about Haskell library?",1
3285858,07/19/2010 23:15:27,440960,02/26/2010 08:17:30,10,0,Pattern matching for equality,"    parserChar :: Char -> Parser Char
    parserChar c = Parser ch where
       ch d = case dvChar d of
          Parsed c dp -> Parsed c dp
          _ -> NoParse

The above function is supposed to take a Char `c` and return a Parser which will only match `c`. The function `dvChar d` is going to return either `Parsed char dp` or `NoParse` (where `char` is the next character in the string). Thus, I had hoped that `Parsed c dp` would only match a result in which `char==c`, but what's actually happening is that the Parser returned by this function matches *any* character (even though `c` seems to be bound to some particular Char, as a function argument).

The following function works correctly:

    parserChar :: Char -> Parser Char
    parserChar c = Parser ch where
       ch d = case dvChar d of
          Parsed char dp -> if char == c then Parsed char dp else NoParse
          _ -> NoParse

Manually coding the parser to parse the letter `'a'` also works correctly, in that

    case dvChar d of
       Parsed 'a' dp -> Parsed 'a' dp
       _ -> NoParse
will only return success if the character was `'a'`.

So what gives? Can you only match literals in a pattern like that (e.g. despite the fact that Char is in class Eq, the `if char==c (..)` still needs to be coded manually), or am I doing something wrong?",haskell,pattern-matching,,,,,open,0,305,4,"Pattern matching for equality     parserChar :: Char -> Parser Char
    parserChar c = Parser ch where
       ch d = case dvChar d of
          Parsed c dp -> Parsed c dp
          _ -> NoParse

The above function is supposed to take a Char `c` and return a Parser which will only match `c`. The function `dvChar d` is going to return either `Parsed char dp` or `NoParse` (where `char` is the next character in the string). Thus, I had hoped that `Parsed c dp` would only match a result in which `char==c`, but what's actually happening is that the Parser returned by this function matches *any* character (even though `c` seems to be bound to some particular Char, as a function argument).

The following function works correctly:

    parserChar :: Char -> Parser Char
    parserChar c = Parser ch where
       ch d = case dvChar d of
          Parsed char dp -> if char == c then Parsed char dp else NoParse
          _ -> NoParse

Manually coding the parser to parse the letter `'a'` also works correctly, in that

    case dvChar d of
       Parsed 'a' dp -> Parsed 'a' dp
       _ -> NoParse
will only return success if the character was `'a'`.

So what gives? Can you only match literals in a pattern like that (e.g. despite the fact that Char is in class Eq, the `if char==c (..)` still needs to be coded manually), or am I doing something wrong?",2
6271020,06/07/2011 20:09:48,787903,06/07/2011 17:03:20,1,0,delete duplicate number or char from list in haskell,"i need a script to delete Duplicate num or char from list in haskell 
i use nubby but This is not what I want , i want a script like this

Main>delete [1,3,2,1,4]
output : [3,2,4]

or

Main>delete ['a','b','i','a','l']
output : ['b','i','l']

thank you",haskell,,,,,06/09/2011 17:08:47,not a real question,1,38,9,"delete duplicate number or char from list in haskell i need a script to delete Duplicate num or char from list in haskell 
i use nubby but This is not what I want , i want a script like this

Main>delete [1,3,2,1,4]
output : [3,2,4]

or

Main>delete ['a','b','i','a','l']
output : ['b','i','l']

thank you",1
9504420,02/29/2012 18:11:27,388585,07/10/2010 20:34:03,43,5,Haskell: What is the difference between (+1) and (\x->x+1)?,"Is there a difference between these two functions?

ghct says:

    Prelude> :t (+1)
    (+1) :: Num a => a -> a
    Prelude> :t \x->x+1
    \x->x+1 :: Num a => a -> a

**But**

When I used (+1) syntax in this piece of code:

    data B = B { 
        pos :: Int, 
        cells :: [Int] 
    } deriving (Show)
    
    createB :: Int -> B
    createB n = B 0 (take n $ repeat 0)
    
    size :: B -> Int
    size b = length $ cells b
    
    get_curr :: B -> Int
    get_curr b = (cells b) !! (pos b)
    
    apply :: (Int -> Int) -> B -> B
    apply f b = let n = pos b
                    h = take n $ cells b       -- head
                    t = drop (n + 1) $ cells b -- tail
                    in B n $ h ++ [f (get_curr b)] ++ t

    -- ...
    eval :: [Char] -> StateT B IO ()
    eval [] = return ()
    eval (x:xs) = do
                    b <- get
    
                    put $ case x of
                            '+'         -> apply (+1) b
                            '-'         -> apply (-1) b
                            '>'         -> fwd b
                            '<'         -> back b
                            otherwise   -> b
                    -- ...

prelude (as well as compiler) said:

    > :load BrainFuck.hs 
    [1 of 1] Compiling BrainFuck        ( BrainFuck.hs, interpreted )
    
    BrainFuck.hs:49:40:
        No instance for (Num (Int -> Int))
          arising from the literal `1'
        Possible fix: add an instance declaration for (Num (Int -> Int))
        In the expression: 1
        In the first argument of `apply', namely `(- 1)'
        In the expression: apply (- 1) b
    Failed, modules loaded: none.

What am I doing wrong?
sorry if code is not-so-cool (full source here: https://github.com/nskeip/bf/blob/a755b2d27292593d63fe1e63c2a6e01cebc73520/BrainFuck.hs)",haskell,functional-programming,,,,,open,0,718,9,"Haskell: What is the difference between (+1) and (\x->x+1)? Is there a difference between these two functions?

ghct says:

    Prelude> :t (+1)
    (+1) :: Num a => a -> a
    Prelude> :t \x->x+1
    \x->x+1 :: Num a => a -> a

**But**

When I used (+1) syntax in this piece of code:

    data B = B { 
        pos :: Int, 
        cells :: [Int] 
    } deriving (Show)
    
    createB :: Int -> B
    createB n = B 0 (take n $ repeat 0)
    
    size :: B -> Int
    size b = length $ cells b
    
    get_curr :: B -> Int
    get_curr b = (cells b) !! (pos b)
    
    apply :: (Int -> Int) -> B -> B
    apply f b = let n = pos b
                    h = take n $ cells b       -- head
                    t = drop (n + 1) $ cells b -- tail
                    in B n $ h ++ [f (get_curr b)] ++ t

    -- ...
    eval :: [Char] -> StateT B IO ()
    eval [] = return ()
    eval (x:xs) = do
                    b <- get
    
                    put $ case x of
                            '+'         -> apply (+1) b
                            '-'         -> apply (-1) b
                            '>'         -> fwd b
                            '<'         -> back b
                            otherwise   -> b
                    -- ...

prelude (as well as compiler) said:

    > :load BrainFuck.hs 
    [1 of 1] Compiling BrainFuck        ( BrainFuck.hs, interpreted )
    
    BrainFuck.hs:49:40:
        No instance for (Num (Int -> Int))
          arising from the literal `1'
        Possible fix: add an instance declaration for (Num (Int -> Int))
        In the expression: 1
        In the first argument of `apply', namely `(- 1)'
        In the expression: apply (- 1) b
    Failed, modules loaded: none.

What am I doing wrong?
sorry if code is not-so-cool (full source here: https://github.com/nskeip/bf/blob/a755b2d27292593d63fe1e63c2a6e01cebc73520/BrainFuck.hs)",2
7919722,10/27/2011 17:13:11,997112,10/15/2011 18:05:14,162,0,How to define an algebraic data type,"Apologies for another question, I think I shall re-phrase my original question here as this is probably a pretty simple thing to do:

If i had a language which i wanted to create, like so:

    A B <something> C

this would mean only an input like: A B .... C would be valid. 

In contrast, B A ..... would not be valid.

Is there any easy way to define a constructor such as 'B' must always occur after 'A'? I have only ever seen the A | B type of constructor 'A or B'
",haskell,,,,,,open,0,94,7,"How to define an algebraic data type Apologies for another question, I think I shall re-phrase my original question here as this is probably a pretty simple thing to do:

If i had a language which i wanted to create, like so:

    A B <something> C

this would mean only an input like: A B .... C would be valid. 

In contrast, B A ..... would not be valid.

Is there any easy way to define a constructor such as 'B' must always occur after 'A'? I have only ever seen the A | B type of constructor 'A or B'
",1
10019828,04/04/2012 21:56:58,1198582,06/16/2011 21:39:48,554,6,fun with sequence,"I have a set of five functions, that could be called one of five ways. I'm expressing that with patern-matching like so,



    type Configure = ReaderT Config IO ()
    data Step = PreVal
              | PreProc
              | Proc
              | PostProc
              | PostVal
           
    foo :: Step -> Configure
    foo PreVal = do some stuff
    foo PreProc = do some stuff
and so on `bar` and `baz` are set up similarly

I know how to use `sequence` to call a list of actions. Given a `[Step]`, how could I go about calling `[foo,bar,baz]`. in sequence, while also calling each possible step.

so it should do this
`foo PreVal`
`foo PreProc`
... and so on
`bar Preval`
`bar PreProc`
.. and so on
`baz` ...",haskell,,,,,,open,0,189,3,"fun with sequence I have a set of five functions, that could be called one of five ways. I'm expressing that with patern-matching like so,



    type Configure = ReaderT Config IO ()
    data Step = PreVal
              | PreProc
              | Proc
              | PostProc
              | PostVal
           
    foo :: Step -> Configure
    foo PreVal = do some stuff
    foo PreProc = do some stuff
and so on `bar` and `baz` are set up similarly

I know how to use `sequence` to call a list of actions. Given a `[Step]`, how could I go about calling `[foo,bar,baz]`. in sequence, while also calling each possible step.

so it should do this
`foo PreVal`
`foo PreProc`
... and so on
`bar Preval`
`bar PreProc`
.. and so on
`baz` ...",1
4028210,10/26/2010 21:32:08,488124,10/26/2010 21:01:32,1,0,How do I write a parallel reduction using strategies in Haskell?,"In high-performance computing, sums, products, etc are often calculated using a ""parallel reduction"" that takes _n_ elements and completes in O(log _n_) time (given enough parallelism). In Haskell, we usually use a _fold_ for this kind of calculation, but evaluation time is always linear in the length of the list.

Data Parallel Haskell has some of this built in, but what about in the common framework of a list? Can we do it with `Control.Parallel.Strategies`?

So, assuming `f` is associative, how do we write

`parFold :: (a -> a -> a) -> [a] -> a`

so that `parFold f xs` only needs time logarithmic in `length xs`?",haskell,parallel-processing,,,,,open,0,103,11,"How do I write a parallel reduction using strategies in Haskell? In high-performance computing, sums, products, etc are often calculated using a ""parallel reduction"" that takes _n_ elements and completes in O(log _n_) time (given enough parallelism). In Haskell, we usually use a _fold_ for this kind of calculation, but evaluation time is always linear in the length of the list.

Data Parallel Haskell has some of this built in, but what about in the common framework of a list? Can we do it with `Control.Parallel.Strategies`?

So, assuming `f` is associative, how do we write

`parFold :: (a -> a -> a) -> [a] -> a`

so that `parFold f xs` only needs time logarithmic in `length xs`?",2
6444716,06/22/2011 18:28:52,784102,06/04/2011 16:40:15,60,0,How to write nested loop problem using parallel strategies in Haskell,"I'm playing with parallel strategies and wondering if I'm doing the following the right way. Java code:

	    double x = 0.0;
	    double[] arr = new double[2000];
	    
	    for (int i = 0; i < arr.length; i++) 
	    	arr[i] = i;

	    for (int i = 0; i < arr.length; i++) {
	        x += arr[i] * 5;

	        for (int j = i + 1; j < arr.length; j++)
	        	x -= arr[j] * 3;
	    }
Haskell program which uses parallel strategies to compute the result:


		n = 2000
		ns = [0..n-1]

		segments = chunk 100 ns
				
		chunk n [] = []
		chunk n xs = ys : chunk n zs
		  where (ys,zs) = splitAt n xs

		parCompute = foldl' (+) 0 (map (\ts -> compute ts) segments `using` parList rdeepseq)
		  
		compute ts = foldl' addfunc 0 ts
			where
				addfunc acc i = (acc + x) - (foldl' minusfunc 0 [(i+1)..(n-1)])
					where
						x = (ns!!i) * 5
						minusfunc acc' j = (acc' + x')
							where
								x' = (ns!!j) * 3
								
		main = print parCompute

My questions are:

- is it right to use foldl' here? I thought since all computations need to be done to get the result, I should force evaluate.

- is there a better way to use segments? what common patterns are present in this problem that i can exploit?

- what other strategies could be applied to this problem? Also, any possibility of parallelising just using `par` and `seq` primitives.",haskell,parallel-processing,,,,,open,0,265,11,"How to write nested loop problem using parallel strategies in Haskell I'm playing with parallel strategies and wondering if I'm doing the following the right way. Java code:

	    double x = 0.0;
	    double[] arr = new double[2000];
	    
	    for (int i = 0; i < arr.length; i++) 
	    	arr[i] = i;

	    for (int i = 0; i < arr.length; i++) {
	        x += arr[i] * 5;

	        for (int j = i + 1; j < arr.length; j++)
	        	x -= arr[j] * 3;
	    }
Haskell program which uses parallel strategies to compute the result:


		n = 2000
		ns = [0..n-1]

		segments = chunk 100 ns
				
		chunk n [] = []
		chunk n xs = ys : chunk n zs
		  where (ys,zs) = splitAt n xs

		parCompute = foldl' (+) 0 (map (\ts -> compute ts) segments `using` parList rdeepseq)
		  
		compute ts = foldl' addfunc 0 ts
			where
				addfunc acc i = (acc + x) - (foldl' minusfunc 0 [(i+1)..(n-1)])
					where
						x = (ns!!i) * 5
						minusfunc acc' j = (acc' + x')
							where
								x' = (ns!!j) * 3
								
		main = print parCompute

My questions are:

- is it right to use foldl' here? I thought since all computations need to be done to get the result, I should force evaluate.

- is there a better way to use segments? what common patterns are present in this problem that i can exploit?

- what other strategies could be applied to this problem? Also, any possibility of parallelising just using `par` and `seq` primitives.",2
8367589,12/03/2011 12:19:28,1023733,11/01/2011 12:59:16,41,0,Anyone written Haskell program that accessed the PC VGA port?,Has anyone out there written a Haskell program that accesses the VGA port of a PC?,haskell,vga,,,,12/03/2011 16:38:37,not a real question,1,16,10,Anyone written Haskell program that accessed the PC VGA port? Has anyone out there written a Haskell program that accesses the VGA port of a PC?,2
11720602,07/30/2012 11:28:39,1560821,07/29/2012 10:26:11,1,0,Why isn't whenM part of 'base'?,"`whenM` (and `unlessM`, and `ifM`) seems to me a very useful function. It lets one write:


    whenM (doesDirectoryExist dir)
        ...

instead of 

    dirExists <- doesDirectoryExist dir
    when (dirExists)
        ...

A while ago I got the impression, based on an old documentation of 'base' google gave me, that it was in 'base' (I may be wrong). But now it's in a separate package, 'IfElse'. Why is that? Shouldn't this bread-and-butter be in Control.Monad?

Another question: the xmonad guys have a `whenX` function, which is equivalent to `whenM` except it's hardcoded to work in the `X` monad. Why is that? Why not just use `whenM`? Is it to avoid having a trivial dependency on 'IfElse'? Or is it to make the compiler's error message easier to grasp?",haskell,,,,,07/30/2012 15:18:56,not constructive,1,146,6,"Why isn't whenM part of 'base'? `whenM` (and `unlessM`, and `ifM`) seems to me a very useful function. It lets one write:


    whenM (doesDirectoryExist dir)
        ...

instead of 

    dirExists <- doesDirectoryExist dir
    when (dirExists)
        ...

A while ago I got the impression, based on an old documentation of 'base' google gave me, that it was in 'base' (I may be wrong). But now it's in a separate package, 'IfElse'. Why is that? Shouldn't this bread-and-butter be in Control.Monad?

Another question: the xmonad guys have a `whenX` function, which is equivalent to `whenM` except it's hardcoded to work in the `X` monad. Why is that? Why not just use `whenM`? Is it to avoid having a trivial dependency on 'IfElse'? Or is it to make the compiler's error message easier to grasp?",1
8629738,12/25/2011 13:11:45,551841,12/22/2010 23:43:15,541,48,haskell modulus primitive recursion,"I'm trying to create a modulus function within haskell using primtive recursive functions. I know it's possible (because it's on the list of example functions on wikipedia)

And I know how i'd logically do it too.. But I just can't implement it!

IE, the logic is (not primtive recursion or haskell)

    function mod(a, b){
      while(a > b)
        a -= b
      return a;
    }

Which I can define using recursion (again not haskel)

    function mod(a, b){
      if(a < b) return a;
      return mod(a - b, b);
    } 

But I just can't seem to implement it using primitive recursive functions. I bit which I can't do is the logic of a < b

I think to really solve my problem I need some sort of defined logic such as (again not haskel)

    reduce(a, b)
        = a >= b -> a-b 
        otherwise x
If anyone could help me with any part of this i'd really appreciate it, thanks
",haskell,functional-programming,primitive,,,,open,0,207,4,"haskell modulus primitive recursion I'm trying to create a modulus function within haskell using primtive recursive functions. I know it's possible (because it's on the list of example functions on wikipedia)

And I know how i'd logically do it too.. But I just can't implement it!

IE, the logic is (not primtive recursion or haskell)

    function mod(a, b){
      while(a > b)
        a -= b
      return a;
    }

Which I can define using recursion (again not haskel)

    function mod(a, b){
      if(a < b) return a;
      return mod(a - b, b);
    } 

But I just can't seem to implement it using primitive recursive functions. I bit which I can't do is the logic of a < b

I think to really solve my problem I need some sort of defined logic such as (again not haskel)

    reduce(a, b)
        = a >= b -> a-b 
        otherwise x
If anyone could help me with any part of this i'd really appreciate it, thanks
",3
8878403,01/16/2012 10:06:36,1151746,01/12/2012 11:42:45,24,0,Error in the code Snippet,"Can somebody please explain the error in the following snippet of code

    data Tree a = EmptyTree | Node a ( Tree a) ( Tree a) deriving ( Show,Read, Eq)
    inorder :: Tree a -> [a]
    inorder EmptyTree = []
    inorder (Node a left right) = inorder left ++ [a] ++ inorder right

    main = do
    putStrLn "" Please enter the number""
    number <- readLn :: IO Int
    putStrLn $ ""The num is:"" ++ show number
    xs <- loop number []
    let numtree = foldr treeInsert EmptyTree xs
    print numtree
    ys <- inorder numtree",haskell,,,,,01/16/2012 23:19:02,too localized,1,130,5,"Error in the code Snippet Can somebody please explain the error in the following snippet of code

    data Tree a = EmptyTree | Node a ( Tree a) ( Tree a) deriving ( Show,Read, Eq)
    inorder :: Tree a -> [a]
    inorder EmptyTree = []
    inorder (Node a left right) = inorder left ++ [a] ++ inorder right

    main = do
    putStrLn "" Please enter the number""
    number <- readLn :: IO Int
    putStrLn $ ""The num is:"" ++ show number
    xs <- loop number []
    let numtree = foldr treeInsert EmptyTree xs
    print numtree
    ys <- inorder numtree",1
7046950,08/12/2011 22:24:12,499560,11/07/2010 00:12:33,252,1,Lazy Evaluation and Macros,"I'm used to lazy evaluation from Haskell, and find myself getting irritated with eager-by-default languages now that I've used lazy evaluation properly. This is actually quite damaging, as the other languages I use mainly make lazily evaluating stuff very awkward, normally involving the rolling out of custom iterators and so forth. So just by acquiring some knowledge, I've actually made myself **less** productive in my original languages. Sigh.

But I hear that AST macros offer another clean way of doing the same thing. I've often heard statements like 'Lazy evaluation makes macros redundant' and vice-versa, mostly from sparring Lisp and Haskell communities.

I've dabbled with macros in various Lisp variants. They just seemed like a really organized way of copy and pasting chunks of code around to be handled at compile time. They certainly weren't the holy grail that Lispers like to think it is. But that's almost certainly because I can't use them properly. Of course, having the macro system work on the same core data structure that the language itself is assembled with is really useful, but it's still basically an organized way of copy-and-pasting code around. I acknowledge that basing a macro system on the same AST as the language that allows full runtime alteration is powerful.

What I want to know is, is how can macros be used to concisely and succinctly do what lazy-evaluation does? If I want to process a file line by line without slurping up the whole thing, I just return a list that's had a line-reading routine mapped over it. It's the perfect example of DWIM (do what I mean). I don't even have to think about it.

I clearly don't get macros. I've used them and not been particularly impressed given the hype. So there's something I'm missing that I'm not getting by reading over documentation online. Can someone explain all of this to me?",haskell,macros,lisp,lazy-evaluation,,,open,0,311,4,"Lazy Evaluation and Macros I'm used to lazy evaluation from Haskell, and find myself getting irritated with eager-by-default languages now that I've used lazy evaluation properly. This is actually quite damaging, as the other languages I use mainly make lazily evaluating stuff very awkward, normally involving the rolling out of custom iterators and so forth. So just by acquiring some knowledge, I've actually made myself **less** productive in my original languages. Sigh.

But I hear that AST macros offer another clean way of doing the same thing. I've often heard statements like 'Lazy evaluation makes macros redundant' and vice-versa, mostly from sparring Lisp and Haskell communities.

I've dabbled with macros in various Lisp variants. They just seemed like a really organized way of copy and pasting chunks of code around to be handled at compile time. They certainly weren't the holy grail that Lispers like to think it is. But that's almost certainly because I can't use them properly. Of course, having the macro system work on the same core data structure that the language itself is assembled with is really useful, but it's still basically an organized way of copy-and-pasting code around. I acknowledge that basing a macro system on the same AST as the language that allows full runtime alteration is powerful.

What I want to know is, is how can macros be used to concisely and succinctly do what lazy-evaluation does? If I want to process a file line by line without slurping up the whole thing, I just return a list that's had a line-reading routine mapped over it. It's the perfect example of DWIM (do what I mean). I don't even have to think about it.

I clearly don't get macros. I've used them and not been particularly impressed given the hype. So there's something I'm missing that I'm not getting by reading over documentation online. Can someone explain all of this to me?",4
6479127,06/25/2011 16:44:10,668199,03/20/2011 12:30:13,3,0,Why does the second element get evaluated first in a haskell pair,"if I try > fst(a, b) where a, b are undefined, I get the error that b is undefined. Even on trying snd(a, b) it is b that causes the error first. I have a background in imperative programming. I am wondering if this is some kind of laziness that I don't understand. ",haskell,hugs,,,,,open,0,54,12,"Why does the second element get evaluated first in a haskell pair if I try > fst(a, b) where a, b are undefined, I get the error that b is undefined. Even on trying snd(a, b) it is b that causes the error first. I have a background in imperative programming. I am wondering if this is some kind of laziness that I don't understand. ",2
9093831,02/01/2012 09:56:18,1151746,01/12/2012 11:42:45,120,0,Implement increment function,"I am working on this program for better understanding of haskell and state monad. I made a module Rectangle which has data type Rectangle and a function to increment the length of the rectangle. To increment the length i made a function plus. **Could there have been a better way than this plus function?** Also while incrementing i am doing addition with a new rectangle which is logically incorrect. **How to perform the increment in the correct way?**

    {-# LANGUAGE TemplateHaskell, TypeOperators #-}
    module Rectangle(Rectangle(Rectangle),GlobState(GlobState),plus,newGlobState,r1,r2,r3,incr) where

    import Control.Monad.State hiding (modify)
    import Data.Label (mkLabels)
    import Data.Label.Pure ((:->))
    import Data.Label.PureM

    type Length = Int
    type Width = Int

    data Rectangle = Rectangle Length Width deriving (Eq,Read,Show)

    data GlobState = GlobState { _r1 :: Rectangle , _r2 :: Rectangle , _r3 :: Rectangle } deriving Show
    $(mkLabels [''GlobState])

    plus :: Rectangle -> Rectangle -> Rectangle
    plus (Rectangle x z) (Rectangle y w) = Rectangle (x+y) z

    newGlobState:: GlobState
    newGlobState = GlobState { _r1 = Rectangle 0 10, _r2 = Rectangle 0 10, _r3 = Rectangle 0 10}

    incr :: (GlobState :-> Rectangle) -> State GlobState ()
    incr x = modify x (plus (Rectangle 1 10))

I made a new module for the main function.

    module Main where

    import Rectangle
    import Control.Monad.State hiding (modify)
    import Data.Label (mkLabels)
    import Data.Label.Pure ((:->))
    import Data.Label.PureM

    main :: IO ()
    main = do
        let x = flip execState newGlobState $ do
            incr r1
       	    incr r2
            incr r1
            incr r3
            incr r3
        print x

Is there any way in which instead of giving the default width the compiler prompts the user for width? How can i sort of extract one or more rectangle or any attribute(length or breadth) while doing stateful computation?
",haskell,,,,,,open,0,424,3,"Implement increment function I am working on this program for better understanding of haskell and state monad. I made a module Rectangle which has data type Rectangle and a function to increment the length of the rectangle. To increment the length i made a function plus. **Could there have been a better way than this plus function?** Also while incrementing i am doing addition with a new rectangle which is logically incorrect. **How to perform the increment in the correct way?**

    {-# LANGUAGE TemplateHaskell, TypeOperators #-}
    module Rectangle(Rectangle(Rectangle),GlobState(GlobState),plus,newGlobState,r1,r2,r3,incr) where

    import Control.Monad.State hiding (modify)
    import Data.Label (mkLabels)
    import Data.Label.Pure ((:->))
    import Data.Label.PureM

    type Length = Int
    type Width = Int

    data Rectangle = Rectangle Length Width deriving (Eq,Read,Show)

    data GlobState = GlobState { _r1 :: Rectangle , _r2 :: Rectangle , _r3 :: Rectangle } deriving Show
    $(mkLabels [''GlobState])

    plus :: Rectangle -> Rectangle -> Rectangle
    plus (Rectangle x z) (Rectangle y w) = Rectangle (x+y) z

    newGlobState:: GlobState
    newGlobState = GlobState { _r1 = Rectangle 0 10, _r2 = Rectangle 0 10, _r3 = Rectangle 0 10}

    incr :: (GlobState :-> Rectangle) -> State GlobState ()
    incr x = modify x (plus (Rectangle 1 10))

I made a new module for the main function.

    module Main where

    import Rectangle
    import Control.Monad.State hiding (modify)
    import Data.Label (mkLabels)
    import Data.Label.Pure ((:->))
    import Data.Label.PureM

    main :: IO ()
    main = do
        let x = flip execState newGlobState $ do
            incr r1
       	    incr r2
            incr r1
            incr r3
            incr r3
        print x

Is there any way in which instead of giving the default width the compiler prompts the user for width? How can i sort of extract one or more rectangle or any attribute(length or breadth) while doing stateful computation?
",1
11547252,07/18/2012 17:42:47,1142160,01/11/2012 01:59:46,129,0,Haskell csv-conduit in GHCi,"I've been suggested [csv-conduit](https://github.com/ozataman/csv-conduit) as a good Haskell package to work with CSV files. I want to learn how it works, but the documentation is too terse for a newbie Haskell programmer.

Is there a way for me to figure out how it works by trial-and-error in GHCi?

More specifically, should I load modules and files _from_ GHCi or should I write a simple HS file to load them and _then_ move around interactively?",haskell,csv,,,,,open,0,72,4,"Haskell csv-conduit in GHCi I've been suggested [csv-conduit](https://github.com/ozataman/csv-conduit) as a good Haskell package to work with CSV files. I want to learn how it works, but the documentation is too terse for a newbie Haskell programmer.

Is there a way for me to figure out how it works by trial-and-error in GHCi?

More specifically, should I load modules and files _from_ GHCi or should I write a simple HS file to load them and _then_ move around interactively?",2
8553927,12/18/2011 18:45:44,493729,11/01/2010 15:18:06,303,14,fail handled in the wrong monad,"At least I think that's what's going on.


My main function looks like this:

            main :: IO ()
            main = do 
                putStrLn $ case eval testExpr of
                    Left msg -> ""Error: "" ++ msg
                    Right result -> show result

Where eval is (with some code removed):


            eval :: (Monad m) => Expr Float -> m Float
            eval (MultExpr ""*"" e1 e2) = evalBin (*) e1 e2
            eval (MultExpr ""/"" e1 e2) = evalBin (/) e1 e2
            eval (MultExpr _ _ _ ) = fail ""Invalid operator. Expected * or /""


But, when `eval` fails, I get an error in IO, without the ""Error: "" string appended.",haskell,,,,,,open,0,223,6,"fail handled in the wrong monad At least I think that's what's going on.


My main function looks like this:

            main :: IO ()
            main = do 
                putStrLn $ case eval testExpr of
                    Left msg -> ""Error: "" ++ msg
                    Right result -> show result

Where eval is (with some code removed):


            eval :: (Monad m) => Expr Float -> m Float
            eval (MultExpr ""*"" e1 e2) = evalBin (*) e1 e2
            eval (MultExpr ""/"" e1 e2) = evalBin (/) e1 e2
            eval (MultExpr _ _ _ ) = fail ""Invalid operator. Expected * or /""


But, when `eval` fails, I get an error in IO, without the ""Error: "" string appended.",1
7359986,09/09/2011 10:02:33,936505,09/09/2011 09:41:33,1,0,Haskell complete guide,Does anyone know a complete guide to haskell that present the more advanced topic like GADTs and multi-parameter type classes?,haskell,books,reference,,,10/03/2011 01:06:54,not constructive,1,20,3,Haskell complete guide Does anyone know a complete guide to haskell that present the more advanced topic like GADTs and multi-parameter type classes?,3
4460014,12/16/2010 10:58:27,543261,12/15/2010 11:16:10,21,0,LISP or HASKELL,"LISP or HASKELL, I need to learn functional programming, but I heard that lisp is very old, any advice between those two languages ?",haskell,functional-programming,lisp,common-lisp,clisp,12/16/2010 11:30:11,not constructive,1,24,3,"LISP or HASKELL LISP or HASKELL, I need to learn functional programming, but I heard that lisp is very old, any advice between those two languages ?",5
6568491,07/04/2011 07:26:09,827677,07/04/2011 07:26:09,1,0,C language and Haskell,"The C language is actually a kind of imperative language .

Haskell I suppose is completely different since it's a functional programming language.

Coming from C (not being an expert) , what are the main troubles I'm bound to face in order to achieve a sufficient level of knowledge with Haskell?

Thanks

Melawe
",haskell,,,,,07/04/2011 08:47:02,not constructive,1,49,4,"C language and Haskell The C language is actually a kind of imperative language .

Haskell I suppose is completely different since it's a functional programming language.

Coming from C (not being an expert) , what are the main troubles I'm bound to face in order to achieve a sufficient level of knowledge with Haskell?

Thanks

Melawe
",1
9149183,02/05/2012 12:21:05,849891,07/18/2011 11:05:00,388,20,Tail optimization guarantee - loop encoding in Haskell,"So the short version of my question is, how are we supposed to encode loops in Haskell, *in general*? There is no tail optimization guarantee in Haskell, bang patterns aren't even a part of the standard (right?), and fold/unfold paradigm is *not* guaranteed to work in all situation. Here's [case in point](http://rosettacode.org/wiki/Hamming_numbers#Direct_calculation_through_triples_enumeration) were only bang-patterns did the trick for me of making it run in constant space (not even using `$!` helped ... although [the testing](http://ideone.com/AkbN1) was done at Ideone.com which uses ghc-6.8.2). 

It is basically about a nested loop, which in list-paradigm can be stated as

    prod (sum,concat) . unzip $ 
        [ (c, [r | t]) | k<-[0..kmax], j<-[0..jmax], let (c,r,t)=...]
    prod (f,g) x = (f.fst $ x, g.snd $ x)

Or in pseudocode: 

    let list_store = [] in
    for k from 0 to kmax
        for j from 0 to jmax
            if test(k,j) list_store += [entry(k,j)]
            count += local_count(k,j)
    result = (count, list_store)

Until I added the bang-pattern to it, I got either a memory blow-out or even a stack overflow. But bang patterns are not part of the standard, right?",haskell,loops,tail-call-optimization,,,,open,0,233,8,"Tail optimization guarantee - loop encoding in Haskell So the short version of my question is, how are we supposed to encode loops in Haskell, *in general*? There is no tail optimization guarantee in Haskell, bang patterns aren't even a part of the standard (right?), and fold/unfold paradigm is *not* guaranteed to work in all situation. Here's [case in point](http://rosettacode.org/wiki/Hamming_numbers#Direct_calculation_through_triples_enumeration) were only bang-patterns did the trick for me of making it run in constant space (not even using `$!` helped ... although [the testing](http://ideone.com/AkbN1) was done at Ideone.com which uses ghc-6.8.2). 

It is basically about a nested loop, which in list-paradigm can be stated as

    prod (sum,concat) . unzip $ 
        [ (c, [r | t]) | k<-[0..kmax], j<-[0..jmax], let (c,r,t)=...]
    prod (f,g) x = (f.fst $ x, g.snd $ x)

Or in pseudocode: 

    let list_store = [] in
    for k from 0 to kmax
        for j from 0 to jmax
            if test(k,j) list_store += [entry(k,j)]
            count += local_count(k,j)
    result = (count, list_store)

Until I added the bang-pattern to it, I got either a memory blow-out or even a stack overflow. But bang patterns are not part of the standard, right?",3
4801659,01/26/2011 05:35:23,566607,01/07/2011 08:17:32,6,1,"Is ML/OCaml more or less ""static""/""expressive"" than Haskell","I know both of these language belong to the hipster crowd, and they're both very cool due to the expressiveness of functional programming in general, but I'm interested in a language that allows me:
1. Airtight static type system.
2. Expressiveness.

I have only a little experience with ML, but I recall that once you can get your program to compile, there was a good chance that it worked as I expected. I can't think of any other language that I've tried that accomplishes the same experience. Furthermore, it accomplished this withoug inhibiting the expressiveness of the language. Looking back, to what do I attribute this great experience? I'm not sure, but I can pick out a couple of things:

-> ML took great care to try to check for redundancy in pattern matching.
-> .. Also it checks if you've ""covered all of the cases"" in your pattern match.
-> You can program without odd features like ""null"" being able to be assigned to any object, which completely destroys the safety of any program.
-> Multitypes and tuples types were simple and quick to define and matching on them didn't require tons of syntax/code.

Does haskell accomplish the same? Is it better at being tighter at compile time? Or is it a little more relaxed? Will I be equally as assured that my code ""works if it compiles"" with Haskell?

In terms of expressiveness, it seems like OCaml might be the way to go, because you can quickly drop out of functional programming mode and code imperatively (with blazing fast binary code I hear).

Side note: Wow, there are almost no tags on SO for haskell/Ocaml (what is this .Net land or something)?
",haskell,pattern-matching,ocaml,sml,ml,01/26/2011 08:18:52,not constructive,1,274,8,"Is ML/OCaml more or less ""static""/""expressive"" than Haskell I know both of these language belong to the hipster crowd, and they're both very cool due to the expressiveness of functional programming in general, but I'm interested in a language that allows me:
1. Airtight static type system.
2. Expressiveness.

I have only a little experience with ML, but I recall that once you can get your program to compile, there was a good chance that it worked as I expected. I can't think of any other language that I've tried that accomplishes the same experience. Furthermore, it accomplished this withoug inhibiting the expressiveness of the language. Looking back, to what do I attribute this great experience? I'm not sure, but I can pick out a couple of things:

-> ML took great care to try to check for redundancy in pattern matching.
-> .. Also it checks if you've ""covered all of the cases"" in your pattern match.
-> You can program without odd features like ""null"" being able to be assigned to any object, which completely destroys the safety of any program.
-> Multitypes and tuples types were simple and quick to define and matching on them didn't require tons of syntax/code.

Does haskell accomplish the same? Is it better at being tighter at compile time? Or is it a little more relaxed? Will I be equally as assured that my code ""works if it compiles"" with Haskell?

In terms of expressiveness, it seems like OCaml might be the way to go, because you can quickly drop out of functional programming mode and code imperatively (with blazing fast binary code I hear).

Side note: Wow, there are almost no tags on SO for haskell/Ocaml (what is this .Net land or something)?
",5
1095778,07/08/2009 01:54:43,75889,03/09/2009 23:11:40,408,24,Simple Haskell graphics library?,"I'd like to experiment with Haskell a bit, and I'm hoping to write a small 2D arcade game (Tetris or Breakout).
Is there a good and simple graphics library that will help me to get started quickly?

Btw, I've been experimenting with SDL and wxWidgets, but haven't yet succeeded in running any samples because of dependency problems, working on it...
",haskell,,,,,12/20/2011 19:23:01,not constructive,1,58,4,"Simple Haskell graphics library? I'd like to experiment with Haskell a bit, and I'm hoping to write a small 2D arcade game (Tetris or Breakout).
Is there a good and simple graphics library that will help me to get started quickly?

Btw, I've been experimenting with SDL and wxWidgets, but haven't yet succeeded in running any samples because of dependency problems, working on it...
",1
1853737,12/05/2009 22:50:04,225576,12/05/2009 22:50:04,1,0,importing c++ data types to haskell with ffi,"I'm writing a haskell wrapper for a c++ library and as much as I can import functions from the library to my haskell program, I have no clue how to import c++ data types. For instance I have a function which takes as a parameter a video::E_DRIVER_TYPE EDT_OPENGL type defined in some.h file, and as I said before I know how to import the function with ffi using 

foreign import ccall ...

with the appropriate compiler-mangled function name

but I'm not able to call the function from haskell because I can't figure out how to import/use this specific video driver data type.

Now, I know that you can create types in Haskell but still I need a starting point as to what to define the type to whatever the c++ representation is. (I'm confused at this point)

I would appreciate any kind of help! Thanks",haskell,c++,types,ffi,,,open,0,141,8,"importing c++ data types to haskell with ffi I'm writing a haskell wrapper for a c++ library and as much as I can import functions from the library to my haskell program, I have no clue how to import c++ data types. For instance I have a function which takes as a parameter a video::E_DRIVER_TYPE EDT_OPENGL type defined in some.h file, and as I said before I know how to import the function with ffi using 

foreign import ccall ...

with the appropriate compiler-mangled function name

but I'm not able to call the function from haskell because I can't figure out how to import/use this specific video driver data type.

Now, I know that you can create types in Haskell but still I need a starting point as to what to define the type to whatever the c++ representation is. (I'm confused at this point)

I would appreciate any kind of help! Thanks",4
